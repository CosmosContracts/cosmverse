{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bip39 = void 0;\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst bip39 = __importStar(require(\"bip39\"));\n\nconst englishmnemonic_1 = require(\"./englishmnemonic\");\n\nclass Bip39 {\n  /**\n   * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.\n   *\n   * | Entropy            | Words |\n   * |--------------------|-------|\n   * | 128 bit (16 bytes) |    12 |\n   * | 160 bit (20 bytes) |    15 |\n   * | 192 bit (24 bytes) |    18 |\n   * | 224 bit (28 bytes) |    21 |\n   * | 256 bit (32 bytes) |    24 |\n   *\n   *\n   * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic\n   * @param entropy The entropy to be encoded. This must be cryptographically secure.\n   */\n  static encode(entropy) {\n    const allowedEntropyLengths = [16, 20, 24, 28, 32];\n\n    if (allowedEntropyLengths.indexOf(entropy.length) === -1) {\n      throw new Error(\"invalid input length\");\n    }\n\n    return new englishmnemonic_1.EnglishMnemonic(bip39.entropyToMnemonic(encoding_1.toHex(entropy)));\n  }\n\n  static decode(mnemonic) {\n    return encoding_1.fromHex(bip39.mnemonicToEntropy(mnemonic.toString()));\n  }\n\n  static async mnemonicToSeed(mnemonic, password) {\n    return new Uint8Array(await bip39.mnemonicToSeed(mnemonic.toString(), password));\n  }\n\n}\n\nexports.Bip39 = Bip39;","map":{"version":3,"sources":["../src/bip39.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,UAAA,GAAA,OAAA,CAAA,kBAAA,CAAA;;AACA,MAAA,KAAA,GAAA,YAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,MAAA,iBAAA,GAAA,OAAA,CAAA,mBAAA,CAAA;;AAEA,MAAa,KAAb,CAAkB;AAChB;;;;;;;;;;;;;;AAcG;AACiB,SAAN,MAAM,CAAC,OAAD,EAAoB;AACtC,UAAM,qBAAqB,GAAsB,CAAC,EAAD,EAAK,EAAL,EAAS,EAAT,EAAa,EAAb,EAAiB,EAAjB,CAAjD;;AAEA,QAAI,qBAAqB,CAAC,OAAtB,CAA8B,OAAO,CAAC,MAAtC,MAAkD,CAAC,CAAvD,EAA0D;AACxD,YAAM,IAAI,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,WAAO,IAAI,iBAAA,CAAA,eAAJ,CAAoB,KAAK,CAAC,iBAAN,CAAwB,UAAA,CAAA,KAAA,CAAM,OAAN,CAAxB,CAApB,CAAP;AACD;;AAEmB,SAAN,MAAM,CAAC,QAAD,EAA0B;AAC5C,WAAO,UAAA,CAAA,OAAA,CAAQ,KAAK,CAAC,iBAAN,CAAwB,QAAQ,CAAC,QAAT,EAAxB,CAAR,CAAP;AACD;;AAEiC,eAAd,cAAc,CAAC,QAAD,EAA4B,QAA5B,EAA6C;AAC7E,WAAO,IAAI,UAAJ,CAAe,MAAM,KAAK,CAAC,cAAN,CAAqB,QAAQ,CAAC,QAAT,EAArB,EAA0C,QAA1C,CAArB,CAAP;AACD;;AAhCe;;AAAlB,OAAA,CAAA,KAAA,GAAA,KAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Bip39 = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst bip39 = __importStar(require(\"bip39\"));\nconst englishmnemonic_1 = require(\"./englishmnemonic\");\nclass Bip39 {\n    /**\n     * Encodes raw entropy of length 16, 20, 24, 28 or 32 bytes as an English mnemonic between 12 and 24 words.\n     *\n     * | Entropy            | Words |\n     * |--------------------|-------|\n     * | 128 bit (16 bytes) |    12 |\n     * | 160 bit (20 bytes) |    15 |\n     * | 192 bit (24 bytes) |    18 |\n     * | 224 bit (28 bytes) |    21 |\n     * | 256 bit (32 bytes) |    24 |\n     *\n     *\n     * @see https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki#generating-the-mnemonic\n     * @param entropy The entropy to be encoded. This must be cryptographically secure.\n     */\n    static encode(entropy) {\n        const allowedEntropyLengths = [16, 20, 24, 28, 32];\n        if (allowedEntropyLengths.indexOf(entropy.length) === -1) {\n            throw new Error(\"invalid input length\");\n        }\n        return new englishmnemonic_1.EnglishMnemonic(bip39.entropyToMnemonic(encoding_1.toHex(entropy)));\n    }\n    static decode(mnemonic) {\n        return encoding_1.fromHex(bip39.mnemonicToEntropy(mnemonic.toString()));\n    }\n    static async mnemonicToSeed(mnemonic, password) {\n        return new Uint8Array(await bip39.mnemonicToSeed(mnemonic.toString(), password));\n    }\n}\nexports.Bip39 = Bip39;\n//# sourceMappingURL=bip39.js.map"]},"metadata":{},"sourceType":"script"}