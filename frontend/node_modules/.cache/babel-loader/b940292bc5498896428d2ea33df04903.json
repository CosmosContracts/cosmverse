{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0; // Reducer takes a stream of events T and a ReducerFunc, that\n// materializes a state of type U.\n\nclass Reducer {\n  constructor(stream, reducer, initState) {\n    this.stream = stream;\n    this.reducer = reducer;\n    this.state = initState;\n    this.completed = new Promise((resolve, reject) => {\n      const subscription = this.stream.subscribe({\n        next: evt => {\n          this.state = this.reducer(this.state, evt);\n        },\n        complete: () => {\n          resolve(); // this must happen after resolve, to ensure stream.subscribe() has finished\n\n          subscription.unsubscribe();\n        },\n        error: err => {\n          reject(err); // the stream already closed on error, but unsubscribe to be safe\n\n          subscription.unsubscribe();\n        }\n      });\n    });\n  } // value returns current materialized state\n\n\n  value() {\n    return this.state;\n  } // finished resolves on completed stream, rejects on stream error\n\n\n  async finished() {\n    return this.completed;\n  }\n\n}\n\nexports.Reducer = Reducer;\n\nfunction increment(sum, _) {\n  return sum + 1;\n} // countStream returns a reducer that contains current count\n// of events on the stream\n\n\nfunction countStream(stream) {\n  return new Reducer(stream, increment, 0);\n}\n\nexports.countStream = countStream;\n\nfunction append(list, evt) {\n  return [...list, evt];\n} // asArray maintains an array containing all events that have\n// occurred on the stream\n\n\nfunction asArray(stream) {\n  return new Reducer(stream, append, []);\n}\n\nexports.asArray = asArray;\n\nfunction last(_, event) {\n  return event;\n} // lastValue returns the last value read from the stream, or undefined if no values sent\n\n\nfunction lastValue(stream) {\n  return new Reducer(stream, last, undefined);\n}\n\nexports.lastValue = lastValue;","map":{"version":3,"sources":["../src/reducer.ts"],"names":[],"mappings":";;;;;sFAIA;AACA;;AACA,MAAa,OAAb,CAAoB;AAQlB,EAAA,WAAA,CAAmB,MAAnB,EAAsC,OAAtC,EAAkE,SAAlE,EAA8E;AAC5E,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,KAAL,GAAa,SAAb;AACA,SAAK,SAAL,GAAiB,IAAI,OAAJ,CAAkB,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrD,YAAM,YAAY,GAAG,KAAK,MAAL,CAAY,SAAZ,CAAsB;AACzC,QAAA,IAAI,EAAG,GAAD,IAAW;AACf,eAAK,KAAL,GAAa,KAAK,OAAL,CAAa,KAAK,KAAlB,EAAyB,GAAzB,CAAb;AACD,SAHwC;AAIzC,QAAA,QAAQ,EAAE,MAAK;AACb,UAAA,OAAO,GADM,CAEb;;AACA,UAAA,YAAY,CAAC,WAAb;AACD,SARwC;AASzC,QAAA,KAAK,EAAG,GAAD,IAAa;AAClB,UAAA,MAAM,CAAC,GAAD,CAAN,CADkB,CAElB;;AACA,UAAA,YAAY,CAAC,WAAb;AACD;AAbwC,OAAtB,CAArB;AAeD,KAhBgB,CAAjB;AAiBD,GA7BiB,CA+BlB;;;AACO,EAAA,KAAK,GAAA;AACV,WAAO,KAAK,KAAZ;AACD,GAlCiB,CAoClB;;;AACqB,QAAR,QAAQ,GAAA;AACnB,WAAO,KAAK,SAAZ;AACD;;AAvCiB;;AAApB,OAAA,CAAA,OAAA,GAAA,OAAA;;AA0CA,SAAS,SAAT,CAAsB,GAAtB,EAAmC,CAAnC,EAAuC;AACrC,SAAO,GAAG,GAAG,CAAb;AACD,C,CAED;AACA;;;AACA,SAAgB,WAAhB,CAA+B,MAA/B,EAAgD;AAC9C,SAAO,IAAI,OAAJ,CAAY,MAAZ,EAAoB,SAApB,EAA+B,CAA/B,CAAP;AACD;;AAFD,OAAA,CAAA,WAAA,GAAA,WAAA;;AAIA,SAAS,MAAT,CAAmB,IAAnB,EAAuC,GAAvC,EAA6C;AAC3C,SAAO,CAAC,GAAG,IAAJ,EAAU,GAAV,CAAP;AACD,C,CAED;AACA;;;AACA,SAAgB,OAAhB,CAA2B,MAA3B,EAA4C;AAC1C,SAAO,IAAI,OAAJ,CAA6B,MAA7B,EAAqC,MAArC,EAA6C,EAA7C,CAAP;AACD;;AAFD,OAAA,CAAA,OAAA,GAAA,OAAA;;AAIA,SAAS,IAAT,CAAiB,CAAjB,EAAyB,KAAzB,EAAiC;AAC/B,SAAO,KAAP;AACD,C,CAED;;;AACA,SAAgB,SAAhB,CAA6B,MAA7B,EAA8C;AAC5C,SAAO,IAAI,OAAJ,CAA8B,MAA9B,EAAsC,IAAtC,EAA4C,SAA5C,CAAP;AACD;;AAFD,OAAA,CAAA,SAAA,GAAA,SAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0;\n// Reducer takes a stream of events T and a ReducerFunc, that\n// materializes a state of type U.\nclass Reducer {\n    constructor(stream, reducer, initState) {\n        this.stream = stream;\n        this.reducer = reducer;\n        this.state = initState;\n        this.completed = new Promise((resolve, reject) => {\n            const subscription = this.stream.subscribe({\n                next: (evt) => {\n                    this.state = this.reducer(this.state, evt);\n                },\n                complete: () => {\n                    resolve();\n                    // this must happen after resolve, to ensure stream.subscribe() has finished\n                    subscription.unsubscribe();\n                },\n                error: (err) => {\n                    reject(err);\n                    // the stream already closed on error, but unsubscribe to be safe\n                    subscription.unsubscribe();\n                },\n            });\n        });\n    }\n    // value returns current materialized state\n    value() {\n        return this.state;\n    }\n    // finished resolves on completed stream, rejects on stream error\n    async finished() {\n        return this.completed;\n    }\n}\nexports.Reducer = Reducer;\nfunction increment(sum, _) {\n    return sum + 1;\n}\n// countStream returns a reducer that contains current count\n// of events on the stream\nfunction countStream(stream) {\n    return new Reducer(stream, increment, 0);\n}\nexports.countStream = countStream;\nfunction append(list, evt) {\n    return [...list, evt];\n}\n// asArray maintains an array containing all events that have\n// occurred on the stream\nfunction asArray(stream) {\n    return new Reducer(stream, append, []);\n}\nexports.asArray = asArray;\nfunction last(_, event) {\n    return event;\n}\n// lastValue returns the last value read from the stream, or undefined if no values sent\nfunction lastValue(stream) {\n    return new Reducer(stream, last, undefined);\n}\nexports.lastValue = lastValue;\n//# sourceMappingURL=reducer.js.map"]},"metadata":{},"sourceType":"script"}