{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\n/* eslint-disable no-bitwise */\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\n\nclass Uint32 {\n  constructor(input) {\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < 0 || input > 4294967295) {\n      throw new Error(\"Input not in uint32 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n  /** @deprecated use Uint32.fromBytes */\n\n\n  static fromBigEndianBytes(bytes) {\n    return Uint32.fromBytes(bytes);\n  }\n  /**\n   * Creates a Uint32 from a fixed length byte array.\n   *\n   * @param bytes a list of exactly 4 bytes\n   * @param endianess defaults to big endian\n   */\n\n\n  static fromBytes(bytes) {\n    let endianess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"be\";\n\n    if (bytes.length !== 4) {\n      throw new Error(\"Invalid input length. Expected 4 bytes.\");\n    }\n\n    for (let i = 0; i < bytes.length; ++i) {\n      if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n        throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n      }\n    }\n\n    const beBytes = endianess === \"be\" ? bytes : Array.from(bytes).reverse(); // Use mulitiplication instead of shifting since bitwise operators are defined\n    // on SIGNED int32 in JavaScript and we don't want to risk surprises\n\n    return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);\n  }\n\n  static fromString(str) {\n    if (!str.match(/^[0-9]+$/)) {\n      throw new Error(\"Invalid string format\");\n    }\n\n    return new Uint32(Number.parseInt(str, 10));\n  }\n\n  toBytesBigEndian() {\n    // Use division instead of shifting since bitwise operators are defined\n    // on SIGNED int32 in JavaScript and we don't want to risk surprises\n    return new Uint8Array([Math.floor(this.data / 2 ** 24) & 0xff, Math.floor(this.data / 2 ** 16) & 0xff, Math.floor(this.data / 2 ** 8) & 0xff, Math.floor(this.data / 2 ** 0) & 0xff]);\n  }\n\n  toBytesLittleEndian() {\n    // Use division instead of shifting since bitwise operators are defined\n    // on SIGNED int32 in JavaScript and we don't want to risk surprises\n    return new Uint8Array([Math.floor(this.data / 2 ** 0) & 0xff, Math.floor(this.data / 2 ** 8) & 0xff, Math.floor(this.data / 2 ** 16) & 0xff, Math.floor(this.data / 2 ** 24) & 0xff]);\n  }\n\n  toNumber() {\n    return this.data;\n  }\n\n  toString() {\n    return this.data.toString();\n  }\n\n}\n\nexports.Uint32 = Uint32;\n\nclass Int53 {\n  constructor(input) {\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n      throw new Error(\"Input not in int53 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n\n  static fromString(str) {\n    if (!str.match(/^-?[0-9]+$/)) {\n      throw new Error(\"Invalid string format\");\n    }\n\n    return new Int53(Number.parseInt(str, 10));\n  }\n\n  toNumber() {\n    return this.data;\n  }\n\n  toString() {\n    return this.data.toString();\n  }\n\n}\n\nexports.Int53 = Int53;\n\nclass Uint53 {\n  constructor(input) {\n    const signed = new Int53(input);\n\n    if (signed.toNumber() < 0) {\n      throw new Error(\"Input is negative\");\n    }\n\n    this.data = signed;\n  }\n\n  static fromString(str) {\n    const signed = Int53.fromString(str);\n    return new Uint53(signed.toNumber());\n  }\n\n  toNumber() {\n    return this.data.toNumber();\n  }\n\n  toString() {\n    return this.data.toString();\n  }\n\n}\n\nexports.Uint53 = Uint53;\n\nclass Uint64 {\n  constructor(data) {\n    if (data.isNeg()) {\n      throw new Error(\"Input is negative\");\n    }\n\n    if (data.gt(uint64MaxValue)) {\n      throw new Error(\"Input exceeds uint64 range\");\n    }\n\n    this.data = data;\n  }\n  /** @deprecated use Uint64.fromBytes */\n\n\n  static fromBytesBigEndian(bytes) {\n    return Uint64.fromBytes(bytes);\n  }\n  /**\n   * Creates a Uint64 from a fixed length byte array.\n   *\n   * @param bytes a list of exactly 8 bytes\n   * @param endianess defaults to big endian\n   */\n\n\n  static fromBytes(bytes) {\n    let endianess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"be\";\n\n    if (bytes.length !== 8) {\n      throw new Error(\"Invalid input length. Expected 8 bytes.\");\n    }\n\n    for (let i = 0; i < bytes.length; ++i) {\n      if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n        throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n      }\n    }\n\n    const beBytes = endianess === \"be\" ? Array.from(bytes) : Array.from(bytes).reverse();\n    return new Uint64(new bn_js_1.default(beBytes));\n  }\n\n  static fromString(str) {\n    if (!str.match(/^[0-9]+$/)) {\n      throw new Error(\"Invalid string format\");\n    }\n\n    return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n  }\n\n  static fromNumber(input) {\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    let bigint;\n\n    try {\n      bigint = new bn_js_1.default(input);\n    } catch (_a) {\n      throw new Error(\"Input is not a safe integer\");\n    }\n\n    return new Uint64(bigint);\n  }\n\n  toBytesBigEndian() {\n    return Uint8Array.from(this.data.toArray(\"be\", 8));\n  }\n\n  toBytesLittleEndian() {\n    return Uint8Array.from(this.data.toArray(\"le\", 8));\n  }\n\n  toString() {\n    return this.data.toString(10);\n  }\n\n  toNumber() {\n    return this.data.toNumber();\n  }\n\n}\n\nexports.Uint64 = Uint64; // Assign classes to unused variables in order to verify static interface conformance at compile time.\n// Workaround for https://github.com/microsoft/TypeScript/issues/33892\n\nconst _int53Class = Int53;\nconst _uint53Class = Uint53;\nconst _uint32Class = Uint32;\nconst _uint64Class = Uint64;","map":{"version":3,"sources":["../src/integers.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\n/* eslint-disable no-bitwise */\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\nconst uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\nclass Uint32 {\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < 0 || input > 4294967295) {\n            throw new Error(\"Input not in uint32 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    /** @deprecated use Uint32.fromBytes */\n    static fromBigEndianBytes(bytes) {\n        return Uint32.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint32 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 4 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 4) {\n            throw new Error(\"Invalid input length. Expected 4 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? bytes : Array.from(bytes).reverse();\n        // Use mulitiplication instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint32(beBytes[0] * 2 ** 24 + beBytes[1] * 2 ** 16 + beBytes[2] * 2 ** 8 + beBytes[3]);\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint32(Number.parseInt(str, 10));\n    }\n    toBytesBigEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 24) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 0) & 0xff,\n        ]);\n    }\n    toBytesLittleEndian() {\n        // Use division instead of shifting since bitwise operators are defined\n        // on SIGNED int32 in JavaScript and we don't want to risk surprises\n        return new Uint8Array([\n            Math.floor(this.data / 2 ** 0) & 0xff,\n            Math.floor(this.data / 2 ** 8) & 0xff,\n            Math.floor(this.data / 2 ** 16) & 0xff,\n            Math.floor(this.data / 2 ** 24) & 0xff,\n        ]);\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint32 = Uint32;\nclass Int53 {\n    constructor(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n            throw new Error(\"Input not in int53 range: \" + input.toString());\n        }\n        this.data = input;\n    }\n    static fromString(str) {\n        if (!str.match(/^-?[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Int53(Number.parseInt(str, 10));\n    }\n    toNumber() {\n        return this.data;\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Int53 = Int53;\nclass Uint53 {\n    constructor(input) {\n        const signed = new Int53(input);\n        if (signed.toNumber() < 0) {\n            throw new Error(\"Input is negative\");\n        }\n        this.data = signed;\n    }\n    static fromString(str) {\n        const signed = Int53.fromString(str);\n        return new Uint53(signed.toNumber());\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n    toString() {\n        return this.data.toString();\n    }\n}\nexports.Uint53 = Uint53;\nclass Uint64 {\n    constructor(data) {\n        if (data.isNeg()) {\n            throw new Error(\"Input is negative\");\n        }\n        if (data.gt(uint64MaxValue)) {\n            throw new Error(\"Input exceeds uint64 range\");\n        }\n        this.data = data;\n    }\n    /** @deprecated use Uint64.fromBytes */\n    static fromBytesBigEndian(bytes) {\n        return Uint64.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint64 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 8 bytes\n     * @param endianess defaults to big endian\n     */\n    static fromBytes(bytes, endianess = \"be\") {\n        if (bytes.length !== 8) {\n            throw new Error(\"Invalid input length. Expected 8 bytes.\");\n        }\n        for (let i = 0; i < bytes.length; ++i) {\n            if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n                throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n            }\n        }\n        const beBytes = endianess === \"be\" ? Array.from(bytes) : Array.from(bytes).reverse();\n        return new Uint64(new bn_js_1.default(beBytes));\n    }\n    static fromString(str) {\n        if (!str.match(/^[0-9]+$/)) {\n            throw new Error(\"Invalid string format\");\n        }\n        return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n    static fromNumber(input) {\n        if (Number.isNaN(input)) {\n            throw new Error(\"Input is not a number\");\n        }\n        if (!Number.isInteger(input)) {\n            throw new Error(\"Input is not an integer\");\n        }\n        let bigint;\n        try {\n            bigint = new bn_js_1.default(input);\n        }\n        catch (_a) {\n            throw new Error(\"Input is not a safe integer\");\n        }\n        return new Uint64(bigint);\n    }\n    toBytesBigEndian() {\n        return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n    toBytesLittleEndian() {\n        return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n    toString() {\n        return this.data.toString(10);\n    }\n    toNumber() {\n        return this.data.toNumber();\n    }\n}\nexports.Uint64 = Uint64;\n// Assign classes to unused variables in order to verify static interface conformance at compile time.\n// Workaround for https://github.com/microsoft/TypeScript/issues/33892\nconst _int53Class = Int53;\nconst _uint53Class = Uint53;\nconst _uint32Class = Uint32;\nconst _uint64Class = Uint64;\n//# sourceMappingURL=integers.js.map"]},"metadata":{},"sourceType":"script"}