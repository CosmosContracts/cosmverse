{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar js_sha512_1 = require(\"js-sha512\");\n\nvar ripemd160_1 = __importDefault(require(\"ripemd160\"));\n\nvar sha_js_1 = __importDefault(require(\"sha.js\"));\n\nvar codecimpl_1 = require(\"./generated/codecimpl\");\n\nvar helpers_1 = require(\"./helpers\");\n\nfunction applyLeaf(leaf, key, value) {\n  if (key.length === 0) {\n    throw new Error(\"Missing key\");\n  }\n\n  if (value.length === 0) {\n    throw new Error(\"Missing value\");\n  }\n\n  var pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n  var pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n  var data = new Uint8Array([].concat(_toConsumableArray(ensureBytes(leaf.prefix)), _toConsumableArray(pkey), _toConsumableArray(pvalue)));\n  return doHash(ensureHash(leaf.hash), data);\n}\n\nexports.applyLeaf = applyLeaf;\n\nfunction applyInner(inner, child) {\n  if (child.length === 0) {\n    throw new Error(\"Inner op needs child value\");\n  }\n\n  var preimage = new Uint8Array([].concat(_toConsumableArray(ensureBytes(inner.prefix)), _toConsumableArray(child), _toConsumableArray(ensureBytes(inner.suffix))));\n  return doHash(ensureHash(inner.hash), preimage);\n}\n\nexports.applyInner = applyInner;\n\nfunction ensure(maybe, value) {\n  return maybe === undefined || maybe === null ? value : maybe;\n}\n\nvar ensureHash = function ensureHash(h) {\n  return ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\n};\n\nvar ensureLength = function ensureLength(l) {\n  return ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\n};\n\nvar ensureBytes = function ensureBytes(b) {\n  return ensure(b, new Uint8Array([]));\n};\n\nfunction prepareLeafData(hashOp, lengthOp, data) {\n  var h = doHashOrNoop(hashOp, data);\n  return doLengthOp(lengthOp, h);\n} // doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\n\n\nfunction doHashOrNoop(hashOp, preimage) {\n  if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n    return preimage;\n  }\n\n  return doHash(hashOp, preimage);\n}\n\nfunction rp160(preimage) {\n  // this is a bit tricky to work with besides buffer\n  return new Uint8Array(new ripemd160_1.default().update(helpers_1.toHex(preimage), \"hex\").digest());\n}\n\nfunction s256(preimage) {\n  return new Uint8Array(sha_js_1.default(\"sha256\").update(preimage).digest());\n} // doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\n\n\nfunction doHash(hashOp, preimage) {\n  switch (hashOp) {\n    case codecimpl_1.ics23.HashOp.SHA256:\n      return s256(preimage);\n\n    case codecimpl_1.ics23.HashOp.SHA512:\n      return new Uint8Array(sha_js_1.default(\"sha512\").update(preimage).digest());\n\n    case codecimpl_1.ics23.HashOp.RIPEMD160:\n      // this requires string or Buffer....\n      return rp160(preimage);\n\n    case codecimpl_1.ics23.HashOp.BITCOIN:\n      return rp160(s256(preimage));\n\n    case codecimpl_1.ics23.HashOp.SHA512_256:\n      return new Uint8Array(js_sha512_1.sha512_256.arrayBuffer(preimage));\n  }\n\n  throw new Error(\"Unsupported hashop: \".concat(hashOp));\n}\n\nexports.doHash = doHash; // doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\n\nfunction doLengthOp(lengthOp, data) {\n  switch (lengthOp) {\n    case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n      return data;\n\n    case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n      return new Uint8Array([].concat(_toConsumableArray(encodeVarintProto(data.length)), _toConsumableArray(data)));\n\n    case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n      if (data.length !== 32) {\n        throw new Error(\"Length is \".concat(data.length, \", not 32 bytes\"));\n      }\n\n      return data;\n\n    case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n      if (data.length !== 64) {\n        throw new Error(\"Length is \".concat(data.length, \", not 64 bytes\"));\n      }\n\n      return data;\n\n    case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n      return new Uint8Array([].concat(_toConsumableArray(encodeFixed32LE(data.length)), _toConsumableArray(data)));\n    // TODO\n    // case LengthOp_VAR_RLP:\n    // case LengthOp_FIXED32_BIG:\n    // case LengthOp_FIXED64_BIG:\n    // case LengthOp_FIXED64_LITTLE:\n  }\n\n  throw new Error(\"Unsupported lengthop: \".concat(lengthOp));\n}\n\nfunction encodeVarintProto(n) {\n  var enc = [];\n  var l = n;\n\n  while (l >= 128) {\n    var b = l % 128 + 128;\n    enc = [].concat(_toConsumableArray(enc), [b]);\n    l = l / 128;\n  }\n\n  enc = [].concat(_toConsumableArray(enc), [l]);\n  return new Uint8Array(enc);\n}\n\nfunction encodeFixed32LE(n) {\n  var enc = new Uint8Array(4);\n  var l = n;\n\n  for (var i = enc.length; i > 0; i--) {\n    /* tslint:disable */\n    enc[Math.abs(i - enc.length)] = l % 256;\n    /* tslint:enable */\n\n    l = Math.floor(l / 256);\n  }\n\n  return enc;\n}","map":null,"metadata":{},"sourceType":"script"}