{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBlockId = exports.encodeVersion = exports.encodeBytes = exports.encodeTime = exports.encodeInt = exports.encodeString = exports.Integer = exports.dictionaryToStringMap = exports.may = exports.optional = exports.assertNotEmpty = exports.assertObject = exports.assertArray = exports.assertNumber = exports.assertString = exports.assertBoolean = exports.assertSet = void 0;\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar math_1 = require(\"@cosmjs/math\");\n/**\n * A runtime checker that ensures a given value is set (i.e. not undefined or null)\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n */\n\n\nfunction assertSet(value) {\n  if (value === undefined) {\n    throw new Error(\"Value must not be undefined\");\n  }\n\n  if (value === null) {\n    throw new Error(\"Value must not be null\");\n  }\n\n  return value;\n}\n\nexports.assertSet = assertSet;\n/**\n * A runtime checker that ensures a given value is a boolean\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\n\nfunction assertBoolean(value) {\n  assertSet(value);\n\n  if (typeof value !== \"boolean\") {\n    throw new Error(\"Value must be a boolean\");\n  }\n\n  return value;\n}\n\nexports.assertBoolean = assertBoolean;\n/**\n * A runtime checker that ensures a given value is a string.\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\n\nfunction assertString(value) {\n  assertSet(value);\n\n  if (typeof value !== \"string\") {\n    throw new Error(\"Value must be a string\");\n  }\n\n  return value;\n}\n\nexports.assertString = assertString;\n/**\n * A runtime checker that ensures a given value is a number\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\n\nfunction assertNumber(value) {\n  assertSet(value);\n\n  if (typeof value !== \"number\") {\n    throw new Error(\"Value must be a number\");\n  }\n\n  return value;\n}\n\nexports.assertNumber = assertNumber;\n/**\n * A runtime checker that ensures a given value is an array\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\n\nfunction assertArray(value) {\n  assertSet(value);\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Value must be a an array\");\n  }\n\n  return value;\n}\n\nexports.assertArray = assertArray;\n/**\n * A runtime checker that ensures a given value is an object in the sense of JSON\n * (an unordered collection of keyâ€“value pairs where the keys are strings)\n *\n * This is used when you want to verify that data at runtime matches the expected type.\n * This implies assertSet.\n */\n\nfunction assertObject(value) {\n  assertSet(value);\n\n  if (typeof value !== \"object\") {\n    throw new Error(\"Value must be an object\");\n  } // Exclude special kind of objects like Array, Date or Uint8Array\n  // Object.prototype.toString() returns a specified value:\n  // http://www.ecma-international.org/ecma-262/7.0/index.html#sec-object.prototype.tostring\n\n\n  if (Object.prototype.toString.call(value) !== \"[object Object]\") {\n    throw new Error(\"Value must be a simple object\");\n  }\n\n  return value;\n}\n\nexports.assertObject = assertObject;\n/**\n * Throws an error if value matches the empty value for the\n * given type (array/string of length 0, number of value 0, ...)\n *\n * Otherwise returns the value.\n *\n * This implies assertSet\n */\n\nfunction assertNotEmpty(value) {\n  assertSet(value);\n\n  if (typeof value === \"number\" && value === 0) {\n    throw new Error(\"must provide a non-zero value\");\n  } else if (value.length === 0) {\n    throw new Error(\"must provide a non-empty value\");\n  }\n\n  return value;\n}\n\nexports.assertNotEmpty = assertNotEmpty; // optional uses the value or provides a default\n\nfunction optional(value, fallback) {\n  return value === undefined || value === null ? fallback : value;\n}\n\nexports.optional = optional; // may will run the transform if value is defined, otherwise returns undefined\n\nfunction may(transform, value) {\n  return value === undefined || value === null ? undefined : transform(value);\n}\n\nexports.may = may;\n\nfunction dictionaryToStringMap(obj) {\n  var out = new Map();\n\n  for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n    var key = _Object$keys[_i];\n    var value = obj[key];\n\n    if (typeof value !== \"string\") {\n      throw new Error(\"Found dictionary value of type other than string\");\n    }\n\n    out.set(key, value);\n  }\n\n  return out;\n}\n\nexports.dictionaryToStringMap = dictionaryToStringMap;\n\nvar Integer = /*#__PURE__*/function () {\n  function Integer() {\n    _classCallCheck(this, Integer);\n  }\n\n  _createClass(Integer, null, [{\n    key: \"parse\",\n    value: function parse(input) {\n      var asInt = typeof input === \"number\" ? new math_1.Int53(input) : math_1.Int53.fromString(input);\n      return asInt.toNumber();\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(num) {\n      return new math_1.Int53(num).toString();\n    }\n  }]);\n\n  return Integer;\n}();\n\nexports.Integer = Integer; // Encodings needed for hashing block headers\n// Several of these functions are inspired by https://github.com/nomic-io/js-tendermint/blob/tendermint-0.30/src/\n// See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L193-L195\n\nfunction encodeString(s) {\n  var utf8 = encoding_1.toUtf8(s);\n  return Uint8Array.from([utf8.length].concat(_toConsumableArray(utf8)));\n}\n\nexports.encodeString = encodeString; // See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L79-L87\n\nfunction encodeInt(n) {\n  // eslint-disable-next-line no-bitwise\n  return n >= 0x80 ? Uint8Array.from([n & 0xff | 0x80].concat(_toConsumableArray(encodeInt(n >> 7)))) : Uint8Array.from([n & 0xff]);\n}\n\nexports.encodeInt = encodeInt; // See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L134-L178\n\nfunction encodeTime(time) {\n  var milliseconds = time.getTime();\n  var seconds = Math.floor(milliseconds / 1000);\n  var secondsArray = seconds ? [0x08].concat(_toConsumableArray(encodeInt(seconds))) : new Uint8Array();\n  var nanoseconds = (time.nanoseconds || 0) + milliseconds % 1000 * 1e6;\n  var nanosecondsArray = nanoseconds ? [0x10].concat(_toConsumableArray(encodeInt(nanoseconds))) : new Uint8Array();\n  return Uint8Array.from([].concat(_toConsumableArray(secondsArray), _toConsumableArray(nanosecondsArray)));\n}\n\nexports.encodeTime = encodeTime; // See https://github.com/tendermint/go-amino/blob/v0.15.0/encoder.go#L180-L187\n\nfunction encodeBytes(bytes) {\n  // Since we're only dealing with short byte arrays we don't need a full VarBuffer implementation yet\n  if (bytes.length >= 0x80) throw new Error(\"Not implemented for byte arrays of length 128 or more\");\n  return bytes.length ? Uint8Array.from([bytes.length].concat(_toConsumableArray(bytes))) : new Uint8Array();\n}\n\nexports.encodeBytes = encodeBytes;\n\nfunction encodeVersion(version) {\n  var blockArray = version.block ? Uint8Array.from([0x08].concat(_toConsumableArray(encodeInt(version.block)))) : new Uint8Array();\n  var appArray = version.app ? Uint8Array.from([0x10].concat(_toConsumableArray(encodeInt(version.app)))) : new Uint8Array();\n  return Uint8Array.from([].concat(_toConsumableArray(blockArray), _toConsumableArray(appArray)));\n}\n\nexports.encodeVersion = encodeVersion;\n\nfunction encodeBlockId(blockId) {\n  return Uint8Array.from([0x0a, blockId.hash.length].concat(_toConsumableArray(blockId.hash), [0x12, blockId.parts.hash.length + 4, 0x08, blockId.parts.total, 0x12, blockId.parts.hash.length], _toConsumableArray(blockId.parts.hash)));\n}\n\nexports.encodeBlockId = encodeBlockId;","map":null,"metadata":{},"sourceType":"script"}