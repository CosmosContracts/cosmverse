{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Uint64 = exports.Uint53 = exports.Int53 = exports.Uint32 = void 0;\n/* eslint-disable no-bitwise */\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar uint64MaxValue = new bn_js_1.default(\"18446744073709551615\", 10, \"be\");\n\nvar Uint32 = /*#__PURE__*/function () {\n  function Uint32(input) {\n    _classCallCheck(this, Uint32);\n\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < 0 || input > 4294967295) {\n      throw new Error(\"Input not in uint32 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n  /** @deprecated use Uint32.fromBytes */\n\n\n  _createClass(Uint32, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 24)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 0)) & 0xff]);\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      // Use division instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n      return new Uint8Array([Math.floor(this.data / Math.pow(2, 0)) & 0xff, Math.floor(this.data / Math.pow(2, 8)) & 0xff, Math.floor(this.data / Math.pow(2, 16)) & 0xff, Math.floor(this.data / Math.pow(2, 24)) & 0xff]);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromBigEndianBytes\",\n    value: function fromBigEndianBytes(bytes) {\n      return Uint32.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint32 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 4 bytes\n     * @param endianess defaults to big endian\n     */\n\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(bytes) {\n      var endianess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"be\";\n\n      if (bytes.length !== 4) {\n        throw new Error(\"Invalid input length. Expected 4 bytes.\");\n      }\n\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      }\n\n      var beBytes = endianess === \"be\" ? bytes : Array.from(bytes).reverse(); // Use mulitiplication instead of shifting since bitwise operators are defined\n      // on SIGNED int32 in JavaScript and we don't want to risk surprises\n\n      return new Uint32(beBytes[0] * Math.pow(2, 24) + beBytes[1] * Math.pow(2, 16) + beBytes[2] * Math.pow(2, 8) + beBytes[3]);\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n\n      return new Uint32(Number.parseInt(str, 10));\n    }\n  }]);\n\n  return Uint32;\n}();\n\nexports.Uint32 = Uint32;\n\nvar Int53 = /*#__PURE__*/function () {\n  function Int53(input) {\n    _classCallCheck(this, Int53);\n\n    if (Number.isNaN(input)) {\n      throw new Error(\"Input is not a number\");\n    }\n\n    if (!Number.isInteger(input)) {\n      throw new Error(\"Input is not an integer\");\n    }\n\n    if (input < Number.MIN_SAFE_INTEGER || input > Number.MAX_SAFE_INTEGER) {\n      throw new Error(\"Input not in int53 range: \" + input.toString());\n    }\n\n    this.data = input;\n  }\n\n  _createClass(Int53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^-?[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n\n      return new Int53(Number.parseInt(str, 10));\n    }\n  }]);\n\n  return Int53;\n}();\n\nexports.Int53 = Int53;\n\nvar Uint53 = /*#__PURE__*/function () {\n  function Uint53(input) {\n    _classCallCheck(this, Uint53);\n\n    var signed = new Int53(input);\n\n    if (signed.toNumber() < 0) {\n      throw new Error(\"Input is negative\");\n    }\n\n    this.data = signed;\n  }\n\n  _createClass(Uint53, [{\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString();\n    }\n  }], [{\n    key: \"fromString\",\n    value: function fromString(str) {\n      var signed = Int53.fromString(str);\n      return new Uint53(signed.toNumber());\n    }\n  }]);\n\n  return Uint53;\n}();\n\nexports.Uint53 = Uint53;\n\nvar Uint64 = /*#__PURE__*/function () {\n  function Uint64(data) {\n    _classCallCheck(this, Uint64);\n\n    if (data.isNeg()) {\n      throw new Error(\"Input is negative\");\n    }\n\n    if (data.gt(uint64MaxValue)) {\n      throw new Error(\"Input exceeds uint64 range\");\n    }\n\n    this.data = data;\n  }\n  /** @deprecated use Uint64.fromBytes */\n\n\n  _createClass(Uint64, [{\n    key: \"toBytesBigEndian\",\n    value: function toBytesBigEndian() {\n      return Uint8Array.from(this.data.toArray(\"be\", 8));\n    }\n  }, {\n    key: \"toBytesLittleEndian\",\n    value: function toBytesLittleEndian() {\n      return Uint8Array.from(this.data.toArray(\"le\", 8));\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.data.toString(10);\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.data.toNumber();\n    }\n  }], [{\n    key: \"fromBytesBigEndian\",\n    value: function fromBytesBigEndian(bytes) {\n      return Uint64.fromBytes(bytes);\n    }\n    /**\n     * Creates a Uint64 from a fixed length byte array.\n     *\n     * @param bytes a list of exactly 8 bytes\n     * @param endianess defaults to big endian\n     */\n\n  }, {\n    key: \"fromBytes\",\n    value: function fromBytes(bytes) {\n      var endianess = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"be\";\n\n      if (bytes.length !== 8) {\n        throw new Error(\"Invalid input length. Expected 8 bytes.\");\n      }\n\n      for (var i = 0; i < bytes.length; ++i) {\n        if (!Number.isInteger(bytes[i]) || bytes[i] > 255 || bytes[i] < 0) {\n          throw new Error(\"Invalid value in byte. Found: \" + bytes[i]);\n        }\n      }\n\n      var beBytes = endianess === \"be\" ? Array.from(bytes) : Array.from(bytes).reverse();\n      return new Uint64(new bn_js_1.default(beBytes));\n    }\n  }, {\n    key: \"fromString\",\n    value: function fromString(str) {\n      if (!str.match(/^[0-9]+$/)) {\n        throw new Error(\"Invalid string format\");\n      }\n\n      return new Uint64(new bn_js_1.default(str, 10, \"be\"));\n    }\n  }, {\n    key: \"fromNumber\",\n    value: function fromNumber(input) {\n      if (Number.isNaN(input)) {\n        throw new Error(\"Input is not a number\");\n      }\n\n      if (!Number.isInteger(input)) {\n        throw new Error(\"Input is not an integer\");\n      }\n\n      var bigint;\n\n      try {\n        bigint = new bn_js_1.default(input);\n      } catch (_a) {\n        throw new Error(\"Input is not a safe integer\");\n      }\n\n      return new Uint64(bigint);\n    }\n  }]);\n\n  return Uint64;\n}();\n\nexports.Uint64 = Uint64; // Assign classes to unused variables in order to verify static interface conformance at compile time.\n// Workaround for https://github.com/microsoft/TypeScript/issues/33892\n\nvar _int53Class = Int53;\nvar _uint53Class = Uint53;\nvar _uint32Class = Uint32;\nvar _uint64Class = Uint64;","map":null,"metadata":{},"sourceType":"script"}