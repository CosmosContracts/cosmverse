{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValueAndUpdates = void 0;\n\nconst xstream_1 = require(\"xstream\");\n/**\n * A read only wrapper around DefaultValueProducer that allows\n * to synchronously get the current value using the .value property\n * and listen to to updates by suscribing to the .updates stream\n */\n\n\nclass ValueAndUpdates {\n  constructor(producer) {\n    this.producer = producer;\n    this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);\n  }\n\n  get value() {\n    return this.producer.value;\n  }\n  /**\n   * Resolves as soon as search value is found.\n   *\n   * @param search either a value or a function that must return true when found\n   * @returns the value of the update that caused the search match\n   */\n\n\n  async waitFor(search) {\n    const searchImplementation = typeof search === \"function\" ? search : value => value === search;\n    return new Promise((resolve, reject) => {\n      const subscription = this.updates.subscribe({\n        next: newValue => {\n          if (searchImplementation(newValue)) {\n            resolve(newValue); // MemoryStream.subscribe() calls next with the last value.\n            // Make async to ensure the subscription exists\n\n            setTimeout(() => subscription.unsubscribe(), 0);\n          }\n        },\n        complete: () => {\n          subscription.unsubscribe();\n          reject(\"Update stream completed without expected value\");\n        },\n        error: error => {\n          reject(error);\n        }\n      });\n    });\n  }\n\n}\n\nexports.ValueAndUpdates = ValueAndUpdates;","map":{"version":3,"sources":["../src/valueandupdates.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;AAMA;;;;AAIG;;;AACH,MAAa,eAAb,CAA4B;AAS1B,EAAA,WAAA,CAAmB,QAAnB,EAAoD;AAClD,SAAK,QAAL,GAAgB,QAAhB;AACA,SAAK,OAAL,GAAe,SAAA,CAAA,YAAA,CAAa,gBAAb,CAA8B,KAAK,QAAnC,CAAf;AACD;;AATe,MAAL,KAAK,GAAA;AACd,WAAO,KAAK,QAAL,CAAc,KAArB;AACD;AASD;;;;;AAKG;;;AACiB,QAAP,OAAO,CAAC,MAAD,EAA8B;AAChD,UAAM,oBAAoB,GACxB,OAAO,MAAP,KAAkB,UAAlB,GAAgC,MAAhC,GAAgE,KAAD,IAAuB,KAAK,KAAK,MADlG;AAGA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrC,YAAM,YAAY,GAAG,KAAK,OAAL,CAAa,SAAb,CAAuB;AAC1C,QAAA,IAAI,EAAG,QAAD,IAAa;AACjB,cAAI,oBAAoB,CAAC,QAAD,CAAxB,EAAoC;AAClC,YAAA,OAAO,CAAC,QAAD,CAAP,CADkC,CAGlC;AACA;;AACA,YAAA,UAAU,CAAC,MAAM,YAAY,CAAC,WAAb,EAAP,EAAmC,CAAnC,CAAV;AACD;AACF,SATyC;AAU1C,QAAA,QAAQ,EAAE,MAAK;AACb,UAAA,YAAY,CAAC,WAAb;AACA,UAAA,MAAM,CAAC,gDAAD,CAAN;AACD,SAbyC;AAc1C,QAAA,KAAK,EAAG,KAAD,IAAU;AACf,UAAA,MAAM,CAAC,KAAD,CAAN;AACD;AAhByC,OAAvB,CAArB;AAkBD,KAnBM,CAAP;AAoBD;;AA5CyB;;AAA5B,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ValueAndUpdates = void 0;\nconst xstream_1 = require(\"xstream\");\n/**\n * A read only wrapper around DefaultValueProducer that allows\n * to synchronously get the current value using the .value property\n * and listen to to updates by suscribing to the .updates stream\n */\nclass ValueAndUpdates {\n    constructor(producer) {\n        this.producer = producer;\n        this.updates = xstream_1.MemoryStream.createWithMemory(this.producer);\n    }\n    get value() {\n        return this.producer.value;\n    }\n    /**\n     * Resolves as soon as search value is found.\n     *\n     * @param search either a value or a function that must return true when found\n     * @returns the value of the update that caused the search match\n     */\n    async waitFor(search) {\n        const searchImplementation = typeof search === \"function\" ? search : (value) => value === search;\n        return new Promise((resolve, reject) => {\n            const subscription = this.updates.subscribe({\n                next: (newValue) => {\n                    if (searchImplementation(newValue)) {\n                        resolve(newValue);\n                        // MemoryStream.subscribe() calls next with the last value.\n                        // Make async to ensure the subscription exists\n                        setTimeout(() => subscription.unsubscribe(), 0);\n                    }\n                },\n                complete: () => {\n                    subscription.unsubscribe();\n                    reject(\"Update stream completed without expected value\");\n                },\n                error: (error) => {\n                    reject(error);\n                },\n            });\n        });\n    }\n}\nexports.ValueAndUpdates = ValueAndUpdates;\n//# sourceMappingURL=valueandupdates.js.map"]},"metadata":{},"sourceType":"script"}