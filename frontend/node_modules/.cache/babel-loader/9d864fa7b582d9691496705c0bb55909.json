{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;\n\nconst stream_1 = require(\"@cosmjs/stream\");\n\nconst xstream_1 = require(\"xstream\");\n\nconst streamingsocket_1 = require(\"./streamingsocket\");\n\nvar ConnectionStatus;\n\n(function (ConnectionStatus) {\n  ConnectionStatus[ConnectionStatus[\"Unconnected\"] = 0] = \"Unconnected\";\n  ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n  ConnectionStatus[ConnectionStatus[\"Connected\"] = 2] = \"Connected\";\n  ConnectionStatus[ConnectionStatus[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n/**\n * A wrapper around StreamingSocket that can queue requests.\n */\n\n\nclass QueueingStreamingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    let reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n    this.queue = [];\n    this.isProcessingQueue = false;\n    this.url = url;\n    this.timeout = timeout;\n    this.reconnectedHandler = reconnectedHandler;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);\n    this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    });\n  }\n\n  connect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Connecting);\n    this.socket.connected.then(async () => {\n      this.connectionStatusProducer.update(ConnectionStatus.Connected);\n      return this.processQueue();\n    }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));\n    this.socket.connect();\n  }\n\n  disconnect() {\n    this.connectionStatusProducer.update(ConnectionStatus.Disconnected);\n    this.socket.disconnect();\n  }\n\n  reconnect() {\n    this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n    this.socket.events.subscribe({\n      next: event => {\n        if (!this.eventProducerListener) throw new Error(\"No event producer listener set\");\n        this.eventProducerListener.next(event);\n      },\n      error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected)\n    }); // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    this.socket.connected.then(() => {\n      if (this.reconnectedHandler) {\n        this.reconnectedHandler();\n      }\n    });\n    this.connect();\n  }\n\n  getQueueLength() {\n    return this.queue.length;\n  }\n\n  queueRequest(request) {\n    this.queue.push(request); // We don’t need to wait for the queue to be processed.\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n\n    this.processQueue();\n  }\n\n  async processQueue() {\n    if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {\n      return;\n    }\n\n    this.isProcessingQueue = true;\n    let request;\n\n    while (request = this.queue.shift()) {\n      try {\n        await this.socket.send(request);\n        this.isProcessingQueue = false;\n      } catch (error) {\n        // Probably the connection is down; will try again automatically when reconnected.\n        this.queue.unshift(request);\n        this.isProcessingQueue = false;\n        return;\n      }\n    }\n  }\n\n}\n\nexports.QueueingStreamingSocket = QueueingStreamingSocket;","map":{"version":3,"sources":["../src/queueingstreamingsocket.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.QueueingStreamingSocket = exports.ConnectionStatus = void 0;\nconst stream_1 = require(\"@cosmjs/stream\");\nconst xstream_1 = require(\"xstream\");\nconst streamingsocket_1 = require(\"./streamingsocket\");\nvar ConnectionStatus;\n(function (ConnectionStatus) {\n    ConnectionStatus[ConnectionStatus[\"Unconnected\"] = 0] = \"Unconnected\";\n    ConnectionStatus[ConnectionStatus[\"Connecting\"] = 1] = \"Connecting\";\n    ConnectionStatus[ConnectionStatus[\"Connected\"] = 2] = \"Connected\";\n    ConnectionStatus[ConnectionStatus[\"Disconnected\"] = 3] = \"Disconnected\";\n})(ConnectionStatus = exports.ConnectionStatus || (exports.ConnectionStatus = {}));\n/**\n * A wrapper around StreamingSocket that can queue requests.\n */\nclass QueueingStreamingSocket {\n    constructor(url, timeout = 10000, reconnectedHandler) {\n        this.queue = [];\n        this.isProcessingQueue = false;\n        this.url = url;\n        this.timeout = timeout;\n        this.reconnectedHandler = reconnectedHandler;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n        this.connectionStatusProducer = new stream_1.DefaultValueProducer(ConnectionStatus.Unconnected);\n        this.connectionStatus = new stream_1.ValueAndUpdates(this.connectionStatusProducer);\n        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n        this.socket.events.subscribe({\n            next: (event) => {\n                if (!this.eventProducerListener)\n                    throw new Error(\"No event producer listener set\");\n                this.eventProducerListener.next(event);\n            },\n            error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected),\n        });\n    }\n    connect() {\n        this.connectionStatusProducer.update(ConnectionStatus.Connecting);\n        this.socket.connected.then(async () => {\n            this.connectionStatusProducer.update(ConnectionStatus.Connected);\n            return this.processQueue();\n        }, () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected));\n        this.socket.connect();\n    }\n    disconnect() {\n        this.connectionStatusProducer.update(ConnectionStatus.Disconnected);\n        this.socket.disconnect();\n    }\n    reconnect() {\n        this.socket = new streamingsocket_1.StreamingSocket(this.url, this.timeout);\n        this.socket.events.subscribe({\n            next: (event) => {\n                if (!this.eventProducerListener)\n                    throw new Error(\"No event producer listener set\");\n                this.eventProducerListener.next(event);\n            },\n            error: () => this.connectionStatusProducer.update(ConnectionStatus.Disconnected),\n        });\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.socket.connected.then(() => {\n            if (this.reconnectedHandler) {\n                this.reconnectedHandler();\n            }\n        });\n        this.connect();\n    }\n    getQueueLength() {\n        return this.queue.length;\n    }\n    queueRequest(request) {\n        this.queue.push(request);\n        // We don’t need to wait for the queue to be processed.\n        // eslint-disable-next-line @typescript-eslint/no-floating-promises\n        this.processQueue();\n    }\n    async processQueue() {\n        if (this.isProcessingQueue || this.connectionStatus.value !== ConnectionStatus.Connected) {\n            return;\n        }\n        this.isProcessingQueue = true;\n        let request;\n        while ((request = this.queue.shift())) {\n            try {\n                await this.socket.send(request);\n                this.isProcessingQueue = false;\n            }\n            catch (error) {\n                // Probably the connection is down; will try again automatically when reconnected.\n                this.queue.unshift(request);\n                this.isProcessingQueue = false;\n                return;\n            }\n        }\n    }\n}\nexports.QueueingStreamingSocket = QueueingStreamingSocket;\n//# sourceMappingURL=queueingstreamingsocket.js.map"]},"metadata":{},"sourceType":"script"}