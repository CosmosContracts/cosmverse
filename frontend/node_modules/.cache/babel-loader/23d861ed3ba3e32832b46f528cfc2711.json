{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocketWrapper = void 0;\n\nconst isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\n\nfunction environmentIsNodeJs() {\n  return typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\";\n}\n/**\n * A thin wrapper around isomorphic-ws' WebSocket class that adds\n * - constant message/error/open/close handlers\n * - explict connection via a connect() method\n * - type support for events\n * - handling of corner cases in the open and close behaviour\n */\n\n\nclass SocketWrapper {\n  constructor(url, messageHandler, errorHandler, openHandler, closeHandler) {\n    let timeout = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10000;\n    this.closed = false;\n    this.connected = new Promise((resolve, reject) => {\n      this.connectedResolver = resolve;\n      this.connectedRejecter = reject;\n    });\n    this.url = url;\n    this.messageHandler = messageHandler;\n    this.errorHandler = errorHandler;\n    this.openHandler = openHandler;\n    this.closeHandler = closeHandler;\n    this.timeout = timeout;\n  }\n  /**\n   * returns a promise that resolves when connection is open\n   */\n\n\n  connect() {\n    const socket = new isomorphic_ws_1.default(this.url);\n\n    socket.onerror = error => {\n      this.clearTimeout();\n\n      if (this.errorHandler) {\n        this.errorHandler(error);\n      }\n    };\n\n    socket.onmessage = messageEvent => {\n      this.messageHandler({\n        type: messageEvent.type,\n        data: messageEvent.data\n      });\n    };\n\n    socket.onopen = _ => {\n      this.clearTimeout(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      this.connectedResolver();\n\n      if (this.openHandler) {\n        this.openHandler();\n      }\n    };\n\n    socket.onclose = closeEvent => {\n      this.closed = true;\n\n      if (this.closeHandler) {\n        this.closeHandler(closeEvent);\n      }\n    };\n\n    const started = Date.now();\n    this.timeoutId = setTimeout(() => {\n      socket.onmessage = () => 0;\n\n      socket.onerror = () => 0;\n\n      socket.onopen = () => 0;\n\n      socket.onclose = () => 0;\n\n      socket.close();\n      this.socket = undefined;\n      const elapsed = Math.floor(Date.now() - started); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);\n    }, this.timeout);\n    this.socket = socket;\n  }\n  /**\n   * Closes an established connection and aborts other connection states\n   */\n\n\n  disconnect() {\n    if (!this.socket) {\n      throw new Error(\"Socket undefined. This must be called after connecting.\");\n    }\n\n    this.clearTimeout();\n\n    switch (this.socket.readyState) {\n      case isomorphic_ws_1.default.OPEN:\n        this.socket.close(1000\n        /* Normal Closure */\n        );\n        break;\n\n      case isomorphic_ws_1.default.CLOSED:\n        // nothing to be done\n        break;\n\n      case isomorphic_ws_1.default.CONNECTING:\n        // imitate missing abort API\n        this.socket.onopen = () => 0;\n\n        this.socket.onclose = () => 0;\n\n        this.socket.onerror = () => 0;\n\n        this.socket.onmessage = () => 0;\n\n        this.socket = undefined;\n\n        if (this.closeHandler) {\n          this.closeHandler({\n            wasClean: false,\n            code: 4001\n          });\n        }\n\n        break;\n\n      case isomorphic_ws_1.default.CLOSING:\n        // already closing. Let it proceed\n        break;\n\n      default:\n        throw new Error(`Unknown readyState: ${this.socket.readyState}`);\n    }\n  }\n\n  async send(data) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket) {\n        throw new Error(\"Socket undefined. This must be called after connecting.\");\n      }\n\n      if (this.closed) {\n        throw new Error(\"Socket was closed, so no data can be sent anymore.\");\n      } // this exception should be thrown by send() automatically according to\n      // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n\n\n      if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {\n        throw new Error(\"Websocket is not open\");\n      }\n\n      if (environmentIsNodeJs()) {\n        this.socket.send(data, err => err ? reject(err) : resolve());\n      } else {\n        // Browser websocket send method does not accept a callback\n        this.socket.send(data);\n        resolve();\n      }\n    });\n  }\n  /**\n   * Clears the timeout function, such that no timeout error will be raised anymore. This should be\n   * called when the connection is established, a connection error occurred or the socket is disconnected.\n   *\n   * This method must not be called before `connect()`.\n   * This method is idempotent.\n   */\n\n\n  clearTimeout() {\n    if (!this.timeoutId) {\n      throw new Error(\"Timeout ID not set. This should not happen and usually means connect() was not called.\");\n    } // Note: do not unset this.timeoutId to allow multiple calls to this function\n\n\n    clearTimeout(this.timeoutId);\n  }\n\n}\n\nexports.SocketWrapper = SocketWrapper;","map":{"version":3,"sources":["../src/socketwrapper.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SocketWrapper = void 0;\nconst isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\nfunction environmentIsNodeJs() {\n    return (typeof process !== \"undefined\" &&\n        typeof process.versions !== \"undefined\" &&\n        typeof process.versions.node !== \"undefined\");\n}\n/**\n * A thin wrapper around isomorphic-ws' WebSocket class that adds\n * - constant message/error/open/close handlers\n * - explict connection via a connect() method\n * - type support for events\n * - handling of corner cases in the open and close behaviour\n */\nclass SocketWrapper {\n    constructor(url, messageHandler, errorHandler, openHandler, closeHandler, timeout = 10000) {\n        this.closed = false;\n        this.connected = new Promise((resolve, reject) => {\n            this.connectedResolver = resolve;\n            this.connectedRejecter = reject;\n        });\n        this.url = url;\n        this.messageHandler = messageHandler;\n        this.errorHandler = errorHandler;\n        this.openHandler = openHandler;\n        this.closeHandler = closeHandler;\n        this.timeout = timeout;\n    }\n    /**\n     * returns a promise that resolves when connection is open\n     */\n    connect() {\n        const socket = new isomorphic_ws_1.default(this.url);\n        socket.onerror = (error) => {\n            this.clearTimeout();\n            if (this.errorHandler) {\n                this.errorHandler(error);\n            }\n        };\n        socket.onmessage = (messageEvent) => {\n            this.messageHandler({\n                type: messageEvent.type,\n                data: messageEvent.data,\n            });\n        };\n        socket.onopen = (_) => {\n            this.clearTimeout();\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.connectedResolver();\n            if (this.openHandler) {\n                this.openHandler();\n            }\n        };\n        socket.onclose = (closeEvent) => {\n            this.closed = true;\n            if (this.closeHandler) {\n                this.closeHandler(closeEvent);\n            }\n        };\n        const started = Date.now();\n        this.timeoutId = setTimeout(() => {\n            socket.onmessage = () => 0;\n            socket.onerror = () => 0;\n            socket.onopen = () => 0;\n            socket.onclose = () => 0;\n            socket.close();\n            this.socket = undefined;\n            const elapsed = Math.floor(Date.now() - started);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            this.connectedRejecter(`Connection attempt timed out after ${elapsed} ms`);\n        }, this.timeout);\n        this.socket = socket;\n    }\n    /**\n     * Closes an established connection and aborts other connection states\n     */\n    disconnect() {\n        if (!this.socket) {\n            throw new Error(\"Socket undefined. This must be called after connecting.\");\n        }\n        this.clearTimeout();\n        switch (this.socket.readyState) {\n            case isomorphic_ws_1.default.OPEN:\n                this.socket.close(1000 /* Normal Closure */);\n                break;\n            case isomorphic_ws_1.default.CLOSED:\n                // nothing to be done\n                break;\n            case isomorphic_ws_1.default.CONNECTING:\n                // imitate missing abort API\n                this.socket.onopen = () => 0;\n                this.socket.onclose = () => 0;\n                this.socket.onerror = () => 0;\n                this.socket.onmessage = () => 0;\n                this.socket = undefined;\n                if (this.closeHandler) {\n                    this.closeHandler({ wasClean: false, code: 4001 });\n                }\n                break;\n            case isomorphic_ws_1.default.CLOSING:\n                // already closing. Let it proceed\n                break;\n            default:\n                throw new Error(`Unknown readyState: ${this.socket.readyState}`);\n        }\n    }\n    async send(data) {\n        return new Promise((resolve, reject) => {\n            if (!this.socket) {\n                throw new Error(\"Socket undefined. This must be called after connecting.\");\n            }\n            if (this.closed) {\n                throw new Error(\"Socket was closed, so no data can be sent anymore.\");\n            }\n            // this exception should be thrown by send() automatically according to\n            // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n            if (this.socket.readyState !== isomorphic_ws_1.default.OPEN) {\n                throw new Error(\"Websocket is not open\");\n            }\n            if (environmentIsNodeJs()) {\n                this.socket.send(data, (err) => (err ? reject(err) : resolve()));\n            }\n            else {\n                // Browser websocket send method does not accept a callback\n                this.socket.send(data);\n                resolve();\n            }\n        });\n    }\n    /**\n     * Clears the timeout function, such that no timeout error will be raised anymore. This should be\n     * called when the connection is established, a connection error occurred or the socket is disconnected.\n     *\n     * This method must not be called before `connect()`.\n     * This method is idempotent.\n     */\n    clearTimeout() {\n        if (!this.timeoutId) {\n            throw new Error(\"Timeout ID not set. This should not happen and usually means connect() was not called.\");\n        }\n        // Note: do not unset this.timeoutId to allow multiple calls to this function\n        clearTimeout(this.timeoutId);\n    }\n}\nexports.SocketWrapper = SocketWrapper;\n//# sourceMappingURL=socketwrapper.js.map"]},"metadata":{},"sourceType":"script"}