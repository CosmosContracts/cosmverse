{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst js_sha512_1 = require(\"js-sha512\");\n\nconst ripemd160_1 = __importDefault(require(\"ripemd160\"));\n\nconst sha_js_1 = __importDefault(require(\"sha.js\"));\n\nconst codecimpl_1 = require(\"./generated/codecimpl\");\n\nconst helpers_1 = require(\"./helpers\");\n\nfunction applyLeaf(leaf, key, value) {\n  if (key.length === 0) {\n    throw new Error(\"Missing key\");\n  }\n\n  if (value.length === 0) {\n    throw new Error(\"Missing value\");\n  }\n\n  const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n  const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n  const data = new Uint8Array([...ensureBytes(leaf.prefix), ...pkey, ...pvalue]);\n  return doHash(ensureHash(leaf.hash), data);\n}\n\nexports.applyLeaf = applyLeaf;\n\nfunction applyInner(inner, child) {\n  if (child.length === 0) {\n    throw new Error(\"Inner op needs child value\");\n  }\n\n  const preimage = new Uint8Array([...ensureBytes(inner.prefix), ...child, ...ensureBytes(inner.suffix)]);\n  return doHash(ensureHash(inner.hash), preimage);\n}\n\nexports.applyInner = applyInner;\n\nfunction ensure(maybe, value) {\n  return maybe === undefined || maybe === null ? value : maybe;\n}\n\nconst ensureHash = h => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\n\nconst ensureLength = l => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\n\nconst ensureBytes = b => ensure(b, new Uint8Array([]));\n\nfunction prepareLeafData(hashOp, lengthOp, data) {\n  const h = doHashOrNoop(hashOp, data);\n  return doLengthOp(lengthOp, h);\n} // doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\n\n\nfunction doHashOrNoop(hashOp, preimage) {\n  if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n    return preimage;\n  }\n\n  return doHash(hashOp, preimage);\n}\n\nfunction rp160(preimage) {\n  // this is a bit tricky to work with besides buffer\n  return new Uint8Array(new ripemd160_1.default().update(helpers_1.toHex(preimage), \"hex\").digest());\n}\n\nfunction s256(preimage) {\n  return new Uint8Array(sha_js_1.default(\"sha256\").update(preimage).digest());\n} // doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\n\n\nfunction doHash(hashOp, preimage) {\n  switch (hashOp) {\n    case codecimpl_1.ics23.HashOp.SHA256:\n      return s256(preimage);\n\n    case codecimpl_1.ics23.HashOp.SHA512:\n      return new Uint8Array(sha_js_1.default(\"sha512\").update(preimage).digest());\n\n    case codecimpl_1.ics23.HashOp.RIPEMD160:\n      // this requires string or Buffer....\n      return rp160(preimage);\n\n    case codecimpl_1.ics23.HashOp.BITCOIN:\n      return rp160(s256(preimage));\n\n    case codecimpl_1.ics23.HashOp.SHA512_256:\n      return new Uint8Array(js_sha512_1.sha512_256.arrayBuffer(preimage));\n  }\n\n  throw new Error(`Unsupported hashop: ${hashOp}`);\n}\n\nexports.doHash = doHash; // doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\n\nfunction doLengthOp(lengthOp, data) {\n  switch (lengthOp) {\n    case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n      return data;\n\n    case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n      return new Uint8Array([...encodeVarintProto(data.length), ...data]);\n\n    case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n      if (data.length !== 32) {\n        throw new Error(`Length is ${data.length}, not 32 bytes`);\n      }\n\n      return data;\n\n    case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n      if (data.length !== 64) {\n        throw new Error(`Length is ${data.length}, not 64 bytes`);\n      }\n\n      return data;\n\n    case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n      return new Uint8Array([...encodeFixed32LE(data.length), ...data]);\n    // TODO\n    // case LengthOp_VAR_RLP:\n    // case LengthOp_FIXED32_BIG:\n    // case LengthOp_FIXED64_BIG:\n    // case LengthOp_FIXED64_LITTLE:\n  }\n\n  throw new Error(`Unsupported lengthop: ${lengthOp}`);\n}\n\nfunction encodeVarintProto(n) {\n  let enc = [];\n  let l = n;\n\n  while (l >= 128) {\n    const b = l % 128 + 128;\n    enc = [...enc, b];\n    l = l / 128;\n  }\n\n  enc = [...enc, l];\n  return new Uint8Array(enc);\n}\n\nfunction encodeFixed32LE(n) {\n  const enc = new Uint8Array(4);\n  let l = n;\n\n  for (let i = enc.length; i > 0; i--) {\n    /* tslint:disable */\n    enc[Math.abs(i - enc.length)] = l % 256;\n    /* tslint:enable */\n\n    l = Math.floor(l / 256);\n  }\n\n  return enc;\n}","map":{"version":3,"sources":["../src/ops.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst js_sha512_1 = require(\"js-sha512\");\nconst ripemd160_1 = __importDefault(require(\"ripemd160\"));\nconst sha_js_1 = __importDefault(require(\"sha.js\"));\nconst codecimpl_1 = require(\"./generated/codecimpl\");\nconst helpers_1 = require(\"./helpers\");\nfunction applyLeaf(leaf, key, value) {\n    if (key.length === 0) {\n        throw new Error(\"Missing key\");\n    }\n    if (value.length === 0) {\n        throw new Error(\"Missing value\");\n    }\n    const pkey = prepareLeafData(ensureHash(leaf.prehashKey), ensureLength(leaf.length), key);\n    const pvalue = prepareLeafData(ensureHash(leaf.prehashValue), ensureLength(leaf.length), value);\n    const data = new Uint8Array([\n        ...ensureBytes(leaf.prefix),\n        ...pkey,\n        ...pvalue\n    ]);\n    return doHash(ensureHash(leaf.hash), data);\n}\nexports.applyLeaf = applyLeaf;\nfunction applyInner(inner, child) {\n    if (child.length === 0) {\n        throw new Error(\"Inner op needs child value\");\n    }\n    const preimage = new Uint8Array([\n        ...ensureBytes(inner.prefix),\n        ...child,\n        ...ensureBytes(inner.suffix)\n    ]);\n    return doHash(ensureHash(inner.hash), preimage);\n}\nexports.applyInner = applyInner;\nfunction ensure(maybe, value) {\n    return maybe === undefined || maybe === null ? value : maybe;\n}\nconst ensureHash = (h) => ensure(h, codecimpl_1.ics23.HashOp.NO_HASH);\nconst ensureLength = (l) => ensure(l, codecimpl_1.ics23.LengthOp.NO_PREFIX);\nconst ensureBytes = (b) => ensure(b, new Uint8Array([]));\nfunction prepareLeafData(hashOp, lengthOp, data) {\n    const h = doHashOrNoop(hashOp, data);\n    return doLengthOp(lengthOp, h);\n}\n// doHashOrNoop will return the preimage untouched if hashOp == NONE,\n// otherwise, perform doHash\nfunction doHashOrNoop(hashOp, preimage) {\n    if (hashOp === codecimpl_1.ics23.HashOp.NO_HASH) {\n        return preimage;\n    }\n    return doHash(hashOp, preimage);\n}\nfunction rp160(preimage) {\n    // this is a bit tricky to work with besides buffer\n    return new Uint8Array(new ripemd160_1.default().update(helpers_1.toHex(preimage), \"hex\").digest());\n}\nfunction s256(preimage) {\n    return new Uint8Array(sha_js_1.default(\"sha256\")\n        .update(preimage)\n        .digest());\n}\n// doHash will preform the specified hash on the preimage.\n// if hashOp == NONE, it will return an error (use doHashOrNoop if you want different behavior)\nfunction doHash(hashOp, preimage) {\n    switch (hashOp) {\n        case codecimpl_1.ics23.HashOp.SHA256:\n            return s256(preimage);\n        case codecimpl_1.ics23.HashOp.SHA512:\n            return new Uint8Array(sha_js_1.default(\"sha512\")\n                .update(preimage)\n                .digest());\n        case codecimpl_1.ics23.HashOp.RIPEMD160:\n            // this requires string or Buffer....\n            return rp160(preimage);\n        case codecimpl_1.ics23.HashOp.BITCOIN:\n            return rp160(s256(preimage));\n        case codecimpl_1.ics23.HashOp.SHA512_256:\n            return new Uint8Array(js_sha512_1.sha512_256.arrayBuffer(preimage));\n    }\n    throw new Error(`Unsupported hashop: ${hashOp}`);\n}\nexports.doHash = doHash;\n// doLengthOp will calculate the proper prefix and return it prepended\n//   doLengthOp(op, data) -> length(data) || data\nfunction doLengthOp(lengthOp, data) {\n    switch (lengthOp) {\n        case codecimpl_1.ics23.LengthOp.NO_PREFIX:\n            return data;\n        case codecimpl_1.ics23.LengthOp.VAR_PROTO:\n            return new Uint8Array([...encodeVarintProto(data.length), ...data]);\n        case codecimpl_1.ics23.LengthOp.REQUIRE_32_BYTES:\n            if (data.length !== 32) {\n                throw new Error(`Length is ${data.length}, not 32 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.REQUIRE_64_BYTES:\n            if (data.length !== 64) {\n                throw new Error(`Length is ${data.length}, not 64 bytes`);\n            }\n            return data;\n        case codecimpl_1.ics23.LengthOp.FIXED32_LITTLE:\n            return new Uint8Array([...encodeFixed32LE(data.length), ...data]);\n        // TODO\n        // case LengthOp_VAR_RLP:\n        // case LengthOp_FIXED32_BIG:\n        // case LengthOp_FIXED64_BIG:\n        // case LengthOp_FIXED64_LITTLE:\n    }\n    throw new Error(`Unsupported lengthop: ${lengthOp}`);\n}\nfunction encodeVarintProto(n) {\n    let enc = [];\n    let l = n;\n    while (l >= 128) {\n        const b = (l % 128) + 128;\n        enc = [...enc, b];\n        l = l / 128;\n    }\n    enc = [...enc, l];\n    return new Uint8Array(enc);\n}\nfunction encodeFixed32LE(n) {\n    const enc = new Uint8Array(4);\n    let l = n;\n    for (let i = enc.length; i > 0; i--) {\n        /* tslint:disable */\n        enc[Math.abs(i - enc.length)] = l % 256;\n        /* tslint:enable */\n        l = Math.floor(l / 256);\n    }\n    return enc;\n}\n//# sourceMappingURL=ops.js.map"]},"metadata":{},"sourceType":"script"}