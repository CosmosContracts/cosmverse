{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningCosmosClient = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\n\nconst cosmosclient_1 = require(\"./cosmosclient\");\n\nconst fee_1 = require(\"./fee\");\n\nconst lcdapi_1 = require(\"./lcdapi\");\n\nconst tx_1 = require(\"./tx\");\n\nconst defaultGasPrice = fee_1.GasPrice.fromString(\"0.025ucosm\");\nconst defaultGasLimits = {\n  send: 80000\n};\n\nclass SigningCosmosClient extends cosmosclient_1.CosmosClient {\n  /**\n   * Creates a new client with signing capability to interact with a Cosmos SDK blockchain. This is the bigger brother of CosmosClient.\n   *\n   * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n   * for the lifetime of your application. When switching backends, a new instance must be created.\n   *\n   * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n   * @param signerAddress The address that will sign transactions using this instance. The `signer` must be able to sign with this address.\n   * @param signer An implementation of OfflineAminoSigner which can provide signatures for transactions, potentially requiring user input.\n   * @param gasPrice The price paid per unit of gas\n   * @param gasLimits Custom overrides for gas limits related to specific transaction types\n   * @param broadcastMode Defines at which point of the transaction processing the broadcastTx method returns\n   */\n  constructor(apiUrl, signerAddress, signer) {\n    let gasPrice = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultGasPrice;\n    let gasLimits = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    let broadcastMode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : lcdapi_1.BroadcastMode.Block;\n    super(apiUrl, broadcastMode);\n    this.anyValidAddress = signerAddress;\n    this.signerAddress = signerAddress;\n    this.signer = signer;\n    this.fees = fee_1.buildFeeTable(gasPrice, defaultGasLimits, gasLimits);\n  }\n\n  async getSequence(address) {\n    return super.getSequence(address || this.signerAddress);\n  }\n\n  async getAccount(address) {\n    return super.getAccount(address || this.signerAddress);\n  }\n\n  async sendTokens(recipientAddress, amount) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const sendMsg = {\n      type: \"cosmos-sdk/MsgSend\",\n      value: {\n        from_address: this.signerAddress,\n        to_address: recipientAddress,\n        amount: amount\n      }\n    };\n    return this.signAndBroadcast([sendMsg], this.fees.send, memo);\n  }\n  /**\n   * Gets account number and sequence from the API, creates a sign doc,\n   * creates a single signature, assembles the signed transaction and broadcasts it.\n   */\n\n\n  async signAndBroadcast(msgs, fee) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const signedTx = await this.sign(msgs, fee, memo);\n    return this.broadcastTx(signedTx);\n  }\n  /**\n   * Gets account number and sequence from the API, creates a sign doc,\n   * creates a single signature and assembles the signed transaction.\n   */\n\n\n  async sign(msgs, fee) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const {\n      accountNumber,\n      sequence\n    } = await this.getSequence();\n    const chainId = await this.getChainId();\n    const signDoc = amino_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);\n    const {\n      signed,\n      signature\n    } = await this.signer.signAmino(this.signerAddress, signDoc);\n    return tx_1.makeStdTx(signed, signature);\n  }\n  /**\n   * Gets account number and sequence from the API, creates a sign doc,\n   * creates a single signature and appends it to the existing signatures.\n   */\n\n\n  async appendSignature(signedTx) {\n    const {\n      msg: msgs,\n      fee,\n      memo\n    } = signedTx;\n    const {\n      accountNumber,\n      sequence\n    } = await this.getSequence();\n    const chainId = await this.getChainId();\n    const signDoc = amino_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);\n    const {\n      signed,\n      signature: additionalSignature\n    } = await this.signer.signAmino(this.signerAddress, signDoc);\n\n    if (!fast_deep_equal_1.default(signDoc, signed)) {\n      throw new Error(\"The signed document differs from the one of the original transaction. This is not allowed since the resulting transaction will be invalid.\");\n    }\n\n    return tx_1.makeStdTx(signed, [...signedTx.signatures, additionalSignature]);\n  }\n\n}\n\nexports.SigningCosmosClient = SigningCosmosClient;","map":{"version":3,"sources":["../src/signingcosmosclient.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;AACA,MAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,iBAAA,GAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AAEA,MAAA,cAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,MAAA,KAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AAEA,MAAA,IAAA,GAAA,OAAA,CAAA,MAAA,CAAA;;AASA,MAAM,eAAe,GAAG,KAAA,CAAA,QAAA,CAAS,UAAT,CAAoB,YAApB,CAAxB;AACA,MAAM,gBAAgB,GAA8B;AAAE,EAAA,IAAI,EAAE;AAAR,CAApD;;AAOA,MAAa,mBAAb,SAAyC,cAAA,CAAA,YAAzC,CAAqD;AAMnD;;;;;;;;;;;;AAYG;AACH,EAAA,WAAA,CACE,MADF,EAEE,aAFF,EAGE,MAHF,EAMqC;AAAA,QAFnC,QAEmC,uEAFd,eAEc;AAAA,QADnC,SACmC,uEADa,EACb;AAAA,QAAnC,aAAmC,uEAAnB,QAAA,CAAA,aAAA,CAAc,KAAK;AAEnC,UAAM,MAAN,EAAc,aAAd;AACA,SAAK,eAAL,GAAuB,aAAvB;AACA,SAAK,aAAL,GAAqB,aAArB;AACA,SAAK,MAAL,GAAc,MAAd;AACA,SAAK,IAAL,GAAY,KAAA,CAAA,aAAA,CAA8B,QAA9B,EAAwC,gBAAxC,EAA0D,SAA1D,CAAZ;AACD;;AAEuB,QAAX,WAAW,CAAC,OAAD,EAAiB;AACvC,WAAO,MAAM,WAAN,CAAkB,OAAO,IAAI,KAAK,aAAlC,CAAP;AACD;;AAEsB,QAAV,UAAU,CAAC,OAAD,EAAiB;AACtC,WAAO,MAAM,UAAN,CAAiB,OAAO,IAAI,KAAK,aAAjC,CAAP;AACD;;AAEsB,QAAV,UAAU,CACrB,gBADqB,EAErB,MAFqB,EAGZ;AAAA,QAAT,IAAS,uEAAF,EAAE;AAET,UAAM,OAAO,GAAY;AACvB,MAAA,IAAI,EAAE,oBADiB;AAEvB,MAAA,KAAK,EAAE;AACL,QAAA,YAAY,EAAE,KAAK,aADd;AAEL,QAAA,UAAU,EAAE,gBAFP;AAGL,QAAA,MAAM,EAAE;AAHH;AAFgB,KAAzB;AAQA,WAAO,KAAK,gBAAL,CAAsB,CAAC,OAAD,CAAtB,EAAiC,KAAK,IAAL,CAAU,IAA3C,EAAiD,IAAjD,CAAP;AACD;AAED;;;AAGG;;;AAC0B,QAAhB,gBAAgB,CAC3B,IAD2B,EAE3B,GAF2B,EAGlB;AAAA,QAAT,IAAS,uEAAF,EAAE;AAET,UAAM,QAAQ,GAAG,MAAM,KAAK,IAAL,CAAU,IAAV,EAAgB,GAAhB,EAAqB,IAArB,CAAvB;AACA,WAAO,KAAK,WAAL,CAAiB,QAAjB,CAAP;AACD;AAED;;;AAGG;;;AACc,QAAJ,IAAI,CAAC,IAAD,EAA4B,GAA5B,EAAkD;AAAA,QAAT,IAAS,uEAAF,EAAE;AACjE,UAAM;AAAE,MAAA,aAAF;AAAiB,MAAA;AAAjB,QAA8B,MAAM,KAAK,WAAL,EAA1C;AACA,UAAM,OAAO,GAAG,MAAM,KAAK,UAAL,EAAtB;AACA,UAAM,OAAO,GAAG,OAAA,CAAA,WAAA,CAAY,IAAZ,EAAkB,GAAlB,EAAuB,OAAvB,EAAgC,IAAhC,EAAsC,aAAtC,EAAqD,QAArD,CAAhB;AACA,UAAM;AAAE,MAAA,MAAF;AAAU,MAAA;AAAV,QAAwB,MAAM,KAAK,MAAL,CAAY,SAAZ,CAAsB,KAAK,aAA3B,EAA0C,OAA1C,CAApC;AACA,WAAO,IAAA,CAAA,SAAA,CAAU,MAAV,EAAkB,SAAlB,CAAP;AACD;AAED;;;AAGG;;;AACyB,QAAf,eAAe,CAAC,QAAD,EAAgB;AAC1C,UAAM;AAAE,MAAA,GAAG,EAAE,IAAP;AAAa,MAAA,GAAb;AAAkB,MAAA;AAAlB,QAA2B,QAAjC;AACA,UAAM;AAAE,MAAA,aAAF;AAAiB,MAAA;AAAjB,QAA8B,MAAM,KAAK,WAAL,EAA1C;AACA,UAAM,OAAO,GAAG,MAAM,KAAK,UAAL,EAAtB;AACA,UAAM,OAAO,GAAG,OAAA,CAAA,WAAA,CAAY,IAAZ,EAAkB,GAAlB,EAAuB,OAAvB,EAAgC,IAAhC,EAAsC,aAAtC,EAAqD,QAArD,CAAhB;AACA,UAAM;AAAE,MAAA,MAAF;AAAU,MAAA,SAAS,EAAE;AAArB,QAA6C,MAAM,KAAK,MAAL,CAAY,SAAZ,CACvD,KAAK,aADkD,EAEvD,OAFuD,CAAzD;;AAIA,QAAI,CAAC,iBAAA,CAAA,OAAA,CAAO,OAAP,EAAgB,MAAhB,CAAL,EAA8B;AAC5B,YAAM,IAAI,KAAJ,CACJ,4IADI,CAAN;AAGD;;AACD,WAAO,IAAA,CAAA,SAAA,CAAU,MAAV,EAAkB,CAAC,GAAG,QAAQ,CAAC,UAAb,EAAyB,mBAAzB,CAAlB,CAAP;AACD;;AAtGkD;;AAArD,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigningCosmosClient = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst amino_1 = require(\"@cosmjs/amino\");\nconst fast_deep_equal_1 = __importDefault(require(\"fast-deep-equal\"));\nconst cosmosclient_1 = require(\"./cosmosclient\");\nconst fee_1 = require(\"./fee\");\nconst lcdapi_1 = require(\"./lcdapi\");\nconst tx_1 = require(\"./tx\");\nconst defaultGasPrice = fee_1.GasPrice.fromString(\"0.025ucosm\");\nconst defaultGasLimits = { send: 80000 };\nclass SigningCosmosClient extends cosmosclient_1.CosmosClient {\n    /**\n     * Creates a new client with signing capability to interact with a Cosmos SDK blockchain. This is the bigger brother of CosmosClient.\n     *\n     * This instance does a lot of caching. In order to benefit from that you should try to use one instance\n     * for the lifetime of your application. When switching backends, a new instance must be created.\n     *\n     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)\n     * @param signerAddress The address that will sign transactions using this instance. The `signer` must be able to sign with this address.\n     * @param signer An implementation of OfflineAminoSigner which can provide signatures for transactions, potentially requiring user input.\n     * @param gasPrice The price paid per unit of gas\n     * @param gasLimits Custom overrides for gas limits related to specific transaction types\n     * @param broadcastMode Defines at which point of the transaction processing the broadcastTx method returns\n     */\n    constructor(apiUrl, signerAddress, signer, gasPrice = defaultGasPrice, gasLimits = {}, broadcastMode = lcdapi_1.BroadcastMode.Block) {\n        super(apiUrl, broadcastMode);\n        this.anyValidAddress = signerAddress;\n        this.signerAddress = signerAddress;\n        this.signer = signer;\n        this.fees = fee_1.buildFeeTable(gasPrice, defaultGasLimits, gasLimits);\n    }\n    async getSequence(address) {\n        return super.getSequence(address || this.signerAddress);\n    }\n    async getAccount(address) {\n        return super.getAccount(address || this.signerAddress);\n    }\n    async sendTokens(recipientAddress, amount, memo = \"\") {\n        const sendMsg = {\n            type: \"cosmos-sdk/MsgSend\",\n            value: {\n                from_address: this.signerAddress,\n                to_address: recipientAddress,\n                amount: amount,\n            },\n        };\n        return this.signAndBroadcast([sendMsg], this.fees.send, memo);\n    }\n    /**\n     * Gets account number and sequence from the API, creates a sign doc,\n     * creates a single signature, assembles the signed transaction and broadcasts it.\n     */\n    async signAndBroadcast(msgs, fee, memo = \"\") {\n        const signedTx = await this.sign(msgs, fee, memo);\n        return this.broadcastTx(signedTx);\n    }\n    /**\n     * Gets account number and sequence from the API, creates a sign doc,\n     * creates a single signature and assembles the signed transaction.\n     */\n    async sign(msgs, fee, memo = \"\") {\n        const { accountNumber, sequence } = await this.getSequence();\n        const chainId = await this.getChainId();\n        const signDoc = amino_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);\n        const { signed, signature } = await this.signer.signAmino(this.signerAddress, signDoc);\n        return tx_1.makeStdTx(signed, signature);\n    }\n    /**\n     * Gets account number and sequence from the API, creates a sign doc,\n     * creates a single signature and appends it to the existing signatures.\n     */\n    async appendSignature(signedTx) {\n        const { msg: msgs, fee, memo } = signedTx;\n        const { accountNumber, sequence } = await this.getSequence();\n        const chainId = await this.getChainId();\n        const signDoc = amino_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);\n        const { signed, signature: additionalSignature } = await this.signer.signAmino(this.signerAddress, signDoc);\n        if (!fast_deep_equal_1.default(signDoc, signed)) {\n            throw new Error(\"The signed document differs from the one of the original transaction. This is not allowed since the resulting transaction will be invalid.\");\n        }\n        return tx_1.makeStdTx(signed, [...signedTx.signatures, additionalSignature]);\n    }\n}\nexports.SigningCosmosClient = SigningCosmosClient;\n//# sourceMappingURL=signingcosmosclient.js.map"]},"metadata":{},"sourceType":"script"}