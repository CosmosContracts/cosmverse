{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SocketWrapper = void 0;\n\nvar isomorphic_ws_1 = __importDefault(require(\"isomorphic-ws\"));\n\nfunction environmentIsNodeJs() {\n  return typeof process !== \"undefined\" && typeof process.versions !== \"undefined\" && typeof process.versions.node !== \"undefined\";\n}\n/**\n * A thin wrapper around isomorphic-ws' WebSocket class that adds\n * - constant message/error/open/close handlers\n * - explict connection via a connect() method\n * - type support for events\n * - handling of corner cases in the open and close behaviour\n */\n\n\nvar SocketWrapper = /*#__PURE__*/function () {\n  function SocketWrapper(url, messageHandler, errorHandler, openHandler, closeHandler) {\n    var _this = this;\n\n    var timeout = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 10000;\n\n    _classCallCheck(this, SocketWrapper);\n\n    this.closed = false;\n    this.connected = new Promise(function (resolve, reject) {\n      _this.connectedResolver = resolve;\n      _this.connectedRejecter = reject;\n    });\n    this.url = url;\n    this.messageHandler = messageHandler;\n    this.errorHandler = errorHandler;\n    this.openHandler = openHandler;\n    this.closeHandler = closeHandler;\n    this.timeout = timeout;\n  }\n  /**\n   * returns a promise that resolves when connection is open\n   */\n\n\n  _createClass(SocketWrapper, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      var socket = new isomorphic_ws_1.default(this.url);\n\n      socket.onerror = function (error) {\n        _this2.clearTimeout();\n\n        if (_this2.errorHandler) {\n          _this2.errorHandler(error);\n        }\n      };\n\n      socket.onmessage = function (messageEvent) {\n        _this2.messageHandler({\n          type: messageEvent.type,\n          data: messageEvent.data\n        });\n      };\n\n      socket.onopen = function (_) {\n        _this2.clearTimeout(); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n        _this2.connectedResolver();\n\n        if (_this2.openHandler) {\n          _this2.openHandler();\n        }\n      };\n\n      socket.onclose = function (closeEvent) {\n        _this2.closed = true;\n\n        if (_this2.closeHandler) {\n          _this2.closeHandler(closeEvent);\n        }\n      };\n\n      var started = Date.now();\n      this.timeoutId = setTimeout(function () {\n        socket.onmessage = function () {\n          return 0;\n        };\n\n        socket.onerror = function () {\n          return 0;\n        };\n\n        socket.onopen = function () {\n          return 0;\n        };\n\n        socket.onclose = function () {\n          return 0;\n        };\n\n        socket.close();\n        _this2.socket = undefined;\n        var elapsed = Math.floor(Date.now() - started); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n        _this2.connectedRejecter(\"Connection attempt timed out after \".concat(elapsed, \" ms\"));\n      }, this.timeout);\n      this.socket = socket;\n    }\n    /**\n     * Closes an established connection and aborts other connection states\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (!this.socket) {\n        throw new Error(\"Socket undefined. This must be called after connecting.\");\n      }\n\n      this.clearTimeout();\n\n      switch (this.socket.readyState) {\n        case isomorphic_ws_1.default.OPEN:\n          this.socket.close(1000\n          /* Normal Closure */\n          );\n          break;\n\n        case isomorphic_ws_1.default.CLOSED:\n          // nothing to be done\n          break;\n\n        case isomorphic_ws_1.default.CONNECTING:\n          // imitate missing abort API\n          this.socket.onopen = function () {\n            return 0;\n          };\n\n          this.socket.onclose = function () {\n            return 0;\n          };\n\n          this.socket.onerror = function () {\n            return 0;\n          };\n\n          this.socket.onmessage = function () {\n            return 0;\n          };\n\n          this.socket = undefined;\n\n          if (this.closeHandler) {\n            this.closeHandler({\n              wasClean: false,\n              code: 4001\n            });\n          }\n\n          break;\n\n        case isomorphic_ws_1.default.CLOSING:\n          // already closing. Let it proceed\n          break;\n\n        default:\n          throw new Error(\"Unknown readyState: \".concat(this.socket.readyState));\n      }\n    }\n  }, {\n    key: \"send\",\n    value: function () {\n      var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(data) {\n        var _this3 = this;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  if (!_this3.socket) {\n                    throw new Error(\"Socket undefined. This must be called after connecting.\");\n                  }\n\n                  if (_this3.closed) {\n                    throw new Error(\"Socket was closed, so no data can be sent anymore.\");\n                  } // this exception should be thrown by send() automatically according to\n                  // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n\n\n                  // this exception should be thrown by send() automatically according to\n                  // https://developer.mozilla.org/de/docs/Web/API/WebSocket#send() but it does not work in browsers\n                  if (_this3.socket.readyState !== isomorphic_ws_1.default.OPEN) {\n                    throw new Error(\"Websocket is not open\");\n                  }\n\n                  if (environmentIsNodeJs()) {\n                    _this3.socket.send(data, function (err) {\n                      return err ? reject(err) : resolve();\n                    });\n                  } else {\n                    // Browser websocket send method does not accept a callback\n                    _this3.socket.send(data);\n\n                    resolve();\n                  }\n                }));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      function send(_x) {\n        return _send.apply(this, arguments);\n      }\n\n      return send;\n    }()\n    /**\n     * Clears the timeout function, such that no timeout error will be raised anymore. This should be\n     * called when the connection is established, a connection error occurred or the socket is disconnected.\n     *\n     * This method must not be called before `connect()`.\n     * This method is idempotent.\n     */\n\n  }, {\n    key: \"clearTimeout\",\n    value: function (_clearTimeout) {\n      function clearTimeout() {\n        return _clearTimeout.apply(this, arguments);\n      }\n\n      clearTimeout.toString = function () {\n        return _clearTimeout.toString();\n      };\n\n      return clearTimeout;\n    }(function () {\n      if (!this.timeoutId) {\n        throw new Error(\"Timeout ID not set. This should not happen and usually means connect() was not called.\");\n      } // Note: do not unset this.timeoutId to allow multiple calls to this function\n\n\n      clearTimeout(this.timeoutId);\n    })\n  }]);\n\n  return SocketWrapper;\n}();\n\nexports.SocketWrapper = SocketWrapper;","map":null,"metadata":{},"sourceType":"script"}