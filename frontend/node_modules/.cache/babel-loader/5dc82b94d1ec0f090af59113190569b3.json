{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hashBlock = exports.hashTx = void 0;\n\nvar crypto_1 = require(\"@cosmjs/crypto\");\n\nvar encodings_1 = require(\"./encodings\"); // hash is sha256\n// https://github.com/tendermint/tendermint/blob/master/UPGRADING.md#v0260\n\n\nfunction hashTx(tx) {\n  return crypto_1.sha256(tx);\n}\n\nexports.hashTx = hashTx;\n\nfunction getSplitPoint(n) {\n  if (n < 1) throw new Error(\"Cannot split an empty tree\");\n  var largestPowerOf2 = Math.pow(2, Math.floor(Math.log2(n)));\n  return largestPowerOf2 < n ? largestPowerOf2 : largestPowerOf2 / 2;\n}\n\nfunction hashLeaf(leaf) {\n  var hash = new crypto_1.Sha256(Uint8Array.from([0]));\n  hash.update(leaf);\n  return hash.digest();\n}\n\nfunction hashInner(left, right) {\n  var hash = new crypto_1.Sha256(Uint8Array.from([1]));\n  hash.update(left);\n  hash.update(right);\n  return hash.digest();\n} // See https://github.com/tendermint/tendermint/blob/v0.31.8/docs/spec/blockchain/encoding.md#merkleroot\n// Note: the hashes input may not actually be hashes, especially before a recursive call\n\n\nfunction hashTree(hashes) {\n  switch (hashes.length) {\n    case 0:\n      throw new Error(\"Cannot hash empty tree\");\n\n    case 1:\n      return hashLeaf(hashes[0]);\n\n    default:\n      {\n        var slicePoint = getSplitPoint(hashes.length);\n        var left = hashTree(hashes.slice(0, slicePoint));\n        var right = hashTree(hashes.slice(slicePoint));\n        return hashInner(left, right);\n      }\n  }\n}\n\nfunction hashBlock(header) {\n  var encodedFields = [encodings_1.encodeVersion(header.version), encodings_1.encodeString(header.chainId), encodings_1.encodeInt(header.height), encodings_1.encodeTime(header.time), encodings_1.encodeBlockId(header.lastBlockId), encodings_1.encodeBytes(header.lastCommitHash), encodings_1.encodeBytes(header.dataHash), encodings_1.encodeBytes(header.validatorsHash), encodings_1.encodeBytes(header.nextValidatorsHash), encodings_1.encodeBytes(header.consensusHash), encodings_1.encodeBytes(header.appHash), encodings_1.encodeBytes(header.lastResultsHash), encodings_1.encodeBytes(header.evidenceHash), encodings_1.encodeBytes(header.proposerAddress)];\n  return hashTree(encodedFields);\n}\n\nexports.hashBlock = hashBlock;","map":null,"metadata":{},"sourceType":"script"}