{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.findSequenceForSignedTx = void 0;\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n/**\n * Serach for sequence s with `min` <= `s` < `upperBound` to find the sequence that was used to sign the transaction\n *\n * @param tx The signed transaction\n * @param chainId The chain ID for which this transaction was signed\n * @param accountNumber The account number for which this transaction was signed\n * @param upperBound The upper bound for the testing, i.e. sequence must be lower than this value\n * @param min The lowest sequence that is tested\n *\n * @returns the sequence if a match was found and undefined otherwise\n */\n\n\nasync function findSequenceForSignedTx(tx, chainId, accountNumber, upperBound) {\n  let min = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  const firstSignature = tx.value.signatures.find(() => true);\n  if (!firstSignature) throw new Error(\"Signature missing in tx\");\n  const {\n    pubkey,\n    signature\n  } = amino_1.decodeSignature(firstSignature);\n  const secp256keSignature = crypto_1.Secp256k1Signature.fromFixedLength(signature);\n\n  for (let s = min; s < upperBound; s++) {\n    // console.log(`Trying sequence ${s}`);\n    const signBytes = amino_1.serializeSignDoc(amino_1.makeSignDoc(tx.value.msg, tx.value.fee, chainId, tx.value.memo || \"\", accountNumber, s));\n    const prehashed = crypto_1.sha256(signBytes);\n    const valid = await crypto_1.Secp256k1.verifySignature(secp256keSignature, prehashed, pubkey);\n    if (valid) return s;\n  }\n\n  return undefined;\n}\n\nexports.findSequenceForSignedTx = findSequenceForSignedTx;","map":{"version":3,"sources":["../src/sequence.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,QAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;AAIA;;;;;;;;;;AAUG;;;AACI,eAAe,uBAAf,CACL,EADK,EAEL,OAFK,EAGL,aAHK,EAIL,UAJK,EAKE;AAAA,MAAP,GAAO,uEAAD,CAAC;AAEP,QAAM,cAAc,GAAG,EAAE,CAAC,KAAH,CAAS,UAAT,CAAoB,IAApB,CAAyB,MAAM,IAA/B,CAAvB;AACA,MAAI,CAAC,cAAL,EAAqB,MAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AAErB,QAAM;AAAE,IAAA,MAAF;AAAU,IAAA;AAAV,MAAwB,OAAA,CAAA,eAAA,CAAgB,cAAhB,CAA9B;AACA,QAAM,kBAAkB,GAAG,QAAA,CAAA,kBAAA,CAAmB,eAAnB,CAAmC,SAAnC,CAA3B;;AAEA,OAAK,IAAI,CAAC,GAAG,GAAb,EAAkB,CAAC,GAAG,UAAtB,EAAkC,CAAC,EAAnC,EAAuC;AACrC;AACA,UAAM,SAAS,GAAG,OAAA,CAAA,gBAAA,CAChB,OAAA,CAAA,WAAA,CAAY,EAAE,CAAC,KAAH,CAAS,GAArB,EAA0B,EAAE,CAAC,KAAH,CAAS,GAAnC,EAAwC,OAAxC,EAAiD,EAAE,CAAC,KAAH,CAAS,IAAT,IAAiB,EAAlE,EAAsE,aAAtE,EAAqF,CAArF,CADgB,CAAlB;AAGA,UAAM,SAAS,GAAG,QAAA,CAAA,MAAA,CAAO,SAAP,CAAlB;AACA,UAAM,KAAK,GAAG,MAAM,QAAA,CAAA,SAAA,CAAU,eAAV,CAA0B,kBAA1B,EAA8C,SAA9C,EAAyD,MAAzD,CAApB;AACA,QAAI,KAAJ,EAAW,OAAO,CAAP;AACZ;;AACD,SAAO,SAAP;AACD;;AAvBD,OAAA,CAAA,uBAAA,GAAA,uBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findSequenceForSignedTx = void 0;\nconst amino_1 = require(\"@cosmjs/amino\");\nconst crypto_1 = require(\"@cosmjs/crypto\");\n/**\n * Serach for sequence s with `min` <= `s` < `upperBound` to find the sequence that was used to sign the transaction\n *\n * @param tx The signed transaction\n * @param chainId The chain ID for which this transaction was signed\n * @param accountNumber The account number for which this transaction was signed\n * @param upperBound The upper bound for the testing, i.e. sequence must be lower than this value\n * @param min The lowest sequence that is tested\n *\n * @returns the sequence if a match was found and undefined otherwise\n */\nasync function findSequenceForSignedTx(tx, chainId, accountNumber, upperBound, min = 0) {\n    const firstSignature = tx.value.signatures.find(() => true);\n    if (!firstSignature)\n        throw new Error(\"Signature missing in tx\");\n    const { pubkey, signature } = amino_1.decodeSignature(firstSignature);\n    const secp256keSignature = crypto_1.Secp256k1Signature.fromFixedLength(signature);\n    for (let s = min; s < upperBound; s++) {\n        // console.log(`Trying sequence ${s}`);\n        const signBytes = amino_1.serializeSignDoc(amino_1.makeSignDoc(tx.value.msg, tx.value.fee, chainId, tx.value.memo || \"\", accountNumber, s));\n        const prehashed = crypto_1.sha256(signBytes);\n        const valid = await crypto_1.Secp256k1.verifySignature(secp256keSignature, prehashed, pubkey);\n        if (valid)\n            return s;\n    }\n    return undefined;\n}\nexports.findSequenceForSignedTx = findSequenceForSignedTx;\n//# sourceMappingURL=sequence.js.map"]},"metadata":{},"sourceType":"script"}