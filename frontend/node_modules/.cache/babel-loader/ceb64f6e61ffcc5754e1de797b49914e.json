{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StargateClient = exports.assertIsBroadcastTxSuccess = exports.isBroadcastTxSuccess = exports.isBroadcastTxFailure = exports.TimeoutError = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst accounts_1 = require(\"./accounts\");\n\nconst queries_1 = require(\"./queries\");\n\nconst search_1 = require(\"./search\");\n\nclass TimeoutError extends Error {\n  constructor(message, txId) {\n    super(message);\n    this.txId = txId;\n  }\n\n}\n\nexports.TimeoutError = TimeoutError;\n\nfunction isBroadcastTxFailure(result) {\n  return !!result.code;\n}\n\nexports.isBroadcastTxFailure = isBroadcastTxFailure;\n\nfunction isBroadcastTxSuccess(result) {\n  return !isBroadcastTxFailure(result);\n}\n\nexports.isBroadcastTxSuccess = isBroadcastTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\n\nfunction assertIsBroadcastTxSuccess(result) {\n  if (isBroadcastTxFailure(result)) {\n    throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n  }\n}\n\nexports.assertIsBroadcastTxSuccess = assertIsBroadcastTxSuccess;\n\nclass StargateClient {\n  constructor(tmClient) {\n    if (tmClient) {\n      this.tmClient = tmClient;\n      this.queryClient = queries_1.QueryClient.withExtensions(tmClient, queries_1.setupAuthExtension, queries_1.setupBankExtension);\n    }\n  }\n\n  static async connect(endpoint) {\n    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n    return new StargateClient(tmClient);\n  }\n\n  getTmClient() {\n    return this.tmClient;\n  }\n\n  forceGetTmClient() {\n    if (!this.tmClient) {\n      throw new Error(\"Tendermint client not available. You cannot use online functionality in offline mode.\");\n    }\n\n    return this.tmClient;\n  }\n\n  getQueryClient() {\n    return this.queryClient;\n  }\n\n  forceGetQueryClient() {\n    if (!this.queryClient) {\n      throw new Error(\"Query client not available. You cannot use online functionality in offline mode.\");\n    }\n\n    return this.queryClient;\n  }\n\n  async getChainId() {\n    if (!this.chainId) {\n      const response = await this.forceGetTmClient().status();\n      const chainId = response.nodeInfo.network;\n      if (!chainId) throw new Error(\"Chain ID must not be empty\");\n      this.chainId = chainId;\n    }\n\n    return this.chainId;\n  }\n\n  async getHeight() {\n    const status = await this.forceGetTmClient().status();\n    return status.syncInfo.latestBlockHeight;\n  }\n\n  async getAccount(searchAddress) {\n    try {\n      const account = await this.forceGetQueryClient().auth.account(searchAddress);\n      return account ? accounts_1.accountFromAny(account) : null;\n    } catch (error) {\n      if (/rpc error: code = NotFound/i.test(error)) {\n        return null;\n      }\n\n      throw error;\n    }\n  }\n\n  async getAccountVerified(searchAddress) {\n    const account = await this.forceGetQueryClient().auth.verified.account(searchAddress);\n    return account ? accounts_1.accountFromAny(account) : null;\n  }\n\n  async getSequence(address) {\n    const account = await this.getAccount(address);\n\n    if (!account) {\n      throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n    }\n\n    return {\n      accountNumber: account.accountNumber,\n      sequence: account.sequence\n    };\n  }\n\n  async getBlock(height) {\n    const response = await this.forceGetTmClient().block(height);\n    return {\n      id: encoding_1.toHex(response.blockId.hash).toUpperCase(),\n      header: {\n        version: {\n          block: new math_1.Uint53(response.block.header.version.block).toString(),\n          app: new math_1.Uint53(response.block.header.version.app).toString()\n        },\n        height: response.block.header.height,\n        chainId: response.block.header.chainId,\n        time: tendermint_rpc_1.toRfc3339WithNanoseconds(response.block.header.time)\n      },\n      txs: response.block.txs\n    };\n  }\n\n  async getBalance(address, searchDenom) {\n    return this.forceGetQueryClient().bank.balance(address, searchDenom);\n  }\n  /**\n   * Queries all balances for all denoms that belong to this address.\n   *\n   * Uses the grpc queries (which iterates over the store internally), and we cannot get\n   * proofs from such a method.\n   */\n\n\n  async getAllBalances(address) {\n    return this.forceGetQueryClient().bank.allBalances(address);\n  }\n\n  async getTx(id) {\n    var _a;\n\n    const results = await this.txsQuery(`tx.hash='${id}'`);\n    return (_a = results[0]) !== null && _a !== void 0 ? _a : null;\n  }\n\n  async searchTx(query) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const minHeight = filter.minHeight || 0;\n    const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n    if (maxHeight < minHeight) return []; // optional optimization\n\n    function withFilters(originalQuery) {\n      return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;\n    }\n\n    let txs;\n\n    if (search_1.isSearchByHeightQuery(query)) {\n      txs = query.height >= minHeight && query.height <= maxHeight ? await this.txsQuery(`tx.height=${query.height}`) : [];\n    } else if (search_1.isSearchBySentFromOrToQuery(query)) {\n      const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);\n      const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);\n      const [sent, received] = await Promise.all([sentQuery, receivedQuery].map(rawQuery => this.txsQuery(rawQuery)));\n      const sentHashes = sent.map(t => t.hash);\n      txs = [...sent, ...received.filter(t => !sentHashes.includes(t.hash))];\n    } else if (search_1.isSearchByTagsQuery(query)) {\n      const rawQuery = withFilters(query.tags.map(t => `${t.key}='${t.value}'`).join(\" AND \"));\n      txs = await this.txsQuery(rawQuery);\n    } else {\n      throw new Error(\"Unknown query type\");\n    }\n\n    const filtered = txs.filter(tx => tx.height >= minHeight && tx.height <= maxHeight);\n    return filtered;\n  }\n\n  disconnect() {\n    if (this.tmClient) this.tmClient.disconnect();\n  }\n  /**\n   * Broadcasts a signed transaction to the network and monitors its inclusion in a block.\n   *\n   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),\n   * an error is thrown.\n   *\n   * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.\n   *\n   * If the transaction is included in a block, a `BroadcastTxResponse` is returned. The caller then\n   * usually needs to check for execution success or failure.\n   */\n\n\n  async broadcastTx(tx) {\n    let timeoutMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60000;\n    let pollIntervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;\n    let timedOut = false;\n    const txPollTimeout = setTimeout(() => {\n      timedOut = true;\n    }, timeoutMs);\n\n    const pollForTx = async txId => {\n      if (timedOut) {\n        throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later.`, txId);\n      }\n\n      await utils_1.sleep(pollIntervalMs);\n      const result = await this.getTx(txId);\n      return result ? {\n        code: result.code,\n        height: result.height,\n        rawLog: result.rawLog,\n        transactionHash: txId,\n        gasUsed: result.gasUsed,\n        gasWanted: result.gasWanted\n      } : pollForTx(txId);\n    };\n\n    const broadcasted = await this.forceGetTmClient().broadcastTxSync({\n      tx\n    });\n\n    if (broadcasted.code) {\n      throw new Error(`Broadcasting transaction failed with code ${broadcasted.code} (codespace: ${broadcasted.codeSpace}). Log: ${broadcasted.log}`);\n    }\n\n    const transactionId = encoding_1.toHex(broadcasted.hash).toUpperCase();\n    return new Promise((resolve, reject) => pollForTx(transactionId).then(value => {\n      clearTimeout(txPollTimeout);\n      resolve(value);\n    }, error => {\n      clearTimeout(txPollTimeout);\n      reject(error);\n    }));\n  }\n\n  async txsQuery(query) {\n    const results = await this.forceGetTmClient().txSearchAll({\n      query: query\n    });\n    return results.txs.map(tx => {\n      return {\n        height: tx.height,\n        hash: encoding_1.toHex(tx.hash).toUpperCase(),\n        code: tx.result.code,\n        rawLog: tx.result.log || \"\",\n        tx: tx.tx,\n        gasUsed: tx.result.gasUsed,\n        gasWanted: tx.result.gasWanted\n      };\n    });\n  }\n\n}\n\nexports.StargateClient = StargateClient;","map":{"version":3,"sources":["../src/stargateclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StargateClient = exports.assertIsBroadcastTxSuccess = exports.isBroadcastTxSuccess = exports.isBroadcastTxFailure = exports.TimeoutError = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst accounts_1 = require(\"./accounts\");\nconst queries_1 = require(\"./queries\");\nconst search_1 = require(\"./search\");\nclass TimeoutError extends Error {\n    constructor(message, txId) {\n        super(message);\n        this.txId = txId;\n    }\n}\nexports.TimeoutError = TimeoutError;\nfunction isBroadcastTxFailure(result) {\n    return !!result.code;\n}\nexports.isBroadcastTxFailure = isBroadcastTxFailure;\nfunction isBroadcastTxSuccess(result) {\n    return !isBroadcastTxFailure(result);\n}\nexports.isBroadcastTxSuccess = isBroadcastTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\nfunction assertIsBroadcastTxSuccess(result) {\n    if (isBroadcastTxFailure(result)) {\n        throw new Error(`Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`);\n    }\n}\nexports.assertIsBroadcastTxSuccess = assertIsBroadcastTxSuccess;\nclass StargateClient {\n    constructor(tmClient) {\n        if (tmClient) {\n            this.tmClient = tmClient;\n            this.queryClient = queries_1.QueryClient.withExtensions(tmClient, queries_1.setupAuthExtension, queries_1.setupBankExtension);\n        }\n    }\n    static async connect(endpoint) {\n        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n        return new StargateClient(tmClient);\n    }\n    getTmClient() {\n        return this.tmClient;\n    }\n    forceGetTmClient() {\n        if (!this.tmClient) {\n            throw new Error(\"Tendermint client not available. You cannot use online functionality in offline mode.\");\n        }\n        return this.tmClient;\n    }\n    getQueryClient() {\n        return this.queryClient;\n    }\n    forceGetQueryClient() {\n        if (!this.queryClient) {\n            throw new Error(\"Query client not available. You cannot use online functionality in offline mode.\");\n        }\n        return this.queryClient;\n    }\n    async getChainId() {\n        if (!this.chainId) {\n            const response = await this.forceGetTmClient().status();\n            const chainId = response.nodeInfo.network;\n            if (!chainId)\n                throw new Error(\"Chain ID must not be empty\");\n            this.chainId = chainId;\n        }\n        return this.chainId;\n    }\n    async getHeight() {\n        const status = await this.forceGetTmClient().status();\n        return status.syncInfo.latestBlockHeight;\n    }\n    async getAccount(searchAddress) {\n        try {\n            const account = await this.forceGetQueryClient().auth.account(searchAddress);\n            return account ? accounts_1.accountFromAny(account) : null;\n        }\n        catch (error) {\n            if (/rpc error: code = NotFound/i.test(error)) {\n                return null;\n            }\n            throw error;\n        }\n    }\n    async getAccountVerified(searchAddress) {\n        const account = await this.forceGetQueryClient().auth.verified.account(searchAddress);\n        return account ? accounts_1.accountFromAny(account) : null;\n    }\n    async getSequence(address) {\n        const account = await this.getAccount(address);\n        if (!account) {\n            throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n        }\n        return {\n            accountNumber: account.accountNumber,\n            sequence: account.sequence,\n        };\n    }\n    async getBlock(height) {\n        const response = await this.forceGetTmClient().block(height);\n        return {\n            id: encoding_1.toHex(response.blockId.hash).toUpperCase(),\n            header: {\n                version: {\n                    block: new math_1.Uint53(response.block.header.version.block).toString(),\n                    app: new math_1.Uint53(response.block.header.version.app).toString(),\n                },\n                height: response.block.header.height,\n                chainId: response.block.header.chainId,\n                time: tendermint_rpc_1.toRfc3339WithNanoseconds(response.block.header.time),\n            },\n            txs: response.block.txs,\n        };\n    }\n    async getBalance(address, searchDenom) {\n        return this.forceGetQueryClient().bank.balance(address, searchDenom);\n    }\n    /**\n     * Queries all balances for all denoms that belong to this address.\n     *\n     * Uses the grpc queries (which iterates over the store internally), and we cannot get\n     * proofs from such a method.\n     */\n    async getAllBalances(address) {\n        return this.forceGetQueryClient().bank.allBalances(address);\n    }\n    async getTx(id) {\n        var _a;\n        const results = await this.txsQuery(`tx.hash='${id}'`);\n        return (_a = results[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    async searchTx(query, filter = {}) {\n        const minHeight = filter.minHeight || 0;\n        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n        if (maxHeight < minHeight)\n            return []; // optional optimization\n        function withFilters(originalQuery) {\n            return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;\n        }\n        let txs;\n        if (search_1.isSearchByHeightQuery(query)) {\n            txs =\n                query.height >= minHeight && query.height <= maxHeight\n                    ? await this.txsQuery(`tx.height=${query.height}`)\n                    : [];\n        }\n        else if (search_1.isSearchBySentFromOrToQuery(query)) {\n            const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);\n            const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);\n            const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));\n            const sentHashes = sent.map((t) => t.hash);\n            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];\n        }\n        else if (search_1.isSearchByTagsQuery(query)) {\n            const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(\" AND \"));\n            txs = await this.txsQuery(rawQuery);\n        }\n        else {\n            throw new Error(\"Unknown query type\");\n        }\n        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);\n        return filtered;\n    }\n    disconnect() {\n        if (this.tmClient)\n            this.tmClient.disconnect();\n    }\n    /**\n     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.\n     *\n     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),\n     * an error is thrown.\n     *\n     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.\n     *\n     * If the transaction is included in a block, a `BroadcastTxResponse` is returned. The caller then\n     * usually needs to check for execution success or failure.\n     */\n    async broadcastTx(tx, timeoutMs = 60000, pollIntervalMs = 3000) {\n        let timedOut = false;\n        const txPollTimeout = setTimeout(() => {\n            timedOut = true;\n        }, timeoutMs);\n        const pollForTx = async (txId) => {\n            if (timedOut) {\n                throw new TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later.`, txId);\n            }\n            await utils_1.sleep(pollIntervalMs);\n            const result = await this.getTx(txId);\n            return result\n                ? {\n                    code: result.code,\n                    height: result.height,\n                    rawLog: result.rawLog,\n                    transactionHash: txId,\n                    gasUsed: result.gasUsed,\n                    gasWanted: result.gasWanted,\n                }\n                : pollForTx(txId);\n        };\n        const broadcasted = await this.forceGetTmClient().broadcastTxSync({ tx });\n        if (broadcasted.code) {\n            throw new Error(`Broadcasting transaction failed with code ${broadcasted.code} (codespace: ${broadcasted.codeSpace}). Log: ${broadcasted.log}`);\n        }\n        const transactionId = encoding_1.toHex(broadcasted.hash).toUpperCase();\n        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {\n            clearTimeout(txPollTimeout);\n            resolve(value);\n        }, (error) => {\n            clearTimeout(txPollTimeout);\n            reject(error);\n        }));\n    }\n    async txsQuery(query) {\n        const results = await this.forceGetTmClient().txSearchAll({ query: query });\n        return results.txs.map((tx) => {\n            return {\n                height: tx.height,\n                hash: encoding_1.toHex(tx.hash).toUpperCase(),\n                code: tx.result.code,\n                rawLog: tx.result.log || \"\",\n                tx: tx.tx,\n                gasUsed: tx.result.gasUsed,\n                gasWanted: tx.result.gasWanted,\n            };\n        });\n    }\n}\nexports.StargateClient = StargateClient;\n//# sourceMappingURL=stargateclient.js.map"]},"metadata":{},"sourceType":"script"}