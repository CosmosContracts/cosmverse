{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decrypt = exports.encrypt = exports.supportedAlgorithms = exports.executeKdf = exports.cosmjsSalt = void 0;\n\nvar crypto_1 = require(\"@cosmjs/crypto\");\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n/**\n * A fixed salt is chosen to archive a deterministic password to key derivation.\n * This reduces the scope of a potential rainbow attack to all CosmJS users.\n * Must be 16 bytes due to implementation limitations.\n */\n\n\nexports.cosmjsSalt = encoding_1.toAscii(\"The CosmJS salt.\");\n\nfunction executeKdf(_x, _x2) {\n  return _executeKdf.apply(this, arguments);\n}\n\nfunction _executeKdf() {\n  _executeKdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(password, configuration) {\n    var options;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.t0 = configuration.algorithm;\n            _context.next = _context.t0 === \"argon2id\" ? 3 : 7;\n            break;\n\n          case 3:\n            options = configuration.params;\n\n            if (crypto_1.isArgon2idOptions(options)) {\n              _context.next = 6;\n              break;\n            }\n\n            throw new Error(\"Invalid format of argon2id params\");\n\n          case 6:\n            return _context.abrupt(\"return\", crypto_1.Argon2id.execute(password, exports.cosmjsSalt, options));\n\n          case 7:\n            throw new Error(\"Unsupported KDF algorithm\");\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _executeKdf.apply(this, arguments);\n}\n\nexports.executeKdf = executeKdf;\nexports.supportedAlgorithms = {\n  xchacha20poly1305Ietf: \"xchacha20poly1305-ietf\"\n};\n\nfunction encrypt(_x3, _x4, _x5) {\n  return _encrypt.apply(this, arguments);\n}\n\nfunction _encrypt() {\n  _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(plaintext, encryptionKey, config) {\n    var nonce;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.t0 = config.algorithm;\n            _context2.next = _context2.t0 === exports.supportedAlgorithms.xchacha20poly1305Ietf ? 3 : 14;\n            break;\n\n          case 3:\n            nonce = crypto_1.Random.getBytes(crypto_1.xchacha20NonceLength); // Prepend fixed-length nonce to ciphertext as suggested in the example from https://github.com/jedisct1/libsodium.js#api\n\n            _context2.t1 = Uint8Array;\n            _context2.t2 = [];\n            _context2.t3 = _toConsumableArray(nonce);\n            _context2.t4 = _toConsumableArray;\n            _context2.next = 10;\n            return crypto_1.Xchacha20poly1305Ietf.encrypt(plaintext, encryptionKey, nonce);\n\n          case 10:\n            _context2.t5 = _context2.sent;\n            _context2.t6 = (0, _context2.t4)(_context2.t5);\n            _context2.t7 = _context2.t2.concat.call(_context2.t2, _context2.t3, _context2.t6);\n            return _context2.abrupt(\"return\", new _context2.t1(_context2.t7));\n\n          case 14:\n            throw new Error(\"Unsupported encryption algorithm: '\".concat(config.algorithm, \"'\"));\n\n          case 15:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _encrypt.apply(this, arguments);\n}\n\nexports.encrypt = encrypt;\n\nfunction decrypt(_x6, _x7, _x8) {\n  return _decrypt.apply(this, arguments);\n}\n\nfunction _decrypt() {\n  _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(ciphertext, encryptionKey, config) {\n    var nonce;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            _context3.t0 = config.algorithm;\n            _context3.next = _context3.t0 === exports.supportedAlgorithms.xchacha20poly1305Ietf ? 3 : 5;\n            break;\n\n          case 3:\n            nonce = ciphertext.slice(0, crypto_1.xchacha20NonceLength);\n            return _context3.abrupt(\"return\", crypto_1.Xchacha20poly1305Ietf.decrypt(ciphertext.slice(crypto_1.xchacha20NonceLength), encryptionKey, nonce));\n\n          case 5:\n            throw new Error(\"Unsupported encryption algorithm: '\".concat(config.algorithm, \"'\"));\n\n          case 6:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3);\n  }));\n  return _decrypt.apply(this, arguments);\n}\n\nexports.decrypt = decrypt;","map":null,"metadata":{},"sourceType":"script"}