{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StreamingSocket = void 0;\n\nconst xstream_1 = require(\"xstream\");\n\nconst socketwrapper_1 = require(\"./socketwrapper\");\n/**\n * A WebSocket wrapper that exposes all events as a stream.\n *\n * This underlying socket will not be closed when the stream has no listeners\n */\n\n\nclass StreamingSocket {\n  constructor(url) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    this.socket = new socketwrapper_1.SocketWrapper(url, event => {\n      if (this.eventProducerListener) {\n        this.eventProducerListener.next(event);\n      }\n    }, errorEvent => {\n      if (this.eventProducerListener) {\n        this.eventProducerListener.error(errorEvent);\n      }\n    }, () => {// socket opened\n    }, closeEvent => {\n      if (this.eventProducerListener) {\n        if (closeEvent.wasClean) {\n          this.eventProducerListener.complete();\n        } else {\n          this.eventProducerListener.error(\"Socket was closed unclean\");\n        }\n      }\n    }, timeout);\n    this.connected = this.socket.connected;\n    const eventProducer = {\n      start: listener => this.eventProducerListener = listener,\n      stop: () => this.eventProducerListener = undefined\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n  }\n\n  connect() {\n    this.socket.connect();\n  }\n\n  disconnect() {\n    this.socket.disconnect();\n  }\n\n  async send(data) {\n    return this.socket.send(data);\n  }\n\n}\n\nexports.StreamingSocket = StreamingSocket;","map":{"version":3,"sources":["../src/streamingsocket.ts"],"names":[],"mappings":";;;;;;;AAAA,MAAA,SAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAEA,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;AAIG;;;AACH,MAAa,eAAb,CAA4B;AAM1B,EAAA,WAAA,CAAmB,GAAnB,EAAgD;AAAA,QAAhB,OAAgB,uEAAN,KAAM;AAC9C,SAAK,MAAL,GAAc,IAAI,eAAA,CAAA,aAAJ,CACZ,GADY,EAEX,KAAD,IAAU;AACR,UAAI,KAAK,qBAAT,EAAgC;AAC9B,aAAK,qBAAL,CAA2B,IAA3B,CAAgC,KAAhC;AACD;AACF,KANW,EAOX,UAAD,IAAe;AACb,UAAI,KAAK,qBAAT,EAAgC;AAC9B,aAAK,qBAAL,CAA2B,KAA3B,CAAiC,UAAjC;AACD;AACF,KAXW,EAYZ,MAAK,CACH;AACD,KAdW,EAeX,UAAD,IAAe;AACb,UAAI,KAAK,qBAAT,EAAgC;AAC9B,YAAI,UAAU,CAAC,QAAf,EAAyB;AACvB,eAAK,qBAAL,CAA2B,QAA3B;AACD,SAFD,MAEO;AACL,eAAK,qBAAL,CAA2B,KAA3B,CAAiC,2BAAjC;AACD;AACF;AACF,KAvBW,EAwBZ,OAxBY,CAAd;AA0BA,SAAK,SAAL,GAAiB,KAAK,MAAL,CAAY,SAA7B;AAEA,UAAM,aAAa,GAAkB;AACnC,MAAA,KAAK,EAAG,QAAD,IAAe,KAAK,qBAAL,GAA6B,QADhB;AAEnC,MAAA,IAAI,EAAE,MAAO,KAAK,qBAAL,GAA6B;AAFP,KAArC;AAIA,SAAK,MAAL,GAAc,SAAA,CAAA,MAAA,CAAO,MAAP,CAAc,aAAd,CAAd;AACD;;AAEM,EAAA,OAAO,GAAA;AACZ,SAAK,MAAL,CAAY,OAAZ;AACD;;AAEM,EAAA,UAAU,GAAA;AACf,SAAK,MAAL,CAAY,UAAZ;AACD;;AAEgB,QAAJ,IAAI,CAAC,IAAD,EAAa;AAC5B,WAAO,KAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB,CAAP;AACD;;AApDyB;;AAA5B,OAAA,CAAA,eAAA,GAAA,eAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamingSocket = void 0;\nconst xstream_1 = require(\"xstream\");\nconst socketwrapper_1 = require(\"./socketwrapper\");\n/**\n * A WebSocket wrapper that exposes all events as a stream.\n *\n * This underlying socket will not be closed when the stream has no listeners\n */\nclass StreamingSocket {\n    constructor(url, timeout = 10000) {\n        this.socket = new socketwrapper_1.SocketWrapper(url, (event) => {\n            if (this.eventProducerListener) {\n                this.eventProducerListener.next(event);\n            }\n        }, (errorEvent) => {\n            if (this.eventProducerListener) {\n                this.eventProducerListener.error(errorEvent);\n            }\n        }, () => {\n            // socket opened\n        }, (closeEvent) => {\n            if (this.eventProducerListener) {\n                if (closeEvent.wasClean) {\n                    this.eventProducerListener.complete();\n                }\n                else {\n                    this.eventProducerListener.error(\"Socket was closed unclean\");\n                }\n            }\n        }, timeout);\n        this.connected = this.socket.connected;\n        const eventProducer = {\n            start: (listener) => (this.eventProducerListener = listener),\n            stop: () => (this.eventProducerListener = undefined),\n        };\n        this.events = xstream_1.Stream.create(eventProducer);\n    }\n    connect() {\n        this.socket.connect();\n    }\n    disconnect() {\n        this.socket.disconnect();\n    }\n    async send(data) {\n        return this.socket.send(data);\n    }\n}\nexports.StreamingSocket = StreamingSocket;\n//# sourceMappingURL=streamingsocket.js.map"]},"metadata":{},"sourceType":"script"}