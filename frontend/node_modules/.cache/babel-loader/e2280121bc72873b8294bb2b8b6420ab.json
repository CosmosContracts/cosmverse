{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _slicedToArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StargateClient = exports.assertIsBroadcastTxSuccess = exports.isBroadcastTxSuccess = exports.isBroadcastTxFailure = exports.TimeoutError = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar math_1 = require(\"@cosmjs/math\");\n\nvar tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\n\nvar utils_1 = require(\"@cosmjs/utils\");\n\nvar accounts_1 = require(\"./accounts\");\n\nvar queries_1 = require(\"./queries\");\n\nvar search_1 = require(\"./search\");\n\nvar TimeoutError = /*#__PURE__*/function (_Error) {\n  _inherits(TimeoutError, _Error);\n\n  var _super = _createSuper(TimeoutError);\n\n  function TimeoutError(message, txId) {\n    var _this;\n\n    _classCallCheck(this, TimeoutError);\n\n    _this = _super.call(this, message);\n    _this.txId = txId;\n    return _this;\n  }\n\n  return TimeoutError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.TimeoutError = TimeoutError;\n\nfunction isBroadcastTxFailure(result) {\n  return !!result.code;\n}\n\nexports.isBroadcastTxFailure = isBroadcastTxFailure;\n\nfunction isBroadcastTxSuccess(result) {\n  return !isBroadcastTxFailure(result);\n}\n\nexports.isBroadcastTxSuccess = isBroadcastTxSuccess;\n/**\n * Ensures the given result is a success. Throws a detailed error message otherwise.\n */\n\nfunction assertIsBroadcastTxSuccess(result) {\n  if (isBroadcastTxFailure(result)) {\n    throw new Error(\"Error when broadcasting tx \".concat(result.transactionHash, \" at height \").concat(result.height, \". Code: \").concat(result.code, \"; Raw log: \").concat(result.rawLog));\n  }\n}\n\nexports.assertIsBroadcastTxSuccess = assertIsBroadcastTxSuccess;\n\nvar StargateClient = /*#__PURE__*/function () {\n  function StargateClient(tmClient) {\n    _classCallCheck(this, StargateClient);\n\n    if (tmClient) {\n      this.tmClient = tmClient;\n      this.queryClient = queries_1.QueryClient.withExtensions(tmClient, queries_1.setupAuthExtension, queries_1.setupBankExtension);\n    }\n  }\n\n  _createClass(StargateClient, [{\n    key: \"getTmClient\",\n    value: function getTmClient() {\n      return this.tmClient;\n    }\n  }, {\n    key: \"forceGetTmClient\",\n    value: function forceGetTmClient() {\n      if (!this.tmClient) {\n        throw new Error(\"Tendermint client not available. You cannot use online functionality in offline mode.\");\n      }\n\n      return this.tmClient;\n    }\n  }, {\n    key: \"getQueryClient\",\n    value: function getQueryClient() {\n      return this.queryClient;\n    }\n  }, {\n    key: \"forceGetQueryClient\",\n    value: function forceGetQueryClient() {\n      if (!this.queryClient) {\n        throw new Error(\"Query client not available. You cannot use online functionality in offline mode.\");\n      }\n\n      return this.queryClient;\n    }\n  }, {\n    key: \"getChainId\",\n    value: function () {\n      var _getChainId = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var response, chainId;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.chainId) {\n                  _context.next = 8;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.forceGetTmClient().status();\n\n              case 3:\n                response = _context.sent;\n                chainId = response.nodeInfo.network;\n\n                if (chainId) {\n                  _context.next = 7;\n                  break;\n                }\n\n                throw new Error(\"Chain ID must not be empty\");\n\n              case 7:\n                this.chainId = chainId;\n\n              case 8:\n                return _context.abrupt(\"return\", this.chainId);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getChainId() {\n        return _getChainId.apply(this, arguments);\n      }\n\n      return getChainId;\n    }()\n  }, {\n    key: \"getHeight\",\n    value: function () {\n      var _getHeight = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var status;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.forceGetTmClient().status();\n\n              case 2:\n                status = _context2.sent;\n                return _context2.abrupt(\"return\", status.syncInfo.latestBlockHeight);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getHeight() {\n        return _getHeight.apply(this, arguments);\n      }\n\n      return getHeight;\n    }()\n  }, {\n    key: \"getAccount\",\n    value: function () {\n      var _getAccount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(searchAddress) {\n        var account;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.prev = 0;\n                _context3.next = 3;\n                return this.forceGetQueryClient().auth.account(searchAddress);\n\n              case 3:\n                account = _context3.sent;\n                return _context3.abrupt(\"return\", account ? accounts_1.accountFromAny(account) : null);\n\n              case 7:\n                _context3.prev = 7;\n                _context3.t0 = _context3[\"catch\"](0);\n\n                if (!/rpc error: code = NotFound/i.test(_context3.t0)) {\n                  _context3.next = 11;\n                  break;\n                }\n\n                return _context3.abrupt(\"return\", null);\n\n              case 11:\n                throw _context3.t0;\n\n              case 12:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[0, 7]]);\n      }));\n\n      function getAccount(_x) {\n        return _getAccount.apply(this, arguments);\n      }\n\n      return getAccount;\n    }()\n  }, {\n    key: \"getAccountVerified\",\n    value: function () {\n      var _getAccountVerified = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(searchAddress) {\n        var account;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.forceGetQueryClient().auth.verified.account(searchAddress);\n\n              case 2:\n                account = _context4.sent;\n                return _context4.abrupt(\"return\", account ? accounts_1.accountFromAny(account) : null);\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getAccountVerified(_x2) {\n        return _getAccountVerified.apply(this, arguments);\n      }\n\n      return getAccountVerified;\n    }()\n  }, {\n    key: \"getSequence\",\n    value: function () {\n      var _getSequence = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(address) {\n        var account;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.getAccount(address);\n\n              case 2:\n                account = _context5.sent;\n\n                if (account) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n\n              case 5:\n                return _context5.abrupt(\"return\", {\n                  accountNumber: account.accountNumber,\n                  sequence: account.sequence\n                });\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getSequence(_x3) {\n        return _getSequence.apply(this, arguments);\n      }\n\n      return getSequence;\n    }()\n  }, {\n    key: \"getBlock\",\n    value: function () {\n      var _getBlock = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(height) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return this.forceGetTmClient().block(height);\n\n              case 2:\n                response = _context6.sent;\n                return _context6.abrupt(\"return\", {\n                  id: encoding_1.toHex(response.blockId.hash).toUpperCase(),\n                  header: {\n                    version: {\n                      block: new math_1.Uint53(response.block.header.version.block).toString(),\n                      app: new math_1.Uint53(response.block.header.version.app).toString()\n                    },\n                    height: response.block.header.height,\n                    chainId: response.block.header.chainId,\n                    time: tendermint_rpc_1.toRfc3339WithNanoseconds(response.block.header.time)\n                  },\n                  txs: response.block.txs\n                });\n\n              case 4:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function getBlock(_x4) {\n        return _getBlock.apply(this, arguments);\n      }\n\n      return getBlock;\n    }()\n  }, {\n    key: \"getBalance\",\n    value: function () {\n      var _getBalance = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(address, searchDenom) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", this.forceGetQueryClient().bank.balance(address, searchDenom));\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getBalance(_x5, _x6) {\n        return _getBalance.apply(this, arguments);\n      }\n\n      return getBalance;\n    }()\n    /**\n     * Queries all balances for all denoms that belong to this address.\n     *\n     * Uses the grpc queries (which iterates over the store internally), and we cannot get\n     * proofs from such a method.\n     */\n\n  }, {\n    key: \"getAllBalances\",\n    value: function () {\n      var _getAllBalances = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(address) {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                return _context8.abrupt(\"return\", this.forceGetQueryClient().bank.allBalances(address));\n\n              case 1:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function getAllBalances(_x7) {\n        return _getAllBalances.apply(this, arguments);\n      }\n\n      return getAllBalances;\n    }()\n  }, {\n    key: \"getTx\",\n    value: function () {\n      var _getTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(id) {\n        var _a, results;\n\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                _context9.next = 2;\n                return this.txsQuery(\"tx.hash='\".concat(id, \"'\"));\n\n              case 2:\n                results = _context9.sent;\n                return _context9.abrupt(\"return\", (_a = results[0]) !== null && _a !== void 0 ? _a : null);\n\n              case 4:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9, this);\n      }));\n\n      function getTx(_x8) {\n        return _getTx.apply(this, arguments);\n      }\n\n      return getTx;\n    }()\n  }, {\n    key: \"searchTx\",\n    value: function () {\n      var _searchTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(query) {\n        var _this2 = this;\n\n        var filter,\n            minHeight,\n            maxHeight,\n            withFilters,\n            txs,\n            sentQuery,\n            receivedQuery,\n            _yield$Promise$all,\n            _yield$Promise$all2,\n            sent,\n            received,\n            sentHashes,\n            rawQuery,\n            filtered,\n            _args10 = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                withFilters = function _withFilters(originalQuery) {\n                  return \"\".concat(originalQuery, \" AND tx.height>=\").concat(minHeight, \" AND tx.height<=\").concat(maxHeight);\n                };\n\n                filter = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n                minHeight = filter.minHeight || 0;\n                maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n\n                if (!(maxHeight < minHeight)) {\n                  _context10.next = 6;\n                  break;\n                }\n\n                return _context10.abrupt(\"return\", []);\n\n              case 6:\n                if (!search_1.isSearchByHeightQuery(query)) {\n                  _context10.next = 17;\n                  break;\n                }\n\n                if (!(query.height >= minHeight && query.height <= maxHeight)) {\n                  _context10.next = 13;\n                  break;\n                }\n\n                _context10.next = 10;\n                return this.txsQuery(\"tx.height=\".concat(query.height));\n\n              case 10:\n                _context10.t0 = _context10.sent;\n                _context10.next = 14;\n                break;\n\n              case 13:\n                _context10.t0 = [];\n\n              case 14:\n                txs = _context10.t0;\n                _context10.next = 38;\n                break;\n\n              case 17:\n                if (!search_1.isSearchBySentFromOrToQuery(query)) {\n                  _context10.next = 30;\n                  break;\n                }\n\n                sentQuery = withFilters(\"message.module='bank' AND transfer.sender='\".concat(query.sentFromOrTo, \"'\"));\n                receivedQuery = withFilters(\"message.module='bank' AND transfer.recipient='\".concat(query.sentFromOrTo, \"'\"));\n                _context10.next = 22;\n                return Promise.all([sentQuery, receivedQuery].map(function (rawQuery) {\n                  return _this2.txsQuery(rawQuery);\n                }));\n\n              case 22:\n                _yield$Promise$all = _context10.sent;\n                _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n                sent = _yield$Promise$all2[0];\n                received = _yield$Promise$all2[1];\n                sentHashes = sent.map(function (t) {\n                  return t.hash;\n                });\n                txs = [].concat(_toConsumableArray(sent), _toConsumableArray(received.filter(function (t) {\n                  return !sentHashes.includes(t.hash);\n                })));\n                _context10.next = 38;\n                break;\n\n              case 30:\n                if (!search_1.isSearchByTagsQuery(query)) {\n                  _context10.next = 37;\n                  break;\n                }\n\n                rawQuery = withFilters(query.tags.map(function (t) {\n                  return \"\".concat(t.key, \"='\").concat(t.value, \"'\");\n                }).join(\" AND \"));\n                _context10.next = 34;\n                return this.txsQuery(rawQuery);\n\n              case 34:\n                txs = _context10.sent;\n                _context10.next = 38;\n                break;\n\n              case 37:\n                throw new Error(\"Unknown query type\");\n\n              case 38:\n                filtered = txs.filter(function (tx) {\n                  return tx.height >= minHeight && tx.height <= maxHeight;\n                });\n                return _context10.abrupt(\"return\", filtered);\n\n              case 40:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10, this);\n      }));\n\n      function searchTx(_x9) {\n        return _searchTx.apply(this, arguments);\n      }\n\n      return searchTx;\n    }()\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.tmClient) this.tmClient.disconnect();\n    }\n    /**\n     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.\n     *\n     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),\n     * an error is thrown.\n     *\n     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.\n     *\n     * If the transaction is included in a block, a `BroadcastTxResponse` is returned. The caller then\n     * usually needs to check for execution success or failure.\n     */\n\n  }, {\n    key: \"broadcastTx\",\n    value: function () {\n      var _broadcastTx = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(tx) {\n        var _this3 = this;\n\n        var timeoutMs,\n            pollIntervalMs,\n            timedOut,\n            txPollTimeout,\n            pollForTx,\n            broadcasted,\n            transactionId,\n            _args12 = arguments;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                timeoutMs = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : 60000;\n                pollIntervalMs = _args12.length > 2 && _args12[2] !== undefined ? _args12[2] : 3000;\n                timedOut = false;\n                txPollTimeout = setTimeout(function () {\n                  timedOut = true;\n                }, timeoutMs);\n\n                pollForTx = /*#__PURE__*/function () {\n                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(txId) {\n                    var result;\n                    return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n                      while (1) {\n                        switch (_context11.prev = _context11.next) {\n                          case 0:\n                            if (!timedOut) {\n                              _context11.next = 2;\n                              break;\n                            }\n\n                            throw new TimeoutError(\"Transaction with ID \".concat(txId, \" was submitted but was not yet found on the chain. You might want to check later.\"), txId);\n\n                          case 2:\n                            _context11.next = 4;\n                            return utils_1.sleep(pollIntervalMs);\n\n                          case 4:\n                            _context11.next = 6;\n                            return _this3.getTx(txId);\n\n                          case 6:\n                            result = _context11.sent;\n                            return _context11.abrupt(\"return\", result ? {\n                              code: result.code,\n                              height: result.height,\n                              rawLog: result.rawLog,\n                              transactionHash: txId,\n                              gasUsed: result.gasUsed,\n                              gasWanted: result.gasWanted\n                            } : pollForTx(txId));\n\n                          case 8:\n                          case \"end\":\n                            return _context11.stop();\n                        }\n                      }\n                    }, _callee11);\n                  }));\n\n                  return function pollForTx(_x11) {\n                    return _ref.apply(this, arguments);\n                  };\n                }();\n\n                _context12.next = 7;\n                return this.forceGetTmClient().broadcastTxSync({\n                  tx: tx\n                });\n\n              case 7:\n                broadcasted = _context12.sent;\n\n                if (!broadcasted.code) {\n                  _context12.next = 10;\n                  break;\n                }\n\n                throw new Error(\"Broadcasting transaction failed with code \".concat(broadcasted.code, \" (codespace: \").concat(broadcasted.codeSpace, \"). Log: \").concat(broadcasted.log));\n\n              case 10:\n                transactionId = encoding_1.toHex(broadcasted.hash).toUpperCase();\n                return _context12.abrupt(\"return\", new Promise(function (resolve, reject) {\n                  return pollForTx(transactionId).then(function (value) {\n                    clearTimeout(txPollTimeout);\n                    resolve(value);\n                  }, function (error) {\n                    clearTimeout(txPollTimeout);\n                    reject(error);\n                  });\n                }));\n\n              case 12:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12, this);\n      }));\n\n      function broadcastTx(_x10) {\n        return _broadcastTx.apply(this, arguments);\n      }\n\n      return broadcastTx;\n    }()\n  }, {\n    key: \"txsQuery\",\n    value: function () {\n      var _txsQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(query) {\n        var results;\n        return _regeneratorRuntime.wrap(function _callee13$(_context13) {\n          while (1) {\n            switch (_context13.prev = _context13.next) {\n              case 0:\n                _context13.next = 2;\n                return this.forceGetTmClient().txSearchAll({\n                  query: query\n                });\n\n              case 2:\n                results = _context13.sent;\n                return _context13.abrupt(\"return\", results.txs.map(function (tx) {\n                  return {\n                    height: tx.height,\n                    hash: encoding_1.toHex(tx.hash).toUpperCase(),\n                    code: tx.result.code,\n                    rawLog: tx.result.log || \"\",\n                    tx: tx.tx,\n                    gasUsed: tx.result.gasUsed,\n                    gasWanted: tx.result.gasWanted\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context13.stop();\n            }\n          }\n        }, _callee13, this);\n      }));\n\n      function txsQuery(_x12) {\n        return _txsQuery.apply(this, arguments);\n      }\n\n      return txsQuery;\n    }()\n  }], [{\n    key: \"connect\",\n    value: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(endpoint) {\n        var tmClient;\n        return _regeneratorRuntime.wrap(function _callee14$(_context14) {\n          while (1) {\n            switch (_context14.prev = _context14.next) {\n              case 0:\n                _context14.next = 2;\n                return tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n\n              case 2:\n                tmClient = _context14.sent;\n                return _context14.abrupt(\"return\", new StargateClient(tmClient));\n\n              case 4:\n              case \"end\":\n                return _context14.stop();\n            }\n          }\n        }, _callee14);\n      }));\n\n      function connect(_x13) {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }()\n  }]);\n\n  return StargateClient;\n}();\n\nexports.StargateClient = StargateClient;","map":null,"metadata":{},"sourceType":"script"}