{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DirectSecp256k1HdWallet = exports.extractKdfConfiguration = void 0;\n\nvar amino_1 = require(\"@cosmjs/amino\");\n\nvar crypto_1 = require(\"@cosmjs/crypto\");\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar build_1 = require(\"@cosmjs/utils/build\");\n\nvar signing_1 = require(\"./signing\");\n\nvar wallet_1 = require(\"./wallet\");\n\nvar serializationTypeV1 = \"directsecp256k1hdwallet-v1\";\n/**\n * A KDF configuration that is not very strong but can be used on the main thread.\n * It takes about 1 second in Node.js 16.0.0 and should have similar runtimes in other modern Wasm hosts.\n */\n\nvar basicPasswordHashingOptions = {\n  algorithm: \"argon2id\",\n  params: {\n    outputLength: 32,\n    opsLimit: 24,\n    memLimitKib: 12 * 1024\n  }\n};\n\nfunction isDerivationJson(thing) {\n  if (!build_1.isNonNullObject(thing)) return false;\n  if (typeof thing.hdPath !== \"string\") return false;\n  if (typeof thing.prefix !== \"string\") return false;\n  return true;\n}\n\nfunction extractKdfConfigurationV1(doc) {\n  return doc.kdf;\n}\n\nfunction extractKdfConfiguration(serialization) {\n  var root = JSON.parse(serialization);\n  if (!build_1.isNonNullObject(root)) throw new Error(\"Root document is not an object.\");\n\n  switch (root.type) {\n    case serializationTypeV1:\n      return extractKdfConfigurationV1(root);\n\n    default:\n      throw new Error(\"Unsupported serialization type\");\n  }\n}\n\nexports.extractKdfConfiguration = extractKdfConfiguration;\nvar defaultOptions = {\n  bip39Password: \"\",\n  hdPaths: [amino_1.makeCosmoshubPath(0)],\n  prefix: \"cosmos\"\n};\n/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */\n\nvar DirectSecp256k1HdWallet = /*#__PURE__*/function () {\n  function DirectSecp256k1HdWallet(mnemonic, options) {\n    _classCallCheck(this, DirectSecp256k1HdWallet);\n\n    var _a, _b;\n\n    var prefix = (_a = options.prefix) !== null && _a !== void 0 ? _a : defaultOptions.prefix;\n    var hdPaths = (_b = options.hdPaths) !== null && _b !== void 0 ? _b : defaultOptions.hdPaths;\n    this.secret = mnemonic;\n    this.seed = options.seed;\n    this.accounts = hdPaths.map(function (hdPath) {\n      return {\n        hdPath: hdPath,\n        prefix: prefix\n      };\n    });\n  }\n  /**\n   * Restores a wallet from the given BIP39 mnemonic.\n   *\n   * @param mnemonic Any valid English mnemonic.\n   * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n   */\n\n\n  _createClass(DirectSecp256k1HdWallet, [{\n    key: \"mnemonic\",\n    get: function get() {\n      return this.secret.toString();\n    }\n  }, {\n    key: \"getAccounts\",\n    value: function () {\n      var _getAccounts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var accountsWithPrivkeys;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.getAccountsWithPrivkeys();\n\n              case 2:\n                accountsWithPrivkeys = _context.sent;\n                return _context.abrupt(\"return\", accountsWithPrivkeys.map(function (_ref) {\n                  var algo = _ref.algo,\n                      pubkey = _ref.pubkey,\n                      address = _ref.address;\n                  return {\n                    algo: algo,\n                    pubkey: pubkey,\n                    address: address\n                  };\n                }));\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAccounts() {\n        return _getAccounts.apply(this, arguments);\n      }\n\n      return getAccounts;\n    }()\n  }, {\n    key: \"signDirect\",\n    value: function () {\n      var _signDirect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(signerAddress, signDoc) {\n        var accounts, account, privkey, pubkey, signBytes, hashedMessage, signature, signatureBytes, stdSignature;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.getAccountsWithPrivkeys();\n\n              case 2:\n                accounts = _context2.sent;\n                account = accounts.find(function (_ref2) {\n                  var address = _ref2.address;\n                  return address === signerAddress;\n                });\n\n                if (!(account === undefined)) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Address \".concat(signerAddress, \" not found in wallet\"));\n\n              case 6:\n                privkey = account.privkey, pubkey = account.pubkey;\n                signBytes = signing_1.makeSignBytes(signDoc);\n                hashedMessage = crypto_1.sha256(signBytes);\n                _context2.next = 11;\n                return crypto_1.Secp256k1.createSignature(hashedMessage, privkey);\n\n              case 11:\n                signature = _context2.sent;\n                signatureBytes = new Uint8Array([].concat(_toConsumableArray(signature.r(32)), _toConsumableArray(signature.s(32))));\n                stdSignature = amino_1.encodeSecp256k1Signature(pubkey, signatureBytes);\n                return _context2.abrupt(\"return\", {\n                  signed: signDoc,\n                  signature: stdSignature\n                });\n\n              case 15:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function signDirect(_x, _x2) {\n        return _signDirect.apply(this, arguments);\n      }\n\n      return signDirect;\n    }()\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function () {\n      var _serialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(password) {\n        var kdfConfiguration, encryptionKey;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                kdfConfiguration = basicPasswordHashingOptions;\n                _context3.next = 3;\n                return wallet_1.executeKdf(password, kdfConfiguration);\n\n              case 3:\n                encryptionKey = _context3.sent;\n                return _context3.abrupt(\"return\", this.serializeWithEncryptionKey(encryptionKey, kdfConfiguration));\n\n              case 5:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function serialize(_x3) {\n        return _serialize.apply(this, arguments);\n      }\n\n      return serialize;\n    }()\n    /**\n     * Generates an encrypted serialization of this wallet.\n     *\n     * This is an advanced alternative to calling `serialize(password)` directly, which allows you to\n     * offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF options. If this\n     * is not the case, the wallet cannot be restored with the original password.\n     */\n\n  }, {\n    key: \"serializeWithEncryptionKey\",\n    value: function () {\n      var _serializeWithEncryptionKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(encryptionKey, kdfConfiguration) {\n        var dataToEncrypt, dataToEncryptRaw, encryptionConfiguration, encryptedData, out;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                dataToEncrypt = {\n                  mnemonic: this.mnemonic,\n                  accounts: this.accounts.map(function (_ref3) {\n                    var hdPath = _ref3.hdPath,\n                        prefix = _ref3.prefix;\n                    return {\n                      hdPath: crypto_1.pathToString(hdPath),\n                      prefix: prefix\n                    };\n                  })\n                };\n                dataToEncryptRaw = encoding_1.toUtf8(JSON.stringify(dataToEncrypt));\n                encryptionConfiguration = {\n                  algorithm: wallet_1.supportedAlgorithms.xchacha20poly1305Ietf\n                };\n                _context4.next = 5;\n                return wallet_1.encrypt(dataToEncryptRaw, encryptionKey, encryptionConfiguration);\n\n              case 5:\n                encryptedData = _context4.sent;\n                out = {\n                  type: serializationTypeV1,\n                  kdf: kdfConfiguration,\n                  encryption: encryptionConfiguration,\n                  data: encoding_1.toBase64(encryptedData)\n                };\n                return _context4.abrupt(\"return\", JSON.stringify(out));\n\n              case 8:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function serializeWithEncryptionKey(_x4, _x5) {\n        return _serializeWithEncryptionKey.apply(this, arguments);\n      }\n\n      return serializeWithEncryptionKey;\n    }()\n  }, {\n    key: \"getKeyPair\",\n    value: function () {\n      var _getKeyPair = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(hdPath) {\n        var _crypto_1$Slip10$deri, privkey, _yield$crypto_1$Secp, pubkey;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _crypto_1$Slip10$deri = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath), privkey = _crypto_1$Slip10$deri.privkey;\n                _context5.next = 3;\n                return crypto_1.Secp256k1.makeKeypair(privkey);\n\n              case 3:\n                _yield$crypto_1$Secp = _context5.sent;\n                pubkey = _yield$crypto_1$Secp.pubkey;\n                return _context5.abrupt(\"return\", {\n                  privkey: privkey,\n                  pubkey: crypto_1.Secp256k1.compressPubkey(pubkey)\n                });\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function getKeyPair(_x6) {\n        return _getKeyPair.apply(this, arguments);\n      }\n\n      return getKeyPair;\n    }()\n  }, {\n    key: \"getAccountsWithPrivkeys\",\n    value: function () {\n      var _getAccountsWithPrivkeys = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var _this = this;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                return _context7.abrupt(\"return\", Promise.all(this.accounts.map( /*#__PURE__*/function () {\n                  var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(_ref4) {\n                    var hdPath, prefix, _yield$_this$getKeyPa, privkey, pubkey, address;\n\n                    return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                      while (1) {\n                        switch (_context6.prev = _context6.next) {\n                          case 0:\n                            hdPath = _ref4.hdPath, prefix = _ref4.prefix;\n                            _context6.next = 3;\n                            return _this.getKeyPair(hdPath);\n\n                          case 3:\n                            _yield$_this$getKeyPa = _context6.sent;\n                            privkey = _yield$_this$getKeyPa.privkey;\n                            pubkey = _yield$_this$getKeyPa.pubkey;\n                            address = encoding_1.Bech32.encode(prefix, amino_1.rawSecp256k1PubkeyToRawAddress(pubkey));\n                            return _context6.abrupt(\"return\", {\n                              algo: \"secp256k1\",\n                              privkey: privkey,\n                              pubkey: pubkey,\n                              address: address\n                            });\n\n                          case 8:\n                          case \"end\":\n                            return _context6.stop();\n                        }\n                      }\n                    }, _callee6);\n                  }));\n\n                  return function (_x7) {\n                    return _ref5.apply(this, arguments);\n                  };\n                }())));\n\n              case 1:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function getAccountsWithPrivkeys() {\n        return _getAccountsWithPrivkeys.apply(this, arguments);\n      }\n\n      return getAccountsWithPrivkeys;\n    }()\n  }], [{\n    key: \"fromMnemonic\",\n    value: function () {\n      var _fromMnemonic = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(mnemonic) {\n        var options,\n            mnemonicChecked,\n            seed,\n            _args8 = arguments;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                options = _args8.length > 1 && _args8[1] !== undefined ? _args8[1] : {};\n                mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);\n                _context8.next = 4;\n                return crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);\n\n              case 4:\n                seed = _context8.sent;\n                return _context8.abrupt(\"return\", new DirectSecp256k1HdWallet(mnemonicChecked, Object.assign(Object.assign({}, options), {\n                  seed: seed\n                })));\n\n              case 6:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function fromMnemonic(_x8) {\n        return _fromMnemonic.apply(this, arguments);\n      }\n\n      return fromMnemonic;\n    }()\n    /**\n     * Generates a new wallet with a BIP39 mnemonic of the given length.\n     *\n     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).\n     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.\n     */\n\n  }, {\n    key: \"generate\",\n    value: function () {\n      var _generate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {\n        var length,\n            options,\n            entropyLength,\n            entropy,\n            mnemonic,\n            _args9 = arguments;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                length = _args9.length > 0 && _args9[0] !== undefined ? _args9[0] : 12;\n                options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n                entropyLength = 4 * Math.floor(11 * length / 33);\n                entropy = crypto_1.Random.getBytes(entropyLength);\n                mnemonic = crypto_1.Bip39.encode(entropy);\n                return _context9.abrupt(\"return\", DirectSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options));\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function generate() {\n        return _generate.apply(this, arguments);\n      }\n\n      return generate;\n    }()\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * @param password The user provided password used to generate an encryption key via a KDF.\n     *                 This is not normalized internally (see \"Unicode normalization\" to learn more).\n     */\n\n  }, {\n    key: \"deserialize\",\n    value: function () {\n      var _deserialize = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(serialization, password) {\n        var root;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                root = JSON.parse(serialization);\n\n                if (build_1.isNonNullObject(root)) {\n                  _context10.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Root document is not an object.\");\n\n              case 3:\n                _context10.t0 = root.type;\n                _context10.next = _context10.t0 === serializationTypeV1 ? 6 : 7;\n                break;\n\n              case 6:\n                return _context10.abrupt(\"return\", DirectSecp256k1HdWallet.deserializeTypeV1(serialization, password));\n\n              case 7:\n                throw new Error(\"Unsupported serialization type\");\n\n              case 8:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function deserialize(_x9, _x10) {\n        return _deserialize.apply(this, arguments);\n      }\n\n      return deserialize;\n    }()\n    /**\n     * Restores a wallet from an encrypted serialization.\n     *\n     * This is an advanced alternative to calling `deserialize(serialization, password)` directly, which allows\n     * you to offload the KDF execution to a non-UI thread (e.g. in a WebWorker).\n     *\n     * The caller is responsible for ensuring the key was derived with the given KDF configuration. This can be\n     * done using `extractKdfConfiguration(serialization)` and `executeKdf(password, kdfConfiguration)` from this package.\n     */\n\n  }, {\n    key: \"deserializeWithEncryptionKey\",\n    value: function () {\n      var _deserializeWithEncryptionKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(serialization, encryptionKey) {\n        var root, untypedRoot, decryptedBytes, decryptedDocument, mnemonic, accounts, firstPrefix, hdPaths;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                root = JSON.parse(serialization);\n\n                if (build_1.isNonNullObject(root)) {\n                  _context11.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Root document is not an object.\");\n\n              case 3:\n                untypedRoot = root;\n                _context11.t0 = untypedRoot.type;\n                _context11.next = _context11.t0 === serializationTypeV1 ? 7 : 22;\n                break;\n\n              case 7:\n                _context11.next = 9;\n                return wallet_1.decrypt(encoding_1.fromBase64(untypedRoot.data), encryptionKey, untypedRoot.encryption);\n\n              case 9:\n                decryptedBytes = _context11.sent;\n                decryptedDocument = JSON.parse(encoding_1.fromUtf8(decryptedBytes));\n                mnemonic = decryptedDocument.mnemonic, accounts = decryptedDocument.accounts;\n                build_1.assert(typeof mnemonic === \"string\");\n\n                if (Array.isArray(accounts)) {\n                  _context11.next = 15;\n                  break;\n                }\n\n                throw new Error(\"Property 'accounts' is not an array\");\n\n              case 15:\n                if (accounts.every(function (account) {\n                  return isDerivationJson(account);\n                })) {\n                  _context11.next = 17;\n                  break;\n                }\n\n                throw new Error(\"Account is not in the correct format.\");\n\n              case 17:\n                firstPrefix = accounts[0].prefix;\n\n                if (accounts.every(function (_ref6) {\n                  var prefix = _ref6.prefix;\n                  return prefix === firstPrefix;\n                })) {\n                  _context11.next = 20;\n                  break;\n                }\n\n                throw new Error(\"Accounts do not all have the same prefix\");\n\n              case 20:\n                hdPaths = accounts.map(function (_ref7) {\n                  var hdPath = _ref7.hdPath;\n                  return crypto_1.stringToPath(hdPath);\n                });\n                return _context11.abrupt(\"return\", DirectSecp256k1HdWallet.fromMnemonic(mnemonic, {\n                  hdPaths: hdPaths,\n                  prefix: firstPrefix\n                }));\n\n              case 22:\n                throw new Error(\"Unsupported serialization type\");\n\n              case 23:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11);\n      }));\n\n      function deserializeWithEncryptionKey(_x11, _x12) {\n        return _deserializeWithEncryptionKey.apply(this, arguments);\n      }\n\n      return deserializeWithEncryptionKey;\n    }()\n  }, {\n    key: \"deserializeTypeV1\",\n    value: function () {\n      var _deserializeTypeV = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(serialization, password) {\n        var root, encryptionKey;\n        return _regeneratorRuntime.wrap(function _callee12$(_context12) {\n          while (1) {\n            switch (_context12.prev = _context12.next) {\n              case 0:\n                root = JSON.parse(serialization);\n\n                if (build_1.isNonNullObject(root)) {\n                  _context12.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Root document is not an object.\");\n\n              case 3:\n                _context12.next = 5;\n                return wallet_1.executeKdf(password, root.kdf);\n\n              case 5:\n                encryptionKey = _context12.sent;\n                return _context12.abrupt(\"return\", DirectSecp256k1HdWallet.deserializeWithEncryptionKey(serialization, encryptionKey));\n\n              case 7:\n              case \"end\":\n                return _context12.stop();\n            }\n          }\n        }, _callee12);\n      }));\n\n      function deserializeTypeV1(_x13, _x14) {\n        return _deserializeTypeV.apply(this, arguments);\n      }\n\n      return deserializeTypeV1;\n    }()\n  }]);\n\n  return DirectSecp256k1HdWallet;\n}();\n\nexports.DirectSecp256k1HdWallet = DirectSecp256k1HdWallet;","map":null,"metadata":{},"sourceType":"script"}