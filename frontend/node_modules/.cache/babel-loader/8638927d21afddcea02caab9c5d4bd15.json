{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ReconnectingSocket = void 0;\n\nvar xstream_1 = require(\"xstream\");\n\nvar queueingstreamingsocket_1 = require(\"./queueingstreamingsocket\");\n/**\n * A wrapper around QueueingStreamingSocket that reconnects automatically.\n */\n\n\nvar ReconnectingSocket = /*#__PURE__*/function () {\n  function ReconnectingSocket(url) {\n    var _this = this;\n\n    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;\n    var reconnectedHandler = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ReconnectingSocket);\n\n    this.unconnected = true;\n    this.disconnected = false;\n    this.timeoutIndex = 0;\n    this.reconnectTimeout = null;\n    var eventProducer = {\n      start: function start(listener) {\n        return _this.eventProducerListener = listener;\n      },\n      stop: function stop() {\n        return _this.eventProducerListener = undefined;\n      }\n    };\n    this.events = xstream_1.Stream.create(eventProducer);\n    this.socket = new queueingstreamingsocket_1.QueueingStreamingSocket(url, timeout, reconnectedHandler);\n    this.socket.events.subscribe({\n      next: function next(event) {\n        if (_this.eventProducerListener) {\n          _this.eventProducerListener.next(event);\n        }\n      },\n      error: function error(_error) {\n        if (_this.eventProducerListener) {\n          _this.eventProducerListener.error(_error);\n        }\n      }\n    });\n    this.connectionStatus = this.socket.connectionStatus;\n    this.connectionStatus.updates.subscribe({\n      next: function next(status) {\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Connected) {\n          _this.timeoutIndex = 0;\n        }\n\n        if (status === queueingstreamingsocket_1.ConnectionStatus.Disconnected) {\n          if (_this.reconnectTimeout) {\n            clearTimeout(_this.reconnectTimeout);\n            _this.reconnectTimeout = null;\n          }\n\n          _this.reconnectTimeout = setTimeout(function () {\n            return _this.socket.reconnect();\n          }, ReconnectingSocket.calculateTimeout(_this.timeoutIndex++));\n        }\n      }\n    });\n  }\n  /** Starts with a 0.1 second timeout, then doubles every attempt with a maximum timeout of 5 seconds. */\n\n\n  _createClass(ReconnectingSocket, [{\n    key: \"connect\",\n    value: function connect() {\n      if (!this.unconnected) {\n        throw new Error(\"Cannot connect: socket has already connected\");\n      }\n\n      this.socket.connect();\n      this.unconnected = false;\n    }\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      if (this.unconnected) {\n        throw new Error(\"Cannot disconnect: socket has not yet connected\");\n      }\n\n      this.socket.disconnect();\n\n      if (this.eventProducerListener) {\n        this.eventProducerListener.complete();\n      }\n\n      this.disconnected = true;\n    }\n  }, {\n    key: \"queueRequest\",\n    value: function queueRequest(request) {\n      if (this.disconnected) {\n        throw new Error(\"Cannot queue request: socket has disconnected\");\n      }\n\n      this.socket.queueRequest(request);\n    }\n  }], [{\n    key: \"calculateTimeout\",\n    value: function calculateTimeout(index) {\n      return Math.min(Math.pow(2, index) * 100, 5000);\n    }\n  }]);\n\n  return ReconnectingSocket;\n}();\n\nexports.ReconnectingSocket = ReconnectingSocket;","map":null,"metadata":{},"sourceType":"script"}