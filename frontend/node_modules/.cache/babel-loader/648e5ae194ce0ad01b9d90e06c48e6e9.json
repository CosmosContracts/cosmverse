{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QueryClient = void 0;\n/* eslint-disable no-dupe-class-members, @typescript-eslint/ban-types, @typescript-eslint/naming-convention */\n\nvar ics23_1 = require(\"@confio/ics23\");\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar stream_1 = require(\"@cosmjs/stream\");\n\nvar utils_1 = require(\"@cosmjs/utils\");\n\nfunction checkAndParseOp(op, kind, key) {\n  if (op.type !== kind) {\n    throw new Error(\"Op expected to be \".concat(kind, \", got \\\"\").concat(op.type));\n  }\n\n  if (!utils_1.arrayContentEquals(key, op.key)) {\n    throw new Error(\"Proven key different than queried key.\\nQuery: \".concat(encoding_1.toHex(key), \"\\nProven: \").concat(encoding_1.toHex(op.key)));\n  }\n\n  return ics23_1.ics23.CommitmentProof.decode(op.data);\n}\n\nvar QueryClient = /*#__PURE__*/function () {\n  function QueryClient(tmClient) {\n    _classCallCheck(this, QueryClient);\n\n    this.tmClient = tmClient;\n  }\n\n  _createClass(QueryClient, [{\n    key: \"queryVerified\",\n    value: function () {\n      var _queryVerified = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(store, key, desiredHeight) {\n        var _yield$this$queryRawP, height, proof, value, subProof, storeProof, header;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.queryRawProof(store, key, desiredHeight);\n\n              case 2:\n                _yield$this$queryRawP = _context.sent;\n                height = _yield$this$queryRawP.height;\n                proof = _yield$this$queryRawP.proof;\n                value = _yield$this$queryRawP.value;\n                subProof = checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n                storeProof = checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store)); // this must always be existence, if the store is not a typo\n\n                utils_1.assert(storeProof.exist);\n                utils_1.assert(storeProof.exist.value); // this may be exist or non-exist, depends on response\n\n                if (!value || value.length === 0) {\n                  // non-existence check\n                  utils_1.assert(subProof.nonexist); // the subproof must map the desired key to the \"value\" of the storeProof\n\n                  ics23_1.verifyNonExistence(subProof.nonexist, ics23_1.iavlSpec, storeProof.exist.value, key);\n                } else {\n                  // existence check\n                  utils_1.assert(subProof.exist);\n                  utils_1.assert(subProof.exist.value); // the subproof must map the desired key to the \"value\" of the storeProof\n\n                  ics23_1.verifyExistence(subProof.exist, ics23_1.iavlSpec, storeProof.exist.value, key, value);\n                } // the store proof must map its declared value (root of subProof) to the appHash of the next block\n\n\n                _context.next = 13;\n                return this.getNextHeader(height);\n\n              case 13:\n                header = _context.sent;\n                ics23_1.verifyExistence(storeProof.exist, ics23_1.tendermintSpec, header.appHash, encoding_1.toAscii(store), storeProof.exist.value);\n                return _context.abrupt(\"return\", value);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function queryVerified(_x, _x2, _x3) {\n        return _queryVerified.apply(this, arguments);\n      }\n\n      return queryVerified;\n    }()\n  }, {\n    key: \"queryRawProof\",\n    value: function () {\n      var _queryRawProof = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(store, queryKey, desiredHeight) {\n        var _a, _yield$this$tmClient$, key, value, height, proof, code, log;\n\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.tmClient.abciQuery({\n                  // we need the StoreKey for the module, not the module name\n                  // https://github.com/cosmos/cosmos-sdk/blob/8cab43c8120fec5200c3459cbf4a92017bb6f287/x/auth/types/keys.go#L12\n                  path: \"/store/\".concat(store, \"/key\"),\n                  data: queryKey,\n                  prove: true,\n                  height: desiredHeight\n                });\n\n              case 2:\n                _yield$this$tmClient$ = _context2.sent;\n                key = _yield$this$tmClient$.key;\n                value = _yield$this$tmClient$.value;\n                height = _yield$this$tmClient$.height;\n                proof = _yield$this$tmClient$.proof;\n                code = _yield$this$tmClient$.code;\n                log = _yield$this$tmClient$.log;\n\n                if (!code) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                throw new Error(\"Query failed with (\".concat(code, \"): \").concat(log));\n\n              case 11:\n                if (utils_1.arrayContentEquals(queryKey, key)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                throw new Error(\"Response key \".concat(encoding_1.toHex(key), \" doesn't match query key \").concat(encoding_1.toHex(queryKey)));\n\n              case 13:\n                if (height) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                throw new Error(\"No query height returned\");\n\n              case 15:\n                if (!(!proof || proof.ops.length !== 2)) {\n                  _context2.next = 17;\n                  break;\n                }\n\n                throw new Error(\"Expected 2 proof ops, got \".concat((_a = proof === null || proof === void 0 ? void 0 : proof.ops.length) !== null && _a !== void 0 ? _a : 0, \". Are you using stargate?\"));\n\n              case 17:\n                // we don't need the results, but we can ensure the data is the proper format\n                checkAndParseOp(proof.ops[0], \"ics23:iavl\", key);\n                checkAndParseOp(proof.ops[1], \"ics23:simple\", encoding_1.toAscii(store));\n                return _context2.abrupt(\"return\", {\n                  key: key,\n                  value: value,\n                  height: height,\n                  // need to clone this: readonly input / writeable output\n                  proof: {\n                    ops: _toConsumableArray(proof.ops)\n                  }\n                });\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function queryRawProof(_x4, _x5, _x6) {\n        return _queryRawProof.apply(this, arguments);\n      }\n\n      return queryRawProof;\n    }()\n  }, {\n    key: \"queryUnverified\",\n    value: function () {\n      var _queryUnverified = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(path, request) {\n        var response;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.tmClient.abciQuery({\n                  path: path,\n                  data: request,\n                  prove: false\n                });\n\n              case 2:\n                response = _context3.sent;\n\n                if (!response.code) {\n                  _context3.next = 5;\n                  break;\n                }\n\n                throw new Error(\"Query failed with (\".concat(response.code, \"): \").concat(response.log));\n\n              case 5:\n                return _context3.abrupt(\"return\", response.value);\n\n              case 6:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function queryUnverified(_x7, _x8) {\n        return _queryUnverified.apply(this, arguments);\n      }\n\n      return queryUnverified;\n    }() // this must return the header for height+1\n    // throws an error if height is 0 or undefined\n\n  }, {\n    key: \"getNextHeader\",\n    value: function () {\n      var _getNextHeader = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(height) {\n        var searchHeight, nextHeader, headersSubscription, firstHeader, correctHeader;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                utils_1.assertDefined(height);\n\n                if (!(height === 0)) {\n                  _context4.next = 3;\n                  break;\n                }\n\n                throw new Error(\"Query returned height 0, cannot prove it\");\n\n              case 3:\n                searchHeight = height + 1;\n\n                try {\n                  headersSubscription = this.tmClient.subscribeNewBlockHeader();\n                } catch (_a) {// Ignore exception caused by non-WebSocket Tendermint clients\n                }\n\n                if (!headersSubscription) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                _context4.next = 8;\n                return stream_1.firstEvent(headersSubscription);\n\n              case 8:\n                firstHeader = _context4.sent;\n\n                // The first header we get might not be n+1 but n+2 or even higher. In such cases we fall back on a query.\n                if (firstHeader.height === searchHeight) {\n                  nextHeader = firstHeader;\n                }\n\n              case 10:\n                if (nextHeader) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                _context4.next = 13;\n                return this.tmClient.blockchain(height, searchHeight);\n\n              case 13:\n                correctHeader = _context4.sent.blockMetas.map(function (meta) {\n                  return meta.header;\n                }).find(function (h) {\n                  return h.height === searchHeight;\n                });\n\n                if (!correctHeader) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                nextHeader = correctHeader;\n                _context4.next = 20;\n                break;\n\n              case 18:\n                _context4.next = 20;\n                return utils_1.sleep(1000);\n\n              case 20:\n                _context4.next = 10;\n                break;\n\n              case 22:\n                utils_1.assert(nextHeader.height === searchHeight, \"Got wrong header. This is a bug in the logic above.\");\n                return _context4.abrupt(\"return\", nextHeader);\n\n              case 24:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function getNextHeader(_x9) {\n        return _getNextHeader.apply(this, arguments);\n      }\n\n      return getNextHeader;\n    }()\n  }], [{\n    key: \"withExtensions\",\n    value: function withExtensions(tmClient) {\n      var client = new QueryClient(tmClient);\n\n      for (var _len = arguments.length, extensionSetups = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        extensionSetups[_key - 1] = arguments[_key];\n      }\n\n      var extensions = extensionSetups.map(function (setupExtension) {\n        return setupExtension(client);\n      });\n\n      var _iterator = _createForOfIteratorHelper(extensions),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var extension = _step.value;\n          utils_1.assert(utils_1.isNonNullObject(extension), \"Extension must be a non-null object\");\n\n          for (var _i = 0, _Object$entries = Object.entries(extension); _i < _Object$entries.length; _i++) {\n            var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n                moduleKey = _Object$entries$_i[0],\n                moduleValue = _Object$entries$_i[1];\n\n            utils_1.assert(utils_1.isNonNullObject(moduleValue), \"Module must be a non-null object. Found type \".concat(typeof moduleValue, \" for module \\\"\").concat(moduleKey, \"\\\".\"));\n            var current = client[moduleKey] || {};\n            client[moduleKey] = Object.assign(Object.assign({}, current), moduleValue);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return client;\n    }\n  }]);\n\n  return QueryClient;\n}();\n\nexports.QueryClient = QueryClient;","map":null,"metadata":{},"sourceType":"script"}