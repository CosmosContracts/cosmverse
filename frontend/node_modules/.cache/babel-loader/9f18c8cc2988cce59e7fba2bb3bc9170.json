{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Registry = exports.isTxBodyEncodeObject = exports.isPbjsGeneratedType = exports.isTsProtoGeneratedType = void 0;\n\nvar tx_1 = require(\"./codec/cosmos/bank/v1beta1/tx\");\n\nvar coin_1 = require(\"./codec/cosmos/base/v1beta1/coin\");\n\nvar tx_2 = require(\"./codec/cosmos/tx/v1beta1/tx\");\n\nvar any_1 = require(\"./codec/google/protobuf/any\");\n\nfunction isTsProtoGeneratedType(type) {\n  return typeof type.fromPartial === \"function\";\n}\n\nexports.isTsProtoGeneratedType = isTsProtoGeneratedType;\n\nfunction isPbjsGeneratedType(type) {\n  return !isTsProtoGeneratedType(type);\n}\n\nexports.isPbjsGeneratedType = isPbjsGeneratedType;\nvar defaultTypeUrls = {\n  cosmosCoin: \"/cosmos.base.v1beta1.Coin\",\n  cosmosMsgSend: \"/cosmos.bank.v1beta1.MsgSend\",\n  cosmosTxBody: \"/cosmos.tx.v1beta1.TxBody\",\n  googleAny: \"/google.protobuf.Any\"\n};\n\nfunction isTxBodyEncodeObject(encodeObject) {\n  return encodeObject.typeUrl === \"/cosmos.tx.v1beta1.TxBody\";\n}\n\nexports.isTxBodyEncodeObject = isTxBodyEncodeObject;\n\nvar Registry = /*#__PURE__*/function () {\n  function Registry() {\n    var customTypes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Registry);\n\n    var cosmosCoin = defaultTypeUrls.cosmosCoin,\n        cosmosMsgSend = defaultTypeUrls.cosmosMsgSend;\n    this.types = new Map([[cosmosCoin, coin_1.Coin], [cosmosMsgSend, tx_1.MsgSend]].concat(_toConsumableArray(customTypes)));\n  }\n\n  _createClass(Registry, [{\n    key: \"register\",\n    value: function register(typeUrl, type) {\n      this.types.set(typeUrl, type);\n    }\n    /**\n     * Looks up a type that was previously added to the registry.\n     *\n     * The generator information (ts-proto or pbjs) gets lost along the way.\n     * If you need to work with the result type in TypeScript, you can use:\n     *\n     * ```\n     * import { assert } from \"@cosmjs/utils\";\n     *\n     * const Coin = registry.lookupType(\"/cosmos.base.v1beta1.Coin\");\n     * assert(Coin); // Ensures not unset\n     * assert(isTsProtoGeneratedType(Coin)); // Ensures this is the type we expect\n     *\n     * // Coin is typed TsProtoGeneratedType now.\n     * ```\n     */\n\n  }, {\n    key: \"lookupType\",\n    value: function lookupType(typeUrl) {\n      return this.types.get(typeUrl);\n    }\n  }, {\n    key: \"lookupTypeWithError\",\n    value: function lookupTypeWithError(typeUrl) {\n      var type = this.lookupType(typeUrl);\n\n      if (!type) {\n        throw new Error(\"Unregistered type url: \".concat(typeUrl));\n      }\n\n      return type;\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(encodeObject) {\n      var value = encodeObject.value,\n          typeUrl = encodeObject.typeUrl;\n\n      if (isTxBodyEncodeObject(encodeObject)) {\n        return this.encodeTxBody(value);\n      }\n\n      var type = this.lookupTypeWithError(typeUrl);\n      var instance = isTsProtoGeneratedType(type) ? type.fromPartial(value) : type.create(value);\n      return type.encode(instance).finish();\n    }\n  }, {\n    key: \"encodeTxBody\",\n    value: function encodeTxBody(txBodyFields) {\n      var _this = this;\n\n      var wrappedMessages = txBodyFields.messages.map(function (message) {\n        var messageBytes = _this.encode(message);\n\n        return any_1.Any.fromPartial({\n          typeUrl: message.typeUrl,\n          value: messageBytes\n        });\n      });\n      var txBody = tx_2.TxBody.fromPartial(Object.assign(Object.assign({}, txBodyFields), {\n        messages: wrappedMessages\n      }));\n      return tx_2.TxBody.encode(txBody).finish();\n    }\n  }, {\n    key: \"decode\",\n    value: function decode(_ref) {\n      var typeUrl = _ref.typeUrl,\n          value = _ref.value;\n\n      if (typeUrl === defaultTypeUrls.cosmosTxBody) {\n        return this.decodeTxBody(value);\n      }\n\n      var type = this.lookupTypeWithError(typeUrl);\n      var decoded = type.decode(value);\n      Object.entries(decoded).forEach(function (_ref2) {\n        var _ref3 = _slicedToArray(_ref2, 2),\n            key = _ref3[0],\n            val = _ref3[1];\n\n        if (typeof Buffer !== \"undefined\" && typeof Buffer.isBuffer !== \"undefined\" && Buffer.isBuffer(val)) {\n          decoded[key] = Uint8Array.from(val);\n        }\n      });\n      return decoded;\n    }\n  }, {\n    key: \"decodeTxBody\",\n    value: function decodeTxBody(txBody) {\n      var _this2 = this;\n\n      var decodedTxBody = tx_2.TxBody.decode(txBody);\n      return Object.assign(Object.assign({}, decodedTxBody), {\n        messages: decodedTxBody.messages.map(function (_ref4) {\n          var typeUrl = _ref4.typeUrl,\n              value = _ref4.value;\n\n          if (!typeUrl) {\n            throw new Error(\"Missing type_url in Any\");\n          }\n\n          if (!value) {\n            throw new Error(\"Missing value in Any\");\n          }\n\n          return _this2.decode({\n            typeUrl: typeUrl,\n            value: value\n          });\n        })\n      });\n    }\n  }]);\n\n  return Registry;\n}();\n\nexports.Registry = Registry;","map":null,"metadata":{},"sourceType":"script"}