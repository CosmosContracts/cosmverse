{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningCosmWasmClient = exports.defaultGasLimits = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nconst amino_1 = require(\"@cosmjs/amino\");\n\nconst cosmwasm_launchpad_1 = require(\"@cosmjs/cosmwasm-launchpad\");\n\nconst crypto_1 = require(\"@cosmjs/crypto\");\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\n\nconst stargate_1 = require(\"@cosmjs/stargate\");\n\nconst tx_1 = require(\"@cosmjs/stargate/build/codec/cosmos/distribution/v1beta1/tx\");\n\nconst tx_2 = require(\"@cosmjs/stargate/build/codec/cosmos/staking/v1beta1/tx\");\n\nconst signing_1 = require(\"@cosmjs/stargate/build/codec/cosmos/tx/signing/v1beta1/signing\");\n\nconst tx_3 = require(\"@cosmjs/stargate/build/codec/cosmos/tx/v1beta1/tx\");\n\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst long_1 = __importDefault(require(\"long\"));\n\nconst pako_1 = __importDefault(require(\"pako\"));\n\nconst aminotypes_1 = require(\"./aminotypes\");\n\nconst tx_4 = require(\"./codec/cosmwasm/wasm/v1beta1/tx\");\n\nconst cosmwasmclient_1 = require(\"./cosmwasmclient\");\n\nfunction prepareBuilder(builder) {\n  if (builder === undefined) {\n    return \"\"; // normalization needed by backend\n  } else {\n    if (!cosmwasm_launchpad_1.isValidBuilder(builder)) throw new Error(\"The builder (Docker Hub image with tag) is not valid\");\n    return builder;\n  }\n}\n\nexports.defaultGasLimits = Object.assign(Object.assign({}, stargate_1.defaultGasLimits), {\n  upload: 1500000,\n  init: 500000,\n  migrate: 200000,\n  exec: 200000,\n  changeAdmin: 80000\n});\n\nfunction createBroadcastTxErrorMessage(result) {\n  return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;\n}\n\nfunction createDefaultRegistry() {\n  return new proto_signing_1.Registry([...stargate_1.defaultRegistryTypes, [\"/cosmwasm.wasm.v1beta1.MsgClearAdmin\", tx_4.MsgClearAdmin], [\"/cosmwasm.wasm.v1beta1.MsgExecuteContract\", tx_4.MsgExecuteContract], [\"/cosmwasm.wasm.v1beta1.MsgMigrateContract\", tx_4.MsgMigrateContract], [\"/cosmwasm.wasm.v1beta1.MsgStoreCode\", tx_4.MsgStoreCode], [\"/cosmwasm.wasm.v1beta1.MsgInstantiateContract\", tx_4.MsgInstantiateContract], [\"/cosmwasm.wasm.v1beta1.MsgUpdateAdmin\", tx_4.MsgUpdateAdmin]]);\n}\n\nclass SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {\n  constructor(tmClient, signer, options) {\n    super(tmClient);\n    const {\n      registry = createDefaultRegistry(),\n      aminoTypes = new stargate_1.AminoTypes({\n        additions: aminotypes_1.cosmWasmTypes,\n        prefix: options.prefix\n      }),\n      gasPrice = stargate_1.defaultGasPrice,\n      gasLimits = {}\n    } = options;\n    this.fees = stargate_1.buildFeeTable(gasPrice, exports.defaultGasLimits, gasLimits);\n    this.registry = registry;\n    this.aminoTypes = aminoTypes;\n    this.signer = signer;\n    this.broadcastTimeoutMs = options.broadcastTimeoutMs;\n    this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;\n  }\n\n  static async connectWithSigner(endpoint, signer) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n    return new SigningCosmWasmClient(tmClient, signer, options);\n  }\n  /**\n   * Creates a client in offline mode.\n   *\n   * This should only be used in niche cases where you know exactly what you're doing,\n   * e.g. when building an offline signing application.\n   *\n   * When you try to use online functionality with such a signer, an\n   * exception will be raised.\n   */\n\n\n  static async offline(signer) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return new SigningCosmWasmClient(undefined, signer, options);\n  }\n  /** Uploads code and returns a receipt, including the code ID */\n\n\n  async upload(senderAddress, wasmCode) {\n    let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    const source = meta.source || \"\";\n    const builder = prepareBuilder(meta.builder);\n    const compressed = pako_1.default.gzip(wasmCode, {\n      level: 9\n    });\n    const storeCodeMsg = {\n      typeUrl: \"/cosmwasm.wasm.v1beta1.MsgStoreCode\",\n      value: tx_4.MsgStoreCode.fromPartial({\n        sender: senderAddress,\n        wasmByteCode: compressed,\n        source: source,\n        builder: builder\n      })\n    };\n    const result = await this.signAndBroadcast(senderAddress, [storeCodeMsg], this.fees.upload, memo);\n\n    if (stargate_1.isBroadcastTxFailure(result)) {\n      throw new Error(createBroadcastTxErrorMessage(result));\n    }\n\n    const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);\n    const codeIdAttr = stargate_1.logs.findAttribute(parsedLogs, \"message\", \"code_id\");\n    return {\n      originalSize: wasmCode.length,\n      originalChecksum: encoding_1.toHex(crypto_1.sha256(wasmCode)),\n      compressedSize: compressed.length,\n      compressedChecksum: encoding_1.toHex(crypto_1.sha256(compressed)),\n      codeId: Number.parseInt(codeIdAttr.value, 10),\n      logs: parsedLogs,\n      transactionHash: result.transactionHash\n    };\n  }\n\n  async instantiate(senderAddress, codeId, msg, label) {\n    let options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    const instantiateContractMsg = {\n      typeUrl: \"/cosmwasm.wasm.v1beta1.MsgInstantiateContract\",\n      value: tx_4.MsgInstantiateContract.fromPartial({\n        sender: senderAddress,\n        codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),\n        label: label,\n        initMsg: encoding_1.toUtf8(JSON.stringify(msg)),\n        funds: [...(options.transferAmount || [])],\n        admin: options.admin\n      })\n    };\n    const result = await this.signAndBroadcast(senderAddress, [instantiateContractMsg], this.fees.init, options.memo);\n\n    if (stargate_1.isBroadcastTxFailure(result)) {\n      throw new Error(createBroadcastTxErrorMessage(result));\n    }\n\n    const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);\n    const contractAddressAttr = stargate_1.logs.findAttribute(parsedLogs, \"message\", \"contract_address\");\n    return {\n      contractAddress: contractAddressAttr.value,\n      logs: parsedLogs,\n      transactionHash: result.transactionHash\n    };\n  }\n\n  async updateAdmin(senderAddress, contractAddress, newAdmin) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    const updateAdminMsg = {\n      typeUrl: \"/cosmwasm.wasm.v1beta1.MsgUpdateAdmin\",\n      value: tx_4.MsgUpdateAdmin.fromPartial({\n        sender: senderAddress,\n        contract: contractAddress,\n        newAdmin: newAdmin\n      })\n    };\n    const result = await this.signAndBroadcast(senderAddress, [updateAdminMsg], this.fees.changeAdmin, memo);\n\n    if (stargate_1.isBroadcastTxFailure(result)) {\n      throw new Error(createBroadcastTxErrorMessage(result));\n    }\n\n    return {\n      logs: stargate_1.logs.parseRawLog(result.rawLog),\n      transactionHash: result.transactionHash\n    };\n  }\n\n  async clearAdmin(senderAddress, contractAddress) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const clearAdminMsg = {\n      typeUrl: \"/cosmwasm.wasm.v1beta1.MsgClearAdmin\",\n      value: tx_4.MsgClearAdmin.fromPartial({\n        sender: senderAddress,\n        contract: contractAddress\n      })\n    };\n    const result = await this.signAndBroadcast(senderAddress, [clearAdminMsg], this.fees.changeAdmin, memo);\n\n    if (stargate_1.isBroadcastTxFailure(result)) {\n      throw new Error(createBroadcastTxErrorMessage(result));\n    }\n\n    return {\n      logs: stargate_1.logs.parseRawLog(result.rawLog),\n      transactionHash: result.transactionHash\n    };\n  }\n\n  async migrate(senderAddress, contractAddress, codeId, migrateMsg) {\n    let memo = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"\";\n    const migrateContractMsg = {\n      typeUrl: \"/cosmwasm.wasm.v1beta1.MsgMigrateContract\",\n      value: tx_4.MsgMigrateContract.fromPartial({\n        sender: senderAddress,\n        contract: contractAddress,\n        codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),\n        migrateMsg: encoding_1.toUtf8(JSON.stringify(migrateMsg))\n      })\n    };\n    const result = await this.signAndBroadcast(senderAddress, [migrateContractMsg], this.fees.migrate, memo);\n\n    if (stargate_1.isBroadcastTxFailure(result)) {\n      throw new Error(createBroadcastTxErrorMessage(result));\n    }\n\n    return {\n      logs: stargate_1.logs.parseRawLog(result.rawLog),\n      transactionHash: result.transactionHash\n    };\n  }\n\n  async execute(senderAddress, contractAddress, msg) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    let funds = arguments.length > 4 ? arguments[4] : undefined;\n    const executeContractMsg = {\n      typeUrl: \"/cosmwasm.wasm.v1beta1.MsgExecuteContract\",\n      value: tx_4.MsgExecuteContract.fromPartial({\n        sender: senderAddress,\n        contract: contractAddress,\n        msg: encoding_1.toUtf8(JSON.stringify(msg)),\n        funds: [...(funds || [])]\n      })\n    };\n    const result = await this.signAndBroadcast(senderAddress, [executeContractMsg], this.fees.exec, memo);\n\n    if (stargate_1.isBroadcastTxFailure(result)) {\n      throw new Error(createBroadcastTxErrorMessage(result));\n    }\n\n    return {\n      logs: stargate_1.logs.parseRawLog(result.rawLog),\n      transactionHash: result.transactionHash\n    };\n  }\n\n  async sendTokens(senderAddress, recipientAddress, amount) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    const sendMsg = {\n      typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n      value: {\n        fromAddress: senderAddress,\n        toAddress: recipientAddress,\n        amount: [...amount]\n      }\n    };\n    return this.signAndBroadcast(senderAddress, [sendMsg], this.fees.send, memo);\n  }\n\n  async delegateTokens(delegatorAddress, validatorAddress, amount) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    const delegateMsg = {\n      typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n      value: tx_2.MsgDelegate.fromPartial({\n        delegatorAddress: delegatorAddress,\n        validatorAddress,\n        amount\n      })\n    };\n    return this.signAndBroadcast(delegatorAddress, [delegateMsg], this.fees.delegate, memo);\n  }\n\n  async undelegateTokens(delegatorAddress, validatorAddress, amount) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    const undelegateMsg = {\n      typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n      value: tx_2.MsgUndelegate.fromPartial({\n        delegatorAddress: delegatorAddress,\n        validatorAddress,\n        amount\n      })\n    };\n    return this.signAndBroadcast(delegatorAddress, [undelegateMsg], this.fees.undelegate, memo);\n  }\n\n  async withdrawRewards(delegatorAddress, validatorAddress) {\n    let memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"\";\n    const withdrawDelegatorRewardMsg = {\n      typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n      value: tx_1.MsgWithdrawDelegatorReward.fromPartial({\n        delegatorAddress: delegatorAddress,\n        validatorAddress\n      })\n    };\n    return this.signAndBroadcast(delegatorAddress, [withdrawDelegatorRewardMsg], this.fees.withdraw, memo);\n  }\n  /**\n   * Creates a transaction with the given messages, fee and memo. Then signs and broadcasts the transaction.\n   *\n   * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.\n   * @param messages\n   * @param fee\n   * @param memo\n   */\n\n\n  async signAndBroadcast(signerAddress, messages, fee) {\n    let memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    const txRaw = await this.sign(signerAddress, messages, fee, memo);\n    const txBytes = tx_3.TxRaw.encode(txRaw).finish();\n    return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);\n  }\n\n  async sign(signerAddress, messages, fee, memo, explicitSignerData) {\n    let signerData;\n\n    if (explicitSignerData) {\n      signerData = explicitSignerData;\n    } else {\n      const {\n        accountNumber,\n        sequence\n      } = await this.getSequence(signerAddress);\n      const chainId = await this.getChainId();\n      signerData = {\n        accountNumber: accountNumber,\n        sequence: sequence,\n        chainId: chainId\n      };\n    }\n\n    return proto_signing_1.isOfflineDirectSigner(this.signer) ? this.signDirect(signerAddress, messages, fee, memo, signerData) : this.signAmino(signerAddress, messages, fee, memo, signerData);\n  }\n\n  async signAmino(signerAddress, messages, fee, memo, _ref) {\n    let {\n      accountNumber,\n      sequence,\n      chainId\n    } = _ref;\n    utils_1.assert(!proto_signing_1.isOfflineDirectSigner(this.signer));\n    const accountFromSigner = (await this.signer.getAccounts()).find(account => account.address === signerAddress);\n\n    if (!accountFromSigner) {\n      throw new Error(\"Failed to retrieve account from signer\");\n    }\n\n    const pubkey = proto_signing_1.encodePubkey(amino_1.encodeSecp256k1Pubkey(accountFromSigner.pubkey));\n    const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n    const msgs = messages.map(msg => this.aminoTypes.toAmino(msg));\n    const signDoc = amino_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);\n    const {\n      signature,\n      signed\n    } = await this.signer.signAmino(signerAddress, signDoc);\n    const signedTxBody = {\n      typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n      value: {\n        messages: signed.msgs.map(msg => this.aminoTypes.fromAmino(msg)),\n        memo: signed.memo\n      }\n    };\n    const signedTxBodyBytes = this.registry.encode(signedTxBody);\n    const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();\n    const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();\n    const signedAuthInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkey], signed.fee.amount, signedGasLimit, signedSequence, signMode);\n    return tx_3.TxRaw.fromPartial({\n      bodyBytes: signedTxBodyBytes,\n      authInfoBytes: signedAuthInfoBytes,\n      signatures: [encoding_1.fromBase64(signature.signature)]\n    });\n  }\n\n  async signDirect(signerAddress, messages, fee, memo, _ref2) {\n    let {\n      accountNumber,\n      sequence,\n      chainId\n    } = _ref2;\n    utils_1.assert(proto_signing_1.isOfflineDirectSigner(this.signer));\n    const accountFromSigner = (await this.signer.getAccounts()).find(account => account.address === signerAddress);\n\n    if (!accountFromSigner) {\n      throw new Error(\"Failed to retrieve account from signer\");\n    }\n\n    const pubkey = proto_signing_1.encodePubkey(amino_1.encodeSecp256k1Pubkey(accountFromSigner.pubkey));\n    const txBody = {\n      typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n      value: {\n        messages: messages,\n        memo: memo\n      }\n    };\n    const txBodyBytes = this.registry.encode(txBody);\n    const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();\n    const authInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkey], fee.amount, gasLimit, sequence);\n    const signDoc = proto_signing_1.makeSignDoc(txBodyBytes, authInfoBytes, chainId, accountNumber);\n    const {\n      signature,\n      signed\n    } = await this.signer.signDirect(signerAddress, signDoc);\n    return tx_3.TxRaw.fromPartial({\n      bodyBytes: signed.bodyBytes,\n      authInfoBytes: signed.authInfoBytes,\n      signatures: [encoding_1.fromBase64(signature.signature)]\n    });\n  }\n\n}\n\nexports.SigningCosmWasmClient = SigningCosmWasmClient;","map":{"version":3,"sources":["../src/signingcosmwasmclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigningCosmWasmClient = exports.defaultGasLimits = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\nconst amino_1 = require(\"@cosmjs/amino\");\nconst cosmwasm_launchpad_1 = require(\"@cosmjs/cosmwasm-launchpad\");\nconst crypto_1 = require(\"@cosmjs/crypto\");\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst proto_signing_1 = require(\"@cosmjs/proto-signing\");\nconst stargate_1 = require(\"@cosmjs/stargate\");\nconst tx_1 = require(\"@cosmjs/stargate/build/codec/cosmos/distribution/v1beta1/tx\");\nconst tx_2 = require(\"@cosmjs/stargate/build/codec/cosmos/staking/v1beta1/tx\");\nconst signing_1 = require(\"@cosmjs/stargate/build/codec/cosmos/tx/signing/v1beta1/signing\");\nconst tx_3 = require(\"@cosmjs/stargate/build/codec/cosmos/tx/v1beta1/tx\");\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst long_1 = __importDefault(require(\"long\"));\nconst pako_1 = __importDefault(require(\"pako\"));\nconst aminotypes_1 = require(\"./aminotypes\");\nconst tx_4 = require(\"./codec/cosmwasm/wasm/v1beta1/tx\");\nconst cosmwasmclient_1 = require(\"./cosmwasmclient\");\nfunction prepareBuilder(builder) {\n    if (builder === undefined) {\n        return \"\"; // normalization needed by backend\n    }\n    else {\n        if (!cosmwasm_launchpad_1.isValidBuilder(builder))\n            throw new Error(\"The builder (Docker Hub image with tag) is not valid\");\n        return builder;\n    }\n}\nexports.defaultGasLimits = Object.assign(Object.assign({}, stargate_1.defaultGasLimits), { upload: 1500000, init: 500000, migrate: 200000, exec: 200000, changeAdmin: 80000 });\nfunction createBroadcastTxErrorMessage(result) {\n    return `Error when broadcasting tx ${result.transactionHash} at height ${result.height}. Code: ${result.code}; Raw log: ${result.rawLog}`;\n}\nfunction createDefaultRegistry() {\n    return new proto_signing_1.Registry([\n        ...stargate_1.defaultRegistryTypes,\n        [\"/cosmwasm.wasm.v1beta1.MsgClearAdmin\", tx_4.MsgClearAdmin],\n        [\"/cosmwasm.wasm.v1beta1.MsgExecuteContract\", tx_4.MsgExecuteContract],\n        [\"/cosmwasm.wasm.v1beta1.MsgMigrateContract\", tx_4.MsgMigrateContract],\n        [\"/cosmwasm.wasm.v1beta1.MsgStoreCode\", tx_4.MsgStoreCode],\n        [\"/cosmwasm.wasm.v1beta1.MsgInstantiateContract\", tx_4.MsgInstantiateContract],\n        [\"/cosmwasm.wasm.v1beta1.MsgUpdateAdmin\", tx_4.MsgUpdateAdmin],\n    ]);\n}\nclass SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {\n    constructor(tmClient, signer, options) {\n        super(tmClient);\n        const { registry = createDefaultRegistry(), aminoTypes = new stargate_1.AminoTypes({ additions: aminotypes_1.cosmWasmTypes, prefix: options.prefix }), gasPrice = stargate_1.defaultGasPrice, gasLimits = {}, } = options;\n        this.fees = stargate_1.buildFeeTable(gasPrice, exports.defaultGasLimits, gasLimits);\n        this.registry = registry;\n        this.aminoTypes = aminoTypes;\n        this.signer = signer;\n        this.broadcastTimeoutMs = options.broadcastTimeoutMs;\n        this.broadcastPollIntervalMs = options.broadcastPollIntervalMs;\n    }\n    static async connectWithSigner(endpoint, signer, options = {}) {\n        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n        return new SigningCosmWasmClient(tmClient, signer, options);\n    }\n    /**\n     * Creates a client in offline mode.\n     *\n     * This should only be used in niche cases where you know exactly what you're doing,\n     * e.g. when building an offline signing application.\n     *\n     * When you try to use online functionality with such a signer, an\n     * exception will be raised.\n     */\n    static async offline(signer, options = {}) {\n        return new SigningCosmWasmClient(undefined, signer, options);\n    }\n    /** Uploads code and returns a receipt, including the code ID */\n    async upload(senderAddress, wasmCode, meta = {}, memo = \"\") {\n        const source = meta.source || \"\";\n        const builder = prepareBuilder(meta.builder);\n        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });\n        const storeCodeMsg = {\n            typeUrl: \"/cosmwasm.wasm.v1beta1.MsgStoreCode\",\n            value: tx_4.MsgStoreCode.fromPartial({\n                sender: senderAddress,\n                wasmByteCode: compressed,\n                source: source,\n                builder: builder,\n            }),\n        };\n        const result = await this.signAndBroadcast(senderAddress, [storeCodeMsg], this.fees.upload, memo);\n        if (stargate_1.isBroadcastTxFailure(result)) {\n            throw new Error(createBroadcastTxErrorMessage(result));\n        }\n        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);\n        const codeIdAttr = stargate_1.logs.findAttribute(parsedLogs, \"message\", \"code_id\");\n        return {\n            originalSize: wasmCode.length,\n            originalChecksum: encoding_1.toHex(crypto_1.sha256(wasmCode)),\n            compressedSize: compressed.length,\n            compressedChecksum: encoding_1.toHex(crypto_1.sha256(compressed)),\n            codeId: Number.parseInt(codeIdAttr.value, 10),\n            logs: parsedLogs,\n            transactionHash: result.transactionHash,\n        };\n    }\n    async instantiate(senderAddress, codeId, msg, label, options = {}) {\n        const instantiateContractMsg = {\n            typeUrl: \"/cosmwasm.wasm.v1beta1.MsgInstantiateContract\",\n            value: tx_4.MsgInstantiateContract.fromPartial({\n                sender: senderAddress,\n                codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),\n                label: label,\n                initMsg: encoding_1.toUtf8(JSON.stringify(msg)),\n                funds: [...(options.transferAmount || [])],\n                admin: options.admin,\n            }),\n        };\n        const result = await this.signAndBroadcast(senderAddress, [instantiateContractMsg], this.fees.init, options.memo);\n        if (stargate_1.isBroadcastTxFailure(result)) {\n            throw new Error(createBroadcastTxErrorMessage(result));\n        }\n        const parsedLogs = stargate_1.logs.parseRawLog(result.rawLog);\n        const contractAddressAttr = stargate_1.logs.findAttribute(parsedLogs, \"message\", \"contract_address\");\n        return {\n            contractAddress: contractAddressAttr.value,\n            logs: parsedLogs,\n            transactionHash: result.transactionHash,\n        };\n    }\n    async updateAdmin(senderAddress, contractAddress, newAdmin, memo = \"\") {\n        const updateAdminMsg = {\n            typeUrl: \"/cosmwasm.wasm.v1beta1.MsgUpdateAdmin\",\n            value: tx_4.MsgUpdateAdmin.fromPartial({\n                sender: senderAddress,\n                contract: contractAddress,\n                newAdmin: newAdmin,\n            }),\n        };\n        const result = await this.signAndBroadcast(senderAddress, [updateAdminMsg], this.fees.changeAdmin, memo);\n        if (stargate_1.isBroadcastTxFailure(result)) {\n            throw new Error(createBroadcastTxErrorMessage(result));\n        }\n        return {\n            logs: stargate_1.logs.parseRawLog(result.rawLog),\n            transactionHash: result.transactionHash,\n        };\n    }\n    async clearAdmin(senderAddress, contractAddress, memo = \"\") {\n        const clearAdminMsg = {\n            typeUrl: \"/cosmwasm.wasm.v1beta1.MsgClearAdmin\",\n            value: tx_4.MsgClearAdmin.fromPartial({\n                sender: senderAddress,\n                contract: contractAddress,\n            }),\n        };\n        const result = await this.signAndBroadcast(senderAddress, [clearAdminMsg], this.fees.changeAdmin, memo);\n        if (stargate_1.isBroadcastTxFailure(result)) {\n            throw new Error(createBroadcastTxErrorMessage(result));\n        }\n        return {\n            logs: stargate_1.logs.parseRawLog(result.rawLog),\n            transactionHash: result.transactionHash,\n        };\n    }\n    async migrate(senderAddress, contractAddress, codeId, migrateMsg, memo = \"\") {\n        const migrateContractMsg = {\n            typeUrl: \"/cosmwasm.wasm.v1beta1.MsgMigrateContract\",\n            value: tx_4.MsgMigrateContract.fromPartial({\n                sender: senderAddress,\n                contract: contractAddress,\n                codeId: long_1.default.fromString(new math_1.Uint53(codeId).toString()),\n                migrateMsg: encoding_1.toUtf8(JSON.stringify(migrateMsg)),\n            }),\n        };\n        const result = await this.signAndBroadcast(senderAddress, [migrateContractMsg], this.fees.migrate, memo);\n        if (stargate_1.isBroadcastTxFailure(result)) {\n            throw new Error(createBroadcastTxErrorMessage(result));\n        }\n        return {\n            logs: stargate_1.logs.parseRawLog(result.rawLog),\n            transactionHash: result.transactionHash,\n        };\n    }\n    async execute(senderAddress, contractAddress, msg, memo = \"\", funds) {\n        const executeContractMsg = {\n            typeUrl: \"/cosmwasm.wasm.v1beta1.MsgExecuteContract\",\n            value: tx_4.MsgExecuteContract.fromPartial({\n                sender: senderAddress,\n                contract: contractAddress,\n                msg: encoding_1.toUtf8(JSON.stringify(msg)),\n                funds: [...(funds || [])],\n            }),\n        };\n        const result = await this.signAndBroadcast(senderAddress, [executeContractMsg], this.fees.exec, memo);\n        if (stargate_1.isBroadcastTxFailure(result)) {\n            throw new Error(createBroadcastTxErrorMessage(result));\n        }\n        return {\n            logs: stargate_1.logs.parseRawLog(result.rawLog),\n            transactionHash: result.transactionHash,\n        };\n    }\n    async sendTokens(senderAddress, recipientAddress, amount, memo = \"\") {\n        const sendMsg = {\n            typeUrl: \"/cosmos.bank.v1beta1.MsgSend\",\n            value: {\n                fromAddress: senderAddress,\n                toAddress: recipientAddress,\n                amount: [...amount],\n            },\n        };\n        return this.signAndBroadcast(senderAddress, [sendMsg], this.fees.send, memo);\n    }\n    async delegateTokens(delegatorAddress, validatorAddress, amount, memo = \"\") {\n        const delegateMsg = {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgDelegate\",\n            value: tx_2.MsgDelegate.fromPartial({ delegatorAddress: delegatorAddress, validatorAddress, amount }),\n        };\n        return this.signAndBroadcast(delegatorAddress, [delegateMsg], this.fees.delegate, memo);\n    }\n    async undelegateTokens(delegatorAddress, validatorAddress, amount, memo = \"\") {\n        const undelegateMsg = {\n            typeUrl: \"/cosmos.staking.v1beta1.MsgUndelegate\",\n            value: tx_2.MsgUndelegate.fromPartial({ delegatorAddress: delegatorAddress, validatorAddress, amount }),\n        };\n        return this.signAndBroadcast(delegatorAddress, [undelegateMsg], this.fees.undelegate, memo);\n    }\n    async withdrawRewards(delegatorAddress, validatorAddress, memo = \"\") {\n        const withdrawDelegatorRewardMsg = {\n            typeUrl: \"/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward\",\n            value: tx_1.MsgWithdrawDelegatorReward.fromPartial({ delegatorAddress: delegatorAddress, validatorAddress }),\n        };\n        return this.signAndBroadcast(delegatorAddress, [withdrawDelegatorRewardMsg], this.fees.withdraw, memo);\n    }\n    /**\n     * Creates a transaction with the given messages, fee and memo. Then signs and broadcasts the transaction.\n     *\n     * @param signerAddress The address that will sign transactions using this instance. The signer must be able to sign with this address.\n     * @param messages\n     * @param fee\n     * @param memo\n     */\n    async signAndBroadcast(signerAddress, messages, fee, memo = \"\") {\n        const txRaw = await this.sign(signerAddress, messages, fee, memo);\n        const txBytes = tx_3.TxRaw.encode(txRaw).finish();\n        return this.broadcastTx(txBytes, this.broadcastTimeoutMs, this.broadcastPollIntervalMs);\n    }\n    async sign(signerAddress, messages, fee, memo, explicitSignerData) {\n        let signerData;\n        if (explicitSignerData) {\n            signerData = explicitSignerData;\n        }\n        else {\n            const { accountNumber, sequence } = await this.getSequence(signerAddress);\n            const chainId = await this.getChainId();\n            signerData = {\n                accountNumber: accountNumber,\n                sequence: sequence,\n                chainId: chainId,\n            };\n        }\n        return proto_signing_1.isOfflineDirectSigner(this.signer)\n            ? this.signDirect(signerAddress, messages, fee, memo, signerData)\n            : this.signAmino(signerAddress, messages, fee, memo, signerData);\n    }\n    async signAmino(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {\n        utils_1.assert(!proto_signing_1.isOfflineDirectSigner(this.signer));\n        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);\n        if (!accountFromSigner) {\n            throw new Error(\"Failed to retrieve account from signer\");\n        }\n        const pubkey = proto_signing_1.encodePubkey(amino_1.encodeSecp256k1Pubkey(accountFromSigner.pubkey));\n        const signMode = signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON;\n        const msgs = messages.map((msg) => this.aminoTypes.toAmino(msg));\n        const signDoc = amino_1.makeSignDoc(msgs, fee, chainId, memo, accountNumber, sequence);\n        const { signature, signed } = await this.signer.signAmino(signerAddress, signDoc);\n        const signedTxBody = {\n            typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n            value: {\n                messages: signed.msgs.map((msg) => this.aminoTypes.fromAmino(msg)),\n                memo: signed.memo,\n            },\n        };\n        const signedTxBodyBytes = this.registry.encode(signedTxBody);\n        const signedGasLimit = math_1.Int53.fromString(signed.fee.gas).toNumber();\n        const signedSequence = math_1.Int53.fromString(signed.sequence).toNumber();\n        const signedAuthInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkey], signed.fee.amount, signedGasLimit, signedSequence, signMode);\n        return tx_3.TxRaw.fromPartial({\n            bodyBytes: signedTxBodyBytes,\n            authInfoBytes: signedAuthInfoBytes,\n            signatures: [encoding_1.fromBase64(signature.signature)],\n        });\n    }\n    async signDirect(signerAddress, messages, fee, memo, { accountNumber, sequence, chainId }) {\n        utils_1.assert(proto_signing_1.isOfflineDirectSigner(this.signer));\n        const accountFromSigner = (await this.signer.getAccounts()).find((account) => account.address === signerAddress);\n        if (!accountFromSigner) {\n            throw new Error(\"Failed to retrieve account from signer\");\n        }\n        const pubkey = proto_signing_1.encodePubkey(amino_1.encodeSecp256k1Pubkey(accountFromSigner.pubkey));\n        const txBody = {\n            typeUrl: \"/cosmos.tx.v1beta1.TxBody\",\n            value: {\n                messages: messages,\n                memo: memo,\n            },\n        };\n        const txBodyBytes = this.registry.encode(txBody);\n        const gasLimit = math_1.Int53.fromString(fee.gas).toNumber();\n        const authInfoBytes = proto_signing_1.makeAuthInfoBytes([pubkey], fee.amount, gasLimit, sequence);\n        const signDoc = proto_signing_1.makeSignDoc(txBodyBytes, authInfoBytes, chainId, accountNumber);\n        const { signature, signed } = await this.signer.signDirect(signerAddress, signDoc);\n        return tx_3.TxRaw.fromPartial({\n            bodyBytes: signed.bodyBytes,\n            authInfoBytes: signed.authInfoBytes,\n            signatures: [encoding_1.fromBase64(signature.signature)],\n        });\n    }\n}\nexports.SigningCosmWasmClient = SigningCosmWasmClient;\n//# sourceMappingURL=signingcosmwasmclient.js.map"]},"metadata":{},"sourceType":"script"}