{"ast":null,"code":"\"use strict\";\n\nvar util = exports; // used to return a Promise where callback is omitted\n\nutil.asPromise = require(\"@protobufjs/aspromise\"); // converts to / from base64 encoded strings\n\nutil.base64 = require(\"@protobufjs/base64\"); // base class of rpc.Service\n\nutil.EventEmitter = require(\"@protobufjs/eventemitter\"); // float handling accross browsers\n\nutil.float = require(\"@protobufjs/float\"); // requires modules optionally and hides the call from bundlers\n\nutil.inquire = require(\"@protobufjs/inquire\"); // converts to / from utf8 encoded strings\n\nutil.utf8 = require(\"@protobufjs/utf8\"); // provides a node-like buffer pool in the browser\n\nutil.pool = require(\"@protobufjs/pool\"); // utility to work with the low and high bits of a 64 bit value\n\nutil.LongBits = require(\"./longbits\");\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\n\nutil.isNode = Boolean(typeof global !== \"undefined\" && global && global.process && global.process.versions && global.process.versions.node);\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\n\nutil.global = util.isNode && global || typeof window !== \"undefined\" && window || typeof self !== \"undefined\" && self || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\n\nutil.emptyArray = Object.freeze ? Object.freeze([]) :\n/* istanbul ignore next */\n[]; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\n\nutil.emptyObject = Object.freeze ? Object.freeze({}) :\n/* istanbul ignore next */\n{}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\n\nutil.isInteger = Number.isInteger ||\n/* istanbul ignore next */\nfunction isInteger(value) {\n  return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\n\n\nutil.isString = function isString(value) {\n  return typeof value === \"string\" || value instanceof String;\n};\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\n\n\nutil.isObject = function isObject(value) {\n  return value && typeof value === \"object\";\n};\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\n\n\nutil.isset =\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n  var value = obj[prop];\n  if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n    return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n  return false;\n};\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\n\n\nutil.Buffer = function () {\n  try {\n    var Buffer = util.inquire(\"buffer\").Buffer; // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n\n    return Buffer.prototype.utf8Write ? Buffer :\n    /* istanbul ignore next */\n    null;\n  } catch (e) {\n    /* istanbul ignore next */\n    return null;\n  }\n}(); // Internal alias of or polyfull for Buffer.from.\n\n\nutil._Buffer_from = null; // Internal alias of or polyfill for Buffer.allocUnsafe.\n\nutil._Buffer_allocUnsafe = null;\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\n\nutil.newBuffer = function newBuffer(sizeOrArray) {\n  /* istanbul ignore next */\n  return typeof sizeOrArray === \"number\" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === \"undefined\" ? sizeOrArray : new Uint8Array(sizeOrArray);\n};\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\n\n\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array\n/* istanbul ignore next */\n: Array;\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\n\nutil.Long =\n/* istanbul ignore next */\nutil.global.dcodeIO &&\n/* istanbul ignore next */\nutil.global.dcodeIO.Long ||\n/* istanbul ignore next */\nutil.global.Long || util.inquire(\"long\");\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\n\nutil.key2Re = /^true|false|0|1$/;\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\n\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\n\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\n\nutil.longToHash = function longToHash(value) {\n  return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;\n};\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\n\n\nutil.longFromHash = function longFromHash(hash, unsigned) {\n  var bits = util.LongBits.fromHash(hash);\n  if (util.Long) return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n  return bits.toNumber(Boolean(unsigned));\n};\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\n\n\nfunction merge(dst, src, ifNotSet) {\n  // used by converters\n  for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) if (dst[keys[i]] === undefined || !ifNotSet) dst[keys[i]] = src[keys[i]];\n\n  return dst;\n}\n\nutil.merge = merge;\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\n\nutil.lcFirst = function lcFirst(str) {\n  return str.charAt(0).toLowerCase() + str.substring(1);\n};\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\n\n\nfunction newError(name) {\n  function CustomError(message, properties) {\n    if (!(this instanceof CustomError)) return new CustomError(message, properties); // Error.call(this, message);\n    // ^ just returns a new error instance because the ctor can be called as a function\n\n    Object.defineProperty(this, \"message\", {\n      get: function () {\n        return message;\n      }\n    });\n    /* istanbul ignore next */\n\n    if (Error.captureStackTrace) // node\n      Error.captureStackTrace(this, CustomError);else Object.defineProperty(this, \"stack\", {\n      value: new Error().stack || \"\"\n    });\n    if (properties) merge(this, properties);\n  }\n\n  (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n  Object.defineProperty(CustomError.prototype, \"name\", {\n    get: function () {\n      return name;\n    }\n  });\n\n  CustomError.prototype.toString = function toString() {\n    return this.name + \": \" + this.message;\n  };\n\n  return CustomError;\n}\n\nutil.newError = newError;\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\n\nutil.ProtocolError = newError(\"ProtocolError\");\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\n\nutil.oneOfGetter = function getOneOf(fieldNames) {\n  var fieldMap = {};\n\n  for (var i = 0; i < fieldNames.length; ++i) fieldMap[fieldNames[i]] = 1;\n  /**\n   * @returns {string|undefined} Set field name, if any\n   * @this Object\n   * @ignore\n   */\n\n\n  return function () {\n    // eslint-disable-line consistent-return\n    for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i) if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null) return keys[i];\n  };\n};\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\n\n\nutil.oneOfSetter = function setOneOf(fieldNames) {\n  /**\n   * @param {string} name Field name\n   * @returns {undefined}\n   * @this Object\n   * @ignore\n   */\n  return function (name) {\n    for (var i = 0; i < fieldNames.length; ++i) if (fieldNames[i] !== name) delete this[fieldNames[i]];\n  };\n};\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\n\n\nutil.toJSONOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  json: true\n}; // Sets up buffer utility according to the environment (called in index-minimal)\n\nutil._configure = function () {\n  var Buffer = util.Buffer;\n  /* istanbul ignore if */\n\n  if (!Buffer) {\n    util._Buffer_from = util._Buffer_allocUnsafe = null;\n    return;\n  } // because node 4.x buffers are incompatible & immutable\n  // see: https://github.com/dcodeIO/protobuf.js/pull/665\n\n\n  util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n  /* istanbul ignore next */\n  function Buffer_from(value, encoding) {\n    return new Buffer(value, encoding);\n  };\n\n  util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n  /* istanbul ignore next */\n  function Buffer_allocUnsafe(size) {\n    return new Buffer(size);\n  };\n};","map":{"version":3,"sources":["/Users/pauloponciano/Documents/cosmverse/node_modules/@confio/ics23/node_modules/protobufjs/src/util/minimal.js"],"names":["util","exports","asPromise","require","base64","EventEmitter","float","inquire","utf8","pool","LongBits","isNode","Boolean","global","process","versions","node","window","self","emptyArray","Object","freeze","emptyObject","isInteger","Number","value","isFinite","Math","floor","isString","String","isObject","isset","isSet","obj","prop","hasOwnProperty","Array","isArray","length","keys","Buffer","prototype","utf8Write","e","_Buffer_from","_Buffer_allocUnsafe","newBuffer","sizeOrArray","Uint8Array","Long","dcodeIO","key2Re","key32Re","key64Re","longToHash","from","toHash","zeroHash","longFromHash","hash","unsigned","bits","fromHash","fromBits","lo","hi","toNumber","merge","dst","src","ifNotSet","i","undefined","lcFirst","str","charAt","toLowerCase","substring","newError","name","CustomError","message","properties","defineProperty","get","Error","captureStackTrace","stack","create","constructor","toString","ProtocolError","oneOfGetter","getOneOf","fieldNames","fieldMap","oneOfSetter","setOneOf","toJSONOptions","longs","enums","bytes","json","_configure","Buffer_from","encoding","allocUnsafe","Buffer_allocUnsafe","size"],"mappings":"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","sourcesContent":["\"use strict\";\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = require(\"@protobufjs/aspromise\");\n\n// converts to / from base64 encoded strings\nutil.base64 = require(\"@protobufjs/base64\");\n\n// base class of rpc.Service\nutil.EventEmitter = require(\"@protobufjs/eventemitter\");\n\n// float handling accross browsers\nutil.float = require(\"@protobufjs/float\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = require(\"@protobufjs/inquire\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = require(\"@protobufjs/utf8\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = require(\"@protobufjs/pool\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = require(\"./longbits\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n"]},"metadata":{},"sourceType":"script"}