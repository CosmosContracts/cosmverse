{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgClientImpl = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.protobufPackage = void 0;\n/* eslint-disable */\n\nconst long_1 = __importDefault(require(\"long\"));\n\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\n\nconst channel_1 = require(\"../../../../ibc/core/channel/v1/channel\");\n\nconst client_1 = require(\"../../../../ibc/core/client/v1/client\");\n\nexports.protobufPackage = \"ibc.core.channel.v1\";\nconst baseMsgChannelOpenInit = {\n  portId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenInit = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenInit);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromJSON(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromPartial(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgChannelOpenInitResponse = {};\nexports.MsgChannelOpenInitResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n    return message;\n  }\n\n};\nconst baseMsgChannelOpenTry = {\n  portId: \"\",\n  previousChannelId: \"\",\n  counterpartyVersion: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenTry = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.previousChannelId !== \"\") {\n      writer.uint32(18).string(message.previousChannelId);\n    }\n\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n\n    if (message.proofInit.length !== 0) {\n      writer.uint32(42).bytes(message.proofInit);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenTry);\n    message.proofInit = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.previousChannelId = reader.string();\n          break;\n\n        case 3:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n\n        case 5:\n          message.proofInit = reader.bytes();\n          break;\n\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenTry);\n    message.proofInit = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n      message.previousChannelId = String(object.previousChannelId);\n    } else {\n      message.previousChannelId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromJSON(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = String(object.counterpartyVersion);\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.previousChannelId !== undefined && (obj.previousChannelId = message.previousChannelId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenTry);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n      message.previousChannelId = object.previousChannelId;\n    } else {\n      message.previousChannelId = \"\";\n    }\n\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromPartial(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = object.counterpartyVersion;\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = object.proofInit;\n    } else {\n      message.proofInit = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgChannelOpenTryResponse = {};\nexports.MsgChannelOpenTryResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n    return message;\n  }\n\n};\nconst baseMsgChannelOpenAck = {\n  portId: \"\",\n  channelId: \"\",\n  counterpartyChannelId: \"\",\n  counterpartyVersion: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenAck = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.counterpartyChannelId !== \"\") {\n      writer.uint32(26).string(message.counterpartyChannelId);\n    }\n\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n\n    if (message.proofTry.length !== 0) {\n      writer.uint32(42).bytes(message.proofTry);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenAck);\n    message.proofTry = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.counterpartyChannelId = reader.string();\n          break;\n\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n\n        case 5:\n          message.proofTry = reader.bytes();\n          break;\n\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenAck);\n    message.proofTry = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n      message.counterpartyChannelId = String(object.counterpartyChannelId);\n    } else {\n      message.counterpartyChannelId = \"\";\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = String(object.counterpartyVersion);\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = bytesFromBase64(object.proofTry);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.counterpartyChannelId !== undefined && (obj.counterpartyChannelId = message.counterpartyChannelId);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofTry !== undefined && (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenAck);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n      message.counterpartyChannelId = object.counterpartyChannelId;\n    } else {\n      message.counterpartyChannelId = \"\";\n    }\n\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = object.counterpartyVersion;\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = object.proofTry;\n    } else {\n      message.proofTry = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgChannelOpenAckResponse = {};\nexports.MsgChannelOpenAckResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n    return message;\n  }\n\n};\nconst baseMsgChannelOpenConfirm = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenConfirm = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.proofAck.length !== 0) {\n      writer.uint32(26).bytes(message.proofAck);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.proofAck = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirm);\n    message.proofAck = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = bytesFromBase64(object.proofAck);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofAck !== undefined && (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirm);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = object.proofAck;\n    } else {\n      message.proofAck = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgChannelOpenConfirmResponse = {};\nexports.MsgChannelOpenConfirmResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n    return message;\n  }\n\n};\nconst baseMsgChannelCloseInit = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelCloseInit = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseInit);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelCloseInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelCloseInit);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgChannelCloseInitResponse = {};\nexports.MsgChannelCloseInitResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n    return message;\n  }\n\n};\nconst baseMsgChannelCloseConfirm = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelCloseConfirm = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n\n    if (message.proofInit.length !== 0) {\n      writer.uint32(26).bytes(message.proofInit);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseConfirm);\n    message.proofInit = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n\n        case 2:\n          message.channelId = reader.string();\n          break;\n\n        case 3:\n          message.proofInit = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirm);\n    message.proofInit = new Uint8Array();\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirm);\n\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = object.proofInit;\n    } else {\n      message.proofInit = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgChannelCloseConfirmResponse = {};\nexports.MsgChannelCloseConfirmResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n    return message;\n  }\n\n};\nconst baseMsgRecvPacket = {\n  signer: \"\"\n};\nexports.MsgRecvPacket = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.proofCommitment.length !== 0) {\n      writer.uint32(18).bytes(message.proofCommitment);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(34).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgRecvPacket);\n    message.proofCommitment = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.proofCommitment = reader.bytes();\n          break;\n\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgRecvPacket);\n    message.proofCommitment = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n      message.proofCommitment = bytesFromBase64(object.proofCommitment);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofCommitment !== undefined && (obj.proofCommitment = base64FromBytes(message.proofCommitment !== undefined ? message.proofCommitment : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgRecvPacket);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n      message.proofCommitment = object.proofCommitment;\n    } else {\n      message.proofCommitment = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgRecvPacketResponse = {};\nexports.MsgRecvPacketResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgRecvPacketResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgRecvPacketResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgRecvPacketResponse);\n    return message;\n  }\n\n};\nconst baseMsgTimeout = {\n  nextSequenceRecv: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgTimeout = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(32).uint64(message.nextSequenceRecv);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeout);\n    message.proofUnreceived = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgTimeout);\n    message.proofUnreceived = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgTimeout);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = object.proofUnreceived;\n    } else {\n      message.proofUnreceived = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = object.nextSequenceRecv;\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgTimeoutResponse = {};\nexports.MsgTimeoutResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeoutResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgTimeoutResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgTimeoutResponse);\n    return message;\n  }\n\n};\nconst baseMsgTimeoutOnClose = {\n  nextSequenceRecv: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgTimeoutOnClose = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n\n    if (message.proofClose.length !== 0) {\n      writer.uint32(26).bytes(message.proofClose);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(40).uint64(message.nextSequenceRecv);\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(50).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeoutOnClose);\n    message.proofUnreceived = new Uint8Array();\n    message.proofClose = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n\n        case 3:\n          message.proofClose = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n\n        case 6:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgTimeoutOnClose);\n    message.proofUnreceived = new Uint8Array();\n    message.proofClose = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n    }\n\n    if (object.proofClose !== undefined && object.proofClose !== null) {\n      message.proofClose = bytesFromBase64(object.proofClose);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofClose !== undefined && (obj.proofClose = base64FromBytes(message.proofClose !== undefined ? message.proofClose : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgTimeoutOnClose);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = object.proofUnreceived;\n    } else {\n      message.proofUnreceived = new Uint8Array();\n    }\n\n    if (object.proofClose !== undefined && object.proofClose !== null) {\n      message.proofClose = object.proofClose;\n    } else {\n      message.proofClose = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = object.nextSequenceRecv;\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgTimeoutOnCloseResponse = {};\nexports.MsgTimeoutOnCloseResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n    return message;\n  }\n\n};\nconst baseMsgAcknowledgement = {\n  signer: \"\"\n};\nexports.MsgAcknowledgement = {\n  encode(message) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n\n    if (message.acknowledgement.length !== 0) {\n      writer.uint32(18).bytes(message.acknowledgement);\n    }\n\n    if (message.proofAcked.length !== 0) {\n      writer.uint32(26).bytes(message.proofAcked);\n    }\n\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgAcknowledgement);\n    message.acknowledgement = new Uint8Array();\n    message.proofAcked = new Uint8Array();\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.acknowledgement = reader.bytes();\n          break;\n\n        case 3:\n          message.proofAcked = reader.bytes();\n          break;\n\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.signer = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgAcknowledgement);\n    message.acknowledgement = new Uint8Array();\n    message.proofAcked = new Uint8Array();\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n      message.acknowledgement = bytesFromBase64(object.acknowledgement);\n    }\n\n    if (object.proofAcked !== undefined && object.proofAcked !== null) {\n      message.proofAcked = bytesFromBase64(object.proofAcked);\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  },\n\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.acknowledgement !== undefined && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== undefined ? message.acknowledgement : new Uint8Array()));\n    message.proofAcked !== undefined && (obj.proofAcked = base64FromBytes(message.proofAcked !== undefined ? message.proofAcked : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgAcknowledgement);\n\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n\n    if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n      message.acknowledgement = object.acknowledgement;\n    } else {\n      message.acknowledgement = new Uint8Array();\n    }\n\n    if (object.proofAcked !== undefined && object.proofAcked !== null) {\n      message.proofAcked = object.proofAcked;\n    } else {\n      message.proofAcked = new Uint8Array();\n    }\n\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n\n    return message;\n  }\n\n};\nconst baseMsgAcknowledgementResponse = {};\nexports.MsgAcknowledgementResponse = {\n  encode(_) {\n    let writer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : minimal_1.default.Writer.create();\n    return writer;\n  },\n\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgAcknowledgementResponse);\n\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  },\n\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgAcknowledgementResponse);\n    return message;\n  },\n\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgAcknowledgementResponse);\n    return message;\n  }\n\n};\n\nclass MsgClientImpl {\n  constructor(rpc) {\n    this.rpc = rpc;\n  }\n\n  ChannelOpenInit(request) {\n    const data = exports.MsgChannelOpenInit.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenInit\", data);\n    return promise.then(data => exports.MsgChannelOpenInitResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ChannelOpenTry(request) {\n    const data = exports.MsgChannelOpenTry.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenTry\", data);\n    return promise.then(data => exports.MsgChannelOpenTryResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ChannelOpenAck(request) {\n    const data = exports.MsgChannelOpenAck.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenAck\", data);\n    return promise.then(data => exports.MsgChannelOpenAckResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ChannelOpenConfirm(request) {\n    const data = exports.MsgChannelOpenConfirm.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenConfirm\", data);\n    return promise.then(data => exports.MsgChannelOpenConfirmResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ChannelCloseInit(request) {\n    const data = exports.MsgChannelCloseInit.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseInit\", data);\n    return promise.then(data => exports.MsgChannelCloseInitResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  ChannelCloseConfirm(request) {\n    const data = exports.MsgChannelCloseConfirm.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseConfirm\", data);\n    return promise.then(data => exports.MsgChannelCloseConfirmResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  RecvPacket(request) {\n    const data = exports.MsgRecvPacket.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"RecvPacket\", data);\n    return promise.then(data => exports.MsgRecvPacketResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  Timeout(request) {\n    const data = exports.MsgTimeout.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Timeout\", data);\n    return promise.then(data => exports.MsgTimeoutResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  TimeoutOnClose(request) {\n    const data = exports.MsgTimeoutOnClose.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"TimeoutOnClose\", data);\n    return promise.then(data => exports.MsgTimeoutOnCloseResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n  Acknowledgement(request) {\n    const data = exports.MsgAcknowledgement.encode(request).finish();\n    const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Acknowledgement\", data);\n    return promise.then(data => exports.MsgAcknowledgementResponse.decode(new minimal_1.default.Reader(data)));\n  }\n\n}\n\nexports.MsgClientImpl = MsgClientImpl;\n\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\n\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\n\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n\n  return arr;\n}\n\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\n\nfunction base64FromBytes(arr) {\n  const bin = [];\n\n  for (let i = 0; i < arr.byteLength; ++i) {\n    bin.push(String.fromCharCode(arr[i]));\n  }\n\n  return btoa(bin.join(\"\"));\n}\n\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}","map":{"version":3,"sources":["../../../../../../src/codec/ibc/core/channel/v1/tx.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MsgClientImpl = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst channel_1 = require(\"../../../../ibc/core/channel/v1/channel\");\nconst client_1 = require(\"../../../../ibc/core/client/v1/client\");\nexports.protobufPackage = \"ibc.core.channel.v1\";\nconst baseMsgChannelOpenInit = { portId: \"\", signer: \"\" };\nexports.MsgChannelOpenInit = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.portId !== \"\") {\n            writer.uint32(10).string(message.portId);\n        }\n        if (message.channel !== undefined) {\n            channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(26).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenInit);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.portId = reader.string();\n                    break;\n                case 2:\n                    message.channel = channel_1.Channel.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgChannelOpenInit);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = String(object.portId);\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channel !== undefined && object.channel !== null) {\n            message.channel = channel_1.Channel.fromJSON(object.channel);\n        }\n        else {\n            message.channel = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.portId !== undefined && (obj.portId = message.portId);\n        message.channel !== undefined &&\n            (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgChannelOpenInit);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = object.portId;\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channel !== undefined && object.channel !== null) {\n            message.channel = channel_1.Channel.fromPartial(object.channel);\n        }\n        else {\n            message.channel = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgChannelOpenInitResponse = {};\nexports.MsgChannelOpenInitResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n        return message;\n    },\n};\nconst baseMsgChannelOpenTry = {\n    portId: \"\",\n    previousChannelId: \"\",\n    counterpartyVersion: \"\",\n    signer: \"\",\n};\nexports.MsgChannelOpenTry = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.portId !== \"\") {\n            writer.uint32(10).string(message.portId);\n        }\n        if (message.previousChannelId !== \"\") {\n            writer.uint32(18).string(message.previousChannelId);\n        }\n        if (message.channel !== undefined) {\n            channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.counterpartyVersion !== \"\") {\n            writer.uint32(34).string(message.counterpartyVersion);\n        }\n        if (message.proofInit.length !== 0) {\n            writer.uint32(42).bytes(message.proofInit);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(58).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenTry);\n        message.proofInit = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.portId = reader.string();\n                    break;\n                case 2:\n                    message.previousChannelId = reader.string();\n                    break;\n                case 3:\n                    message.channel = channel_1.Channel.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.counterpartyVersion = reader.string();\n                    break;\n                case 5:\n                    message.proofInit = reader.bytes();\n                    break;\n                case 6:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgChannelOpenTry);\n        message.proofInit = new Uint8Array();\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = String(object.portId);\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n            message.previousChannelId = String(object.previousChannelId);\n        }\n        else {\n            message.previousChannelId = \"\";\n        }\n        if (object.channel !== undefined && object.channel !== null) {\n            message.channel = channel_1.Channel.fromJSON(object.channel);\n        }\n        else {\n            message.channel = undefined;\n        }\n        if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n            message.counterpartyVersion = String(object.counterpartyVersion);\n        }\n        else {\n            message.counterpartyVersion = \"\";\n        }\n        if (object.proofInit !== undefined && object.proofInit !== null) {\n            message.proofInit = bytesFromBase64(object.proofInit);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.portId !== undefined && (obj.portId = message.portId);\n        message.previousChannelId !== undefined && (obj.previousChannelId = message.previousChannelId);\n        message.channel !== undefined &&\n            (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n        message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n        message.proofInit !== undefined &&\n            (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgChannelOpenTry);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = object.portId;\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n            message.previousChannelId = object.previousChannelId;\n        }\n        else {\n            message.previousChannelId = \"\";\n        }\n        if (object.channel !== undefined && object.channel !== null) {\n            message.channel = channel_1.Channel.fromPartial(object.channel);\n        }\n        else {\n            message.channel = undefined;\n        }\n        if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n            message.counterpartyVersion = object.counterpartyVersion;\n        }\n        else {\n            message.counterpartyVersion = \"\";\n        }\n        if (object.proofInit !== undefined && object.proofInit !== null) {\n            message.proofInit = object.proofInit;\n        }\n        else {\n            message.proofInit = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgChannelOpenTryResponse = {};\nexports.MsgChannelOpenTryResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n        return message;\n    },\n};\nconst baseMsgChannelOpenAck = {\n    portId: \"\",\n    channelId: \"\",\n    counterpartyChannelId: \"\",\n    counterpartyVersion: \"\",\n    signer: \"\",\n};\nexports.MsgChannelOpenAck = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.portId !== \"\") {\n            writer.uint32(10).string(message.portId);\n        }\n        if (message.channelId !== \"\") {\n            writer.uint32(18).string(message.channelId);\n        }\n        if (message.counterpartyChannelId !== \"\") {\n            writer.uint32(26).string(message.counterpartyChannelId);\n        }\n        if (message.counterpartyVersion !== \"\") {\n            writer.uint32(34).string(message.counterpartyVersion);\n        }\n        if (message.proofTry.length !== 0) {\n            writer.uint32(42).bytes(message.proofTry);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(58).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenAck);\n        message.proofTry = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.portId = reader.string();\n                    break;\n                case 2:\n                    message.channelId = reader.string();\n                    break;\n                case 3:\n                    message.counterpartyChannelId = reader.string();\n                    break;\n                case 4:\n                    message.counterpartyVersion = reader.string();\n                    break;\n                case 5:\n                    message.proofTry = reader.bytes();\n                    break;\n                case 6:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgChannelOpenAck);\n        message.proofTry = new Uint8Array();\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = String(object.portId);\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = String(object.channelId);\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n            message.counterpartyChannelId = String(object.counterpartyChannelId);\n        }\n        else {\n            message.counterpartyChannelId = \"\";\n        }\n        if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n            message.counterpartyVersion = String(object.counterpartyVersion);\n        }\n        else {\n            message.counterpartyVersion = \"\";\n        }\n        if (object.proofTry !== undefined && object.proofTry !== null) {\n            message.proofTry = bytesFromBase64(object.proofTry);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.portId !== undefined && (obj.portId = message.portId);\n        message.channelId !== undefined && (obj.channelId = message.channelId);\n        message.counterpartyChannelId !== undefined &&\n            (obj.counterpartyChannelId = message.counterpartyChannelId);\n        message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n        message.proofTry !== undefined &&\n            (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgChannelOpenAck);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = object.portId;\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = object.channelId;\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n            message.counterpartyChannelId = object.counterpartyChannelId;\n        }\n        else {\n            message.counterpartyChannelId = \"\";\n        }\n        if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n            message.counterpartyVersion = object.counterpartyVersion;\n        }\n        else {\n            message.counterpartyVersion = \"\";\n        }\n        if (object.proofTry !== undefined && object.proofTry !== null) {\n            message.proofTry = object.proofTry;\n        }\n        else {\n            message.proofTry = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgChannelOpenAckResponse = {};\nexports.MsgChannelOpenAckResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n        return message;\n    },\n};\nconst baseMsgChannelOpenConfirm = { portId: \"\", channelId: \"\", signer: \"\" };\nexports.MsgChannelOpenConfirm = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.portId !== \"\") {\n            writer.uint32(10).string(message.portId);\n        }\n        if (message.channelId !== \"\") {\n            writer.uint32(18).string(message.channelId);\n        }\n        if (message.proofAck.length !== 0) {\n            writer.uint32(26).bytes(message.proofAck);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(42).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenConfirm);\n        message.proofAck = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.portId = reader.string();\n                    break;\n                case 2:\n                    message.channelId = reader.string();\n                    break;\n                case 3:\n                    message.proofAck = reader.bytes();\n                    break;\n                case 4:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgChannelOpenConfirm);\n        message.proofAck = new Uint8Array();\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = String(object.portId);\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = String(object.channelId);\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.proofAck !== undefined && object.proofAck !== null) {\n            message.proofAck = bytesFromBase64(object.proofAck);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.portId !== undefined && (obj.portId = message.portId);\n        message.channelId !== undefined && (obj.channelId = message.channelId);\n        message.proofAck !== undefined &&\n            (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgChannelOpenConfirm);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = object.portId;\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = object.channelId;\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.proofAck !== undefined && object.proofAck !== null) {\n            message.proofAck = object.proofAck;\n        }\n        else {\n            message.proofAck = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgChannelOpenConfirmResponse = {};\nexports.MsgChannelOpenConfirmResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n        return message;\n    },\n};\nconst baseMsgChannelCloseInit = { portId: \"\", channelId: \"\", signer: \"\" };\nexports.MsgChannelCloseInit = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.portId !== \"\") {\n            writer.uint32(10).string(message.portId);\n        }\n        if (message.channelId !== \"\") {\n            writer.uint32(18).string(message.channelId);\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(26).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelCloseInit);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.portId = reader.string();\n                    break;\n                case 2:\n                    message.channelId = reader.string();\n                    break;\n                case 3:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgChannelCloseInit);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = String(object.portId);\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = String(object.channelId);\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.portId !== undefined && (obj.portId = message.portId);\n        message.channelId !== undefined && (obj.channelId = message.channelId);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgChannelCloseInit);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = object.portId;\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = object.channelId;\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgChannelCloseInitResponse = {};\nexports.MsgChannelCloseInitResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n        return message;\n    },\n};\nconst baseMsgChannelCloseConfirm = { portId: \"\", channelId: \"\", signer: \"\" };\nexports.MsgChannelCloseConfirm = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.portId !== \"\") {\n            writer.uint32(10).string(message.portId);\n        }\n        if (message.channelId !== \"\") {\n            writer.uint32(18).string(message.channelId);\n        }\n        if (message.proofInit.length !== 0) {\n            writer.uint32(26).bytes(message.proofInit);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(42).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelCloseConfirm);\n        message.proofInit = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.portId = reader.string();\n                    break;\n                case 2:\n                    message.channelId = reader.string();\n                    break;\n                case 3:\n                    message.proofInit = reader.bytes();\n                    break;\n                case 4:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgChannelCloseConfirm);\n        message.proofInit = new Uint8Array();\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = String(object.portId);\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = String(object.channelId);\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.proofInit !== undefined && object.proofInit !== null) {\n            message.proofInit = bytesFromBase64(object.proofInit);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.portId !== undefined && (obj.portId = message.portId);\n        message.channelId !== undefined && (obj.channelId = message.channelId);\n        message.proofInit !== undefined &&\n            (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgChannelCloseConfirm);\n        if (object.portId !== undefined && object.portId !== null) {\n            message.portId = object.portId;\n        }\n        else {\n            message.portId = \"\";\n        }\n        if (object.channelId !== undefined && object.channelId !== null) {\n            message.channelId = object.channelId;\n        }\n        else {\n            message.channelId = \"\";\n        }\n        if (object.proofInit !== undefined && object.proofInit !== null) {\n            message.proofInit = object.proofInit;\n        }\n        else {\n            message.proofInit = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgChannelCloseConfirmResponse = {};\nexports.MsgChannelCloseConfirmResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n        return message;\n    },\n};\nconst baseMsgRecvPacket = { signer: \"\" };\nexports.MsgRecvPacket = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.packet !== undefined) {\n            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.proofCommitment.length !== 0) {\n            writer.uint32(18).bytes(message.proofCommitment);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(34).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgRecvPacket);\n        message.proofCommitment = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.packet = channel_1.Packet.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.proofCommitment = reader.bytes();\n                    break;\n                case 3:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgRecvPacket);\n        message.proofCommitment = new Uint8Array();\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromJSON(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n            message.proofCommitment = bytesFromBase64(object.proofCommitment);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n        message.proofCommitment !== undefined &&\n            (obj.proofCommitment = base64FromBytes(message.proofCommitment !== undefined ? message.proofCommitment : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgRecvPacket);\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromPartial(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n            message.proofCommitment = object.proofCommitment;\n        }\n        else {\n            message.proofCommitment = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgRecvPacketResponse = {};\nexports.MsgRecvPacketResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgRecvPacketResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgRecvPacketResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgRecvPacketResponse);\n        return message;\n    },\n};\nconst baseMsgTimeout = { nextSequenceRecv: long_1.default.UZERO, signer: \"\" };\nexports.MsgTimeout = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.packet !== undefined) {\n            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.proofUnreceived.length !== 0) {\n            writer.uint32(18).bytes(message.proofUnreceived);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n        }\n        if (!message.nextSequenceRecv.isZero()) {\n            writer.uint32(32).uint64(message.nextSequenceRecv);\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(42).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgTimeout);\n        message.proofUnreceived = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.packet = channel_1.Packet.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.proofUnreceived = reader.bytes();\n                    break;\n                case 3:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.nextSequenceRecv = reader.uint64();\n                    break;\n                case 5:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgTimeout);\n        message.proofUnreceived = new Uint8Array();\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromJSON(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n            message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n            message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n        }\n        else {\n            message.nextSequenceRecv = long_1.default.UZERO;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n        message.proofUnreceived !== undefined &&\n            (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.nextSequenceRecv !== undefined &&\n            (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgTimeout);\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromPartial(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n            message.proofUnreceived = object.proofUnreceived;\n        }\n        else {\n            message.proofUnreceived = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n            message.nextSequenceRecv = object.nextSequenceRecv;\n        }\n        else {\n            message.nextSequenceRecv = long_1.default.UZERO;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgTimeoutResponse = {};\nexports.MsgTimeoutResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgTimeoutResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgTimeoutResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgTimeoutResponse);\n        return message;\n    },\n};\nconst baseMsgTimeoutOnClose = { nextSequenceRecv: long_1.default.UZERO, signer: \"\" };\nexports.MsgTimeoutOnClose = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.packet !== undefined) {\n            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.proofUnreceived.length !== 0) {\n            writer.uint32(18).bytes(message.proofUnreceived);\n        }\n        if (message.proofClose.length !== 0) {\n            writer.uint32(26).bytes(message.proofClose);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n        }\n        if (!message.nextSequenceRecv.isZero()) {\n            writer.uint32(40).uint64(message.nextSequenceRecv);\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(50).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgTimeoutOnClose);\n        message.proofUnreceived = new Uint8Array();\n        message.proofClose = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.packet = channel_1.Packet.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.proofUnreceived = reader.bytes();\n                    break;\n                case 3:\n                    message.proofClose = reader.bytes();\n                    break;\n                case 4:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.nextSequenceRecv = reader.uint64();\n                    break;\n                case 6:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgTimeoutOnClose);\n        message.proofUnreceived = new Uint8Array();\n        message.proofClose = new Uint8Array();\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromJSON(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n            message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n        }\n        if (object.proofClose !== undefined && object.proofClose !== null) {\n            message.proofClose = bytesFromBase64(object.proofClose);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n            message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n        }\n        else {\n            message.nextSequenceRecv = long_1.default.UZERO;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n        message.proofUnreceived !== undefined &&\n            (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n        message.proofClose !== undefined &&\n            (obj.proofClose = base64FromBytes(message.proofClose !== undefined ? message.proofClose : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.nextSequenceRecv !== undefined &&\n            (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgTimeoutOnClose);\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromPartial(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n            message.proofUnreceived = object.proofUnreceived;\n        }\n        else {\n            message.proofUnreceived = new Uint8Array();\n        }\n        if (object.proofClose !== undefined && object.proofClose !== null) {\n            message.proofClose = object.proofClose;\n        }\n        else {\n            message.proofClose = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n            message.nextSequenceRecv = object.nextSequenceRecv;\n        }\n        else {\n            message.nextSequenceRecv = long_1.default.UZERO;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgTimeoutOnCloseResponse = {};\nexports.MsgTimeoutOnCloseResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n        return message;\n    },\n};\nconst baseMsgAcknowledgement = { signer: \"\" };\nexports.MsgAcknowledgement = {\n    encode(message, writer = minimal_1.default.Writer.create()) {\n        if (message.packet !== undefined) {\n            channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.acknowledgement.length !== 0) {\n            writer.uint32(18).bytes(message.acknowledgement);\n        }\n        if (message.proofAcked.length !== 0) {\n            writer.uint32(26).bytes(message.proofAcked);\n        }\n        if (message.proofHeight !== undefined) {\n            client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.signer !== \"\") {\n            writer.uint32(42).string(message.signer);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgAcknowledgement);\n        message.acknowledgement = new Uint8Array();\n        message.proofAcked = new Uint8Array();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.packet = channel_1.Packet.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.acknowledgement = reader.bytes();\n                    break;\n                case 3:\n                    message.proofAcked = reader.bytes();\n                    break;\n                case 4:\n                    message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.signer = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        const message = Object.assign({}, baseMsgAcknowledgement);\n        message.acknowledgement = new Uint8Array();\n        message.proofAcked = new Uint8Array();\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromJSON(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n            message.acknowledgement = bytesFromBase64(object.acknowledgement);\n        }\n        if (object.proofAcked !== undefined && object.proofAcked !== null) {\n            message.proofAcked = bytesFromBase64(object.proofAcked);\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = String(object.signer);\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n    toJSON(message) {\n        const obj = {};\n        message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n        message.acknowledgement !== undefined &&\n            (obj.acknowledgement = base64FromBytes(message.acknowledgement !== undefined ? message.acknowledgement : new Uint8Array()));\n        message.proofAcked !== undefined &&\n            (obj.proofAcked = base64FromBytes(message.proofAcked !== undefined ? message.proofAcked : new Uint8Array()));\n        message.proofHeight !== undefined &&\n            (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n        message.signer !== undefined && (obj.signer = message.signer);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = Object.assign({}, baseMsgAcknowledgement);\n        if (object.packet !== undefined && object.packet !== null) {\n            message.packet = channel_1.Packet.fromPartial(object.packet);\n        }\n        else {\n            message.packet = undefined;\n        }\n        if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n            message.acknowledgement = object.acknowledgement;\n        }\n        else {\n            message.acknowledgement = new Uint8Array();\n        }\n        if (object.proofAcked !== undefined && object.proofAcked !== null) {\n            message.proofAcked = object.proofAcked;\n        }\n        else {\n            message.proofAcked = new Uint8Array();\n        }\n        if (object.proofHeight !== undefined && object.proofHeight !== null) {\n            message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n        }\n        else {\n            message.proofHeight = undefined;\n        }\n        if (object.signer !== undefined && object.signer !== null) {\n            message.signer = object.signer;\n        }\n        else {\n            message.signer = \"\";\n        }\n        return message;\n    },\n};\nconst baseMsgAcknowledgementResponse = {};\nexports.MsgAcknowledgementResponse = {\n    encode(_, writer = minimal_1.default.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = Object.assign({}, baseMsgAcknowledgementResponse);\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        const message = Object.assign({}, baseMsgAcknowledgementResponse);\n        return message;\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = Object.assign({}, baseMsgAcknowledgementResponse);\n        return message;\n    },\n};\nclass MsgClientImpl {\n    constructor(rpc) {\n        this.rpc = rpc;\n    }\n    ChannelOpenInit(request) {\n        const data = exports.MsgChannelOpenInit.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenInit\", data);\n        return promise.then((data) => exports.MsgChannelOpenInitResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ChannelOpenTry(request) {\n        const data = exports.MsgChannelOpenTry.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenTry\", data);\n        return promise.then((data) => exports.MsgChannelOpenTryResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ChannelOpenAck(request) {\n        const data = exports.MsgChannelOpenAck.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenAck\", data);\n        return promise.then((data) => exports.MsgChannelOpenAckResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ChannelOpenConfirm(request) {\n        const data = exports.MsgChannelOpenConfirm.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelOpenConfirm\", data);\n        return promise.then((data) => exports.MsgChannelOpenConfirmResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ChannelCloseInit(request) {\n        const data = exports.MsgChannelCloseInit.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseInit\", data);\n        return promise.then((data) => exports.MsgChannelCloseInitResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    ChannelCloseConfirm(request) {\n        const data = exports.MsgChannelCloseConfirm.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"ChannelCloseConfirm\", data);\n        return promise.then((data) => exports.MsgChannelCloseConfirmResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    RecvPacket(request) {\n        const data = exports.MsgRecvPacket.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"RecvPacket\", data);\n        return promise.then((data) => exports.MsgRecvPacketResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    Timeout(request) {\n        const data = exports.MsgTimeout.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Timeout\", data);\n        return promise.then((data) => exports.MsgTimeoutResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    TimeoutOnClose(request) {\n        const data = exports.MsgTimeoutOnClose.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"TimeoutOnClose\", data);\n        return promise.then((data) => exports.MsgTimeoutOnCloseResponse.decode(new minimal_1.default.Reader(data)));\n    }\n    Acknowledgement(request) {\n        const data = exports.MsgAcknowledgement.encode(request).finish();\n        const promise = this.rpc.request(\"ibc.core.channel.v1.Msg\", \"Acknowledgement\", data);\n        return promise.then((data) => exports.MsgAcknowledgementResponse.decode(new minimal_1.default.Reader(data)));\n    }\n}\nexports.MsgClientImpl = MsgClientImpl;\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    for (let i = 0; i < arr.byteLength; ++i) {\n        bin.push(String.fromCharCode(arr[i]));\n    }\n    return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n    minimal_1.default.util.Long = long_1.default;\n    minimal_1.default.configure();\n}\n//# sourceMappingURL=tx.js.map"]},"metadata":{},"sourceType":"script"}