{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useBoolean, useCallbackRef, useControllableState, useDimensions, useIds, useLatestRef, usePanGesture, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { mergeRefs } from \"@chakra-ui/react-utils\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, getBox, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useMemo, useRef } from \"react\";\nimport { getStyles, getIsReversed } from \"./slider-utils\";\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\n\nexport function useSlider(props) {\n  var _getAriaValueText;\n\n  var {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"direction\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\"]);\n\n  var onChangeStart = useCallbackRef(onChangeStartProp);\n  var onChangeEnd = useCallbackRef(onChangeEndProp);\n  var getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  var isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n\n  var [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : getDefaultValue(min, max),\n    onChange\n  });\n  var [isDragging, setDragging] = useBoolean();\n  var [isFocused, setFocused] = useBoolean();\n  var eventSourceRef = useRef(null);\n  var isInteractive = !(isDisabled || isReadOnly);\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n\n  var value = clampValue(computedValue, min, max);\n  var valueRef = useLatestRef(value);\n  var prevRef = useRef(valueRef.current);\n  var reversedValue = max - value + min;\n  var trackValue = isReversed ? reversedValue : value;\n  var thumbPercent = valueToPercent(trackValue, min, max);\n  var isVertical = orientation === \"vertical\";\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var thumbRef = useRef(null);\n  var rootRef = useRef(null);\n  /**\n   * Generate unique ids for component parts\n   */\n\n  var [thumbId, trackId] = useIds(idProp, \"slider-thumb\", \"slider-track\");\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  var getValueFromPointer = useCallback(event => {\n    var _event$touches$, _event$touches;\n\n    if (!trackRef.current) return;\n    eventSourceRef.current = \"pointer\";\n    var trackRect = getBox(trackRef.current).borderBox;\n    var {\n      clientX,\n      clientY\n    } = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event;\n    var diff = isVertical ? trackRect.bottom - clientY : clientX - trackRect.left;\n    var length = isVertical ? trackRect.height : trackRect.width;\n    var percent = diff / length;\n\n    if (isReversed) {\n      percent = 1 - percent;\n    }\n\n    var nextValue = percentToValue(percent, min, max);\n\n    if (step) {\n      nextValue = parseFloat(roundValueToStep(nextValue, min, step));\n    }\n\n    nextValue = clampValue(nextValue, min, max);\n    return nextValue;\n  }, [isVertical, isReversed, max, min, step]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var constrain = useCallback(value => {\n    if (!isInteractive) return;\n    value = parseFloat(roundValueToStep(value, min, oneStep));\n    value = clampValue(value, min, max);\n    setValue(value);\n  }, [oneStep, max, min, setValue, isInteractive]);\n  var actions = useMemo(() => ({\n    stepUp: function stepUp(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var next = isReversed ? value - step : value + step;\n      constrain(next);\n    },\n    stepDown: function stepDown(step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var next = isReversed ? value + step : value - step;\n      constrain(next);\n    },\n    reset: () => constrain(defaultValue || 0),\n    stepTo: value => constrain(value)\n  }), [constrain, isReversed, value, oneStep, defaultValue]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: () => actions.stepUp(),\n      ArrowUp: () => actions.stepUp(),\n      ArrowLeft: () => actions.stepDown(),\n      ArrowDown: () => actions.stepDown(),\n      PageUp: () => actions.stepUp(tenSteps),\n      PageDown: () => actions.stepDown(tenSteps),\n      Home: () => constrain(min),\n      End: () => constrain(max)\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      eventSourceRef.current = \"keyboard\";\n    }\n  }, [actions, constrain, max, min, tenSteps]);\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n\n  var valueText = (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(value)) != null ? _getAriaValueText : ariaValueText;\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n\n  var thumbBoxModel = useDimensions(thumbRef);\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => {\n    var _thumbBoxModel$border;\n\n    var thumbRect = (_thumbBoxModel$border = thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox) != null ? _thumbBoxModel$border : {\n      width: 0,\n      height: 0\n    };\n    return getStyles({\n      isReversed,\n      orientation,\n      thumbRects: [thumbRect],\n      thumbPercents: [thumbPercent]\n    });\n  }, [isReversed, orientation, thumbBoxModel == null ? void 0 : thumbBoxModel.borderBox, thumbPercent]);\n  var focusThumb = useCallback(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(() => focus(thumbRef.current));\n    }\n  }, [focusThumbOnChange]);\n  useUpdateEffect(() => {\n    focusThumb();\n\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    }\n  }, [value, onChangeEnd]);\n\n  var setValueFromPointer = event => {\n    var nextValue = getValueFromPointer(event);\n\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue);\n    }\n  };\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging.on();\n      focusThumb();\n      setValueFromPointer(event);\n      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);\n    },\n\n    onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging.off();\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n      prevRef.current = valueRef.current;\n    },\n\n    onPan(event) {\n      if (!isInteractive) return;\n      setValueFromPointer(event);\n    }\n\n  });\n  var getRootProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, htmlProps, {\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  }, [htmlProps, isDisabled, isFocused, rootStyle]);\n  var getTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  }, [isDisabled, trackId, trackStyle]);\n  var getInnerTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  }, [innerTrackStyle]);\n  var getThumbProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: _extends({}, props.style, getThumbStyle(0)),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off)\n    });\n  }, [isInteractive, thumbId, isDragging, valueText, min, max, value, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused.on, setFocused.off]);\n  var getMarkerProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    var isInRange = !(props.value < min || props.value > max);\n    var isHighlighted = value >= props.value;\n    var markerPercent = valueToPercent(props.value, min, max);\n\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation,\n      vertical: {\n        bottom: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      },\n      horizontal: {\n        left: isReversed ? 100 - markerPercent + \"%\" : markerPercent + \"%\"\n      }\n    }));\n\n    return _extends({}, props, {\n      ref,\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  }, [isDisabled, isReversed, max, min, orientation, value]);\n  var getInputProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      type: \"hidden\",\n      value,\n      name\n    });\n  }, [name, value]);\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps\n  };\n}\n\nfunction orient(options) {\n  var {\n    orientation,\n    vertical,\n    horizontal\n  } = options;\n  return orientation === \"vertical\" ? vertical : horizontal;\n}\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\n\n\nfunction getDefaultValue(min, max) {\n  return max < min ? min : min + (max - min) / 2;\n}","map":{"version":3,"sources":["../../src/use-slider.ts"],"names":["min","max","value","isReversed","direction","orientation","id","onChangeStart","onChangeEnd","step","getAriaValueText","focusThumbOnChange","htmlProps","useCallbackRef","getIsReversed","useControllableState","defaultValue","getDefaultValue","onChange","useBoolean","eventSourceRef","useRef","isInteractive","isDisabled","clampValue","valueRef","useLatestRef","prevRef","reversedValue","trackValue","thumbPercent","valueToPercent","isVertical","trackRef","thumbRef","rootRef","useIds","getValueFromPointer","useCallback","event","trackRect","getBox","clientY","diff","clientX","length","percent","nextValue","percentToValue","parseFloat","roundValueToStep","tenSteps","oneStep","constrain","setValue","actions","useMemo","stepUp","next","stepDown","reset","stepTo","onKeyDown","eventKey","normalizeEventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","valueText","thumbBoxModel","useDimensions","innerTrackStyle","thumbRect","width","height","getStyles","thumbRects","thumbPercents","focusThumb","setTimeout","focus","useUpdateEffect","setValueFromPointer","usePanGesture","onPanSessionStart","setDragging","onPanSessionEnd","onPan","getRootProps","props","ref","mergeRefs","tabIndex","ariaAttr","dataAttr","style","getTrackProps","getInnerTrackProps","getThumbProps","role","ariaLabel","getThumbStyle","callAllHandlers","onFocus","setFocused","onBlur","getMarkerProps","isInRange","isHighlighted","markerPercent","markerStyle","position","pointerEvents","orient","vertical","bottom","horizontal","left","getInputProps","type","name","state","isDragging"],"mappings":"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","sourcesContent":["import {\n  useBoolean,\n  useCallbackRef,\n  useControllableState,\n  useDimensions,\n  useIds,\n  useLatestRef,\n  usePanGesture,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport { EventKeyMap, mergeRefs, PropGetter } from \"@chakra-ui/react-utils\"\nimport {\n  AnyPointerEvent,\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  focus,\n  getBox,\n  normalizeEventKey,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { CSSProperties, useCallback, useMemo, useRef } from \"react\"\nimport { getStyles, getIsReversed } from \"./slider-utils\"\n\nexport interface UseSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string\n  direction?: \"ltr\" | \"rtl\"\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useSlider(props: UseSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  /**\n   * Enable the slider handle controlled and uncontrolled scenarios\n   */\n  const [computedValue, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? getDefaultValue(min, max),\n    onChange,\n  })\n\n  const [isDragging, setDragging] = useBoolean()\n\n  const [isFocused, setFocused] = useBoolean()\n  const eventSourceRef = useRef<\"pointer\" | \"keyboard\" | null>(null)\n\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  /**\n   * Constrain the value because it can't be less than min\n   * or greater than max\n   */\n  const value = clampValue(computedValue, min, max)\n  const valueRef = useLatestRef(value)\n\n  const prevRef = useRef(valueRef.current)\n\n  const reversedValue = max - value + min\n  const trackValue = isReversed ? reversedValue : value\n  const thumbPercent = valueToPercent(trackValue, min, max)\n\n  const isVertical = orientation === \"vertical\"\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<any>(null)\n  const thumbRef = useRef<any>(null)\n  const rootRef = useRef<any>(null)\n\n  /**\n   * Generate unique ids for component parts\n   */\n  const [thumbId, trackId] = useIds(idProp, `slider-thumb`, `slider-track`)\n\n  /**\n   * Get relative value of slider from the event by tracking\n   * how far you clicked within the track to determine the value\n   *\n   * @todo - Refactor this later on to use info from pan session\n   */\n\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return\n      eventSourceRef.current = \"pointer\"\n      const trackRect = getBox(trackRef.current).borderBox\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical\n        ? trackRect.bottom - clientY\n        : clientX - trackRect.left\n\n      const length = isVertical ? trackRect.height : trackRect.width\n      let percent = diff / length\n\n      if (isReversed) {\n        percent = 1 - percent\n      }\n\n      let nextValue = percentToValue(percent, min, max)\n\n      if (step) {\n        nextValue = parseFloat(roundValueToStep(nextValue, min, step))\n      }\n\n      nextValue = clampValue(nextValue, min, max)\n\n      return nextValue\n    },\n    [isVertical, isReversed, max, min, step],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const constrain = useCallback(\n    (value: number) => {\n      if (!isInteractive) return\n      value = parseFloat(roundValueToStep(value, min, oneStep))\n      value = clampValue(value, min, max)\n      setValue(value)\n    },\n    [oneStep, max, min, setValue, isInteractive],\n  )\n\n  const actions = useMemo(\n    () => ({\n      stepUp: (step = oneStep) => {\n        const next = isReversed ? value - step : value + step\n        constrain(next)\n      },\n      stepDown: (step = oneStep) => {\n        const next = isReversed ? value + step : value - step\n        constrain(next)\n      },\n      reset: () => constrain(defaultValue || 0),\n      stepTo: (value: number) => constrain(value),\n    }),\n    [constrain, isReversed, value, oneStep, defaultValue],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(),\n        ArrowUp: () => actions.stepUp(),\n        ArrowLeft: () => actions.stepDown(),\n        ArrowDown: () => actions.stepDown(),\n        PageUp: () => actions.stepUp(tenSteps),\n        PageDown: () => actions.stepDown(tenSteps),\n        Home: () => constrain(min),\n        End: () => constrain(max),\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        eventSourceRef.current = \"keyboard\"\n      }\n    },\n    [actions, constrain, max, min, tenSteps],\n  )\n\n  /**\n   * ARIA (Optional): To define a human readable representation of the value,\n   * we allow users pass aria-valuetext.\n   */\n  const valueText = getAriaValueText?.(value) ?? ariaValueText\n\n  /**\n   * Measure the dimensions of the thumb so\n   * we can center it within the track properly\n   */\n  const thumbBoxModel = useDimensions(thumbRef)\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle,\n  } = useMemo(() => {\n    const thumbRect = thumbBoxModel?.borderBox ?? { width: 0, height: 0 }\n    return getStyles({\n      isReversed,\n      orientation,\n      thumbRects: [thumbRect],\n      thumbPercents: [thumbPercent],\n    })\n  }, [isReversed, orientation, thumbBoxModel?.borderBox, thumbPercent])\n\n  const focusThumb = useCallback(() => {\n    if (thumbRef.current && focusThumbOnChange) {\n      setTimeout(() => focus(thumbRef.current))\n    }\n  }, [focusThumbOnChange])\n\n  useUpdateEffect(() => {\n    focusThumb()\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd?.(valueRef.current)\n    }\n  }, [value, onChangeEnd])\n\n  const setValueFromPointer = (event: AnyPointerEvent) => {\n    const nextValue = getValueFromPointer(event)\n    if (nextValue != null && nextValue !== valueRef.current) {\n      setValue(nextValue)\n    }\n  }\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging.on()\n      focusThumb()\n      setValueFromPointer(event)\n      onChangeStart?.(valueRef.current)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging.off()\n      onChangeEnd?.(valueRef.current)\n      prevRef.current = valueRef.current\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      setValueFromPointer(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ...htmlProps,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: {\n        ...props.style,\n        ...rootStyle,\n      },\n    }),\n    [htmlProps, isDisabled, isFocused, rootStyle],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n      id: trackId,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: {\n        ...props.style,\n        ...trackStyle,\n      },\n    }),\n    [isDisabled, trackId, trackStyle],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      style: {\n        ...props.style,\n        ...innerTrackStyle,\n      },\n    }),\n    [innerTrackStyle],\n  )\n\n  const getThumbProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, thumbRef),\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: thumbId,\n      \"data-active\": dataAttr(isDragging),\n      \"aria-valuetext\": valueText,\n      \"aria-valuemin\": min,\n      \"aria-valuemax\": max,\n      \"aria-valuenow\": value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": ariaLabel ? undefined : ariaLabelledBy,\n      style: {\n        ...props.style,\n        ...getThumbStyle(0),\n      },\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, setFocused.on),\n      onBlur: callAllHandlers(props.onBlur, setFocused.off),\n    }),\n    [\n      isInteractive,\n      thumbId,\n      isDragging,\n      valueText,\n      min,\n      max,\n      value,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n      setFocused.on,\n      setFocused.off,\n    ],\n  )\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = useCallback(\n    (props = {}, ref = null) => {\n      const isInRange = !(props.value < min || props.value > max)\n      const isHighlighted = value >= props.value\n      const markerPercent = valueToPercent(props.value, min, max)\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: {\n            bottom: isReversed\n              ? `${100 - markerPercent}%`\n              : `${markerPercent}%`,\n          },\n          horizontal: {\n            left: isReversed ? `${100 - markerPercent}%` : `${markerPercent}%`,\n          },\n        }),\n      }\n\n      return {\n        ...props,\n        ref,\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value],\n  )\n\n  const getInputProps: PropGetter<HTMLInputElement> = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      type: \"hidden\",\n      value,\n      name,\n    }),\n    [name, value],\n  )\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n  }\n}\n\nexport type UseSliderReturn = ReturnType<typeof useSlider>\n\nfunction orient(options: {\n  orientation: UseSliderProps[\"orientation\"]\n  vertical: CSSProperties\n  horizontal: CSSProperties\n}) {\n  const { orientation, vertical, horizontal } = options\n  return orientation === \"vertical\" ? vertical : horizontal\n}\n\n/**\n * The browser <input type=\"range\" /> calculates\n * the default value of a slider by using mid-point\n * between the min and the max.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/range\n */\nfunction getDefaultValue(min: number, max: number) {\n  return max < min ? min : min + (max - min) / 2\n}\n"]},"metadata":{},"sourceType":"module"}