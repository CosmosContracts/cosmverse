{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CosmWasmClient = void 0;\n\nconst encoding_1 = require(\"@cosmjs/encoding\");\n\nconst math_1 = require(\"@cosmjs/math\");\n\nconst stargate_1 = require(\"@cosmjs/stargate\");\n\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\n\nconst utils_1 = require(\"@cosmjs/utils\");\n\nconst types_1 = require(\"./codec/cosmwasm/wasm/v1beta1/types\");\n\nconst queries_1 = require(\"./queries\");\n\nclass CosmWasmClient {\n  constructor(tmClient) {\n    this.codesCache = new Map();\n\n    if (tmClient) {\n      this.tmClient = tmClient;\n      this.queryClient = stargate_1.QueryClient.withExtensions(tmClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, queries_1.setupWasmExtension);\n    }\n  }\n\n  static async connect(endpoint) {\n    const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n    return new CosmWasmClient(tmClient);\n  }\n\n  getTmClient() {\n    return this.tmClient;\n  }\n\n  forceGetTmClient() {\n    if (!this.tmClient) {\n      throw new Error(\"Tendermint client not available. You cannot use online functionality in offline mode.\");\n    }\n\n    return this.tmClient;\n  }\n\n  getQueryClient() {\n    return this.queryClient;\n  }\n\n  forceGetQueryClient() {\n    if (!this.queryClient) {\n      throw new Error(\"Query client not available. You cannot use online functionality in offline mode.\");\n    }\n\n    return this.queryClient;\n  }\n\n  async getChainId() {\n    if (!this.chainId) {\n      const response = await this.forceGetTmClient().status();\n      const chainId = response.nodeInfo.network;\n      if (!chainId) throw new Error(\"Chain ID must not be empty\");\n      this.chainId = chainId;\n    }\n\n    return this.chainId;\n  }\n\n  async getHeight() {\n    const status = await this.forceGetTmClient().status();\n    return status.syncInfo.latestBlockHeight;\n  }\n\n  async getAccount(searchAddress) {\n    try {\n      const account = await this.forceGetQueryClient().auth.account(searchAddress);\n      return account ? stargate_1.accountFromAny(account) : null;\n    } catch (error) {\n      if (/rpc error: code = NotFound/i.test(error)) {\n        return null;\n      }\n\n      throw error;\n    }\n  }\n\n  async getSequence(address) {\n    const account = await this.getAccount(address);\n\n    if (!account) {\n      throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n    }\n\n    return {\n      accountNumber: account.accountNumber,\n      sequence: account.sequence\n    };\n  }\n\n  async getBlock(height) {\n    const response = await this.forceGetTmClient().block(height);\n    return {\n      id: encoding_1.toHex(response.blockId.hash).toUpperCase(),\n      header: {\n        version: {\n          block: new math_1.Uint53(response.block.header.version.block).toString(),\n          app: new math_1.Uint53(response.block.header.version.app).toString()\n        },\n        height: response.block.header.height,\n        chainId: response.block.header.chainId,\n        time: tendermint_rpc_1.toRfc3339WithNanoseconds(response.block.header.time)\n      },\n      txs: response.block.txs\n    };\n  }\n\n  async getBalance(address, searchDenom) {\n    return this.forceGetQueryClient().bank.balance(address, searchDenom);\n  }\n\n  async getTx(id) {\n    var _a;\n\n    const results = await this.txsQuery(`tx.hash='${id}'`);\n    return (_a = results[0]) !== null && _a !== void 0 ? _a : null;\n  }\n\n  async searchTx(query) {\n    let filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const minHeight = filter.minHeight || 0;\n    const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n    if (maxHeight < minHeight) return []; // optional optimization\n\n    function withFilters(originalQuery) {\n      return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;\n    }\n\n    let txs;\n\n    if (stargate_1.isSearchByHeightQuery(query)) {\n      txs = query.height >= minHeight && query.height <= maxHeight ? await this.txsQuery(`tx.height=${query.height}`) : [];\n    } else if (stargate_1.isSearchBySentFromOrToQuery(query)) {\n      const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);\n      const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);\n      const [sent, received] = await Promise.all([sentQuery, receivedQuery].map(rawQuery => this.txsQuery(rawQuery)));\n      const sentHashes = sent.map(t => t.hash);\n      txs = [...sent, ...received.filter(t => !sentHashes.includes(t.hash))];\n    } else if (stargate_1.isSearchByTagsQuery(query)) {\n      const rawQuery = withFilters(query.tags.map(t => `${t.key}='${t.value}'`).join(\" AND \"));\n      txs = await this.txsQuery(rawQuery);\n    } else {\n      throw new Error(\"Unknown query type\");\n    }\n\n    const filtered = txs.filter(tx => tx.height >= minHeight && tx.height <= maxHeight);\n    return filtered;\n  }\n\n  disconnect() {\n    if (this.tmClient) this.tmClient.disconnect();\n  }\n  /**\n   * Broadcasts a signed transaction to the network and monitors its inclusion in a block.\n   *\n   * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),\n   * an error is thrown.\n   *\n   * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.\n   *\n   * If the transaction is included in a block, a `BroadcastTxResponse` is returned. The caller then\n   * usually needs to check for execution success or failure.\n   */\n  // NOTE: This method is tested against slow chains and timeouts in the @cosmjs/stargate package.\n  // Make sure it is kept in sync!\n\n\n  async broadcastTx(tx) {\n    let timeoutMs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60000;\n    let pollIntervalMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3000;\n    let timedOut = false;\n    const txPollTimeout = setTimeout(() => {\n      timedOut = true;\n    }, timeoutMs);\n\n    const pollForTx = async txId => {\n      if (timedOut) {\n        throw new stargate_1.TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later.`, txId);\n      }\n\n      await utils_1.sleep(pollIntervalMs);\n      const result = await this.getTx(txId);\n      return result ? {\n        code: result.code,\n        height: result.height,\n        rawLog: result.rawLog,\n        transactionHash: txId,\n        gasUsed: result.gasUsed,\n        gasWanted: result.gasWanted\n      } : pollForTx(txId);\n    };\n\n    const broadcasted = await this.forceGetTmClient().broadcastTxSync({\n      tx\n    });\n\n    if (broadcasted.code) {\n      throw new Error(`Broadcasting transaction failed with code ${broadcasted.code} (codespace: ${broadcasted.codeSpace}). Log: ${broadcasted.log}`);\n    }\n\n    const transactionId = encoding_1.toHex(broadcasted.hash).toUpperCase();\n    return new Promise((resolve, reject) => pollForTx(transactionId).then(value => {\n      clearTimeout(txPollTimeout);\n      resolve(value);\n    }, error => {\n      clearTimeout(txPollTimeout);\n      reject(error);\n    }));\n  }\n\n  async getCodes() {\n    const {\n      codeInfos\n    } = await this.forceGetQueryClient().wasm.listCodeInfo();\n    return (codeInfos || []).map(entry => {\n      utils_1.assert(entry.creator && entry.codeId && entry.dataHash, \"entry incomplete\");\n      return {\n        id: entry.codeId.toNumber(),\n        creator: entry.creator,\n        checksum: encoding_1.toHex(entry.dataHash),\n        source: entry.source || undefined,\n        builder: entry.builder || undefined\n      };\n    });\n  }\n\n  async getCodeDetails(codeId) {\n    const cached = this.codesCache.get(codeId);\n    if (cached) return cached;\n    const {\n      codeInfo,\n      data\n    } = await this.forceGetQueryClient().wasm.getCode(codeId);\n    utils_1.assert(codeInfo && codeInfo.codeId && codeInfo.creator && codeInfo.dataHash && data, \"codeInfo missing or incomplete\");\n    const codeDetails = {\n      id: codeInfo.codeId.toNumber(),\n      creator: codeInfo.creator,\n      checksum: encoding_1.toHex(codeInfo.dataHash),\n      source: codeInfo.source || undefined,\n      builder: codeInfo.builder || undefined,\n      data: data\n    };\n    this.codesCache.set(codeId, codeDetails);\n    return codeDetails;\n  }\n\n  async getContracts(codeId) {\n    // TODO: handle pagination - accept as arg or auto-loop\n    const {\n      contracts\n    } = await this.forceGetQueryClient().wasm.listContractsByCodeId(codeId);\n    return contracts;\n  }\n  /**\n   * Throws an error if no contract was found at the address\n   */\n\n\n  async getContract(address) {\n    const {\n      address: retrievedAddress,\n      contractInfo\n    } = await this.forceGetQueryClient().wasm.getContractInfo(address);\n    if (!contractInfo) throw new Error(`No contract found at address \"${address}\"`);\n    utils_1.assert(retrievedAddress, \"address missing\");\n    utils_1.assert(contractInfo.codeId && contractInfo.creator && contractInfo.label, \"contractInfo incomplete\");\n    return {\n      address: retrievedAddress,\n      codeId: contractInfo.codeId.toNumber(),\n      creator: contractInfo.creator,\n      admin: contractInfo.admin || undefined,\n      label: contractInfo.label\n    };\n  }\n  /**\n   * Throws an error if no contract was found at the address\n   */\n\n\n  async getContractCodeHistory(address) {\n    const result = await this.forceGetQueryClient().wasm.getContractCodeHistory(address);\n    if (!result) throw new Error(`No contract history found for address \"${address}\"`);\n    const operations = {\n      [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT]: \"Init\",\n      [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS]: \"Genesis\",\n      [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE]: \"Migrate\"\n    };\n    return (result.entries || []).map(entry => {\n      utils_1.assert(entry.operation && entry.codeId && entry.msg);\n      return {\n        operation: operations[entry.operation],\n        codeId: entry.codeId.toNumber(),\n        msg: JSON.parse(encoding_1.fromAscii(entry.msg))\n      };\n    });\n  }\n  /**\n   * Returns the data at the key if present (raw contract dependent storage data)\n   * or null if no data at this key.\n   *\n   * Promise is rejected when contract does not exist.\n   */\n\n\n  async queryContractRaw(address, key) {\n    // just test contract existence\n    await this.getContract(address);\n    const {\n      data\n    } = await this.forceGetQueryClient().wasm.queryContractRaw(address, key);\n    return data !== null && data !== void 0 ? data : null;\n  }\n  /**\n   * Makes a smart query on the contract, returns the parsed JSON document.\n   *\n   * Promise is rejected when contract does not exist.\n   * Promise is rejected for invalid query format.\n   * Promise is rejected for invalid response format.\n   */\n\n\n  async queryContractSmart(address, queryMsg) {\n    try {\n      return await this.forceGetQueryClient().wasm.queryContractSmart(address, queryMsg);\n    } catch (error) {\n      if (error instanceof Error) {\n        if (error.message.startsWith(\"not found: contract\")) {\n          throw new Error(`No contract found at address \"${address}\"`);\n        } else {\n          throw error;\n        }\n      } else {\n        throw error;\n      }\n    }\n  }\n\n  async txsQuery(query) {\n    const results = await this.forceGetTmClient().txSearchAll({\n      query: query\n    });\n    return results.txs.map(tx => {\n      return {\n        height: tx.height,\n        hash: encoding_1.toHex(tx.hash).toUpperCase(),\n        code: tx.result.code,\n        rawLog: tx.result.log || \"\",\n        tx: tx.tx,\n        gasUsed: tx.result.gasUsed,\n        gasWanted: tx.result.gasWanted\n      };\n    });\n  }\n\n}\n\nexports.CosmWasmClient = CosmWasmClient;","map":{"version":3,"sources":["../src/cosmwasmclient.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CosmWasmClient = void 0;\nconst encoding_1 = require(\"@cosmjs/encoding\");\nconst math_1 = require(\"@cosmjs/math\");\nconst stargate_1 = require(\"@cosmjs/stargate\");\nconst tendermint_rpc_1 = require(\"@cosmjs/tendermint-rpc\");\nconst utils_1 = require(\"@cosmjs/utils\");\nconst types_1 = require(\"./codec/cosmwasm/wasm/v1beta1/types\");\nconst queries_1 = require(\"./queries\");\nclass CosmWasmClient {\n    constructor(tmClient) {\n        this.codesCache = new Map();\n        if (tmClient) {\n            this.tmClient = tmClient;\n            this.queryClient = stargate_1.QueryClient.withExtensions(tmClient, stargate_1.setupAuthExtension, stargate_1.setupBankExtension, queries_1.setupWasmExtension);\n        }\n    }\n    static async connect(endpoint) {\n        const tmClient = await tendermint_rpc_1.Tendermint34Client.connect(endpoint);\n        return new CosmWasmClient(tmClient);\n    }\n    getTmClient() {\n        return this.tmClient;\n    }\n    forceGetTmClient() {\n        if (!this.tmClient) {\n            throw new Error(\"Tendermint client not available. You cannot use online functionality in offline mode.\");\n        }\n        return this.tmClient;\n    }\n    getQueryClient() {\n        return this.queryClient;\n    }\n    forceGetQueryClient() {\n        if (!this.queryClient) {\n            throw new Error(\"Query client not available. You cannot use online functionality in offline mode.\");\n        }\n        return this.queryClient;\n    }\n    async getChainId() {\n        if (!this.chainId) {\n            const response = await this.forceGetTmClient().status();\n            const chainId = response.nodeInfo.network;\n            if (!chainId)\n                throw new Error(\"Chain ID must not be empty\");\n            this.chainId = chainId;\n        }\n        return this.chainId;\n    }\n    async getHeight() {\n        const status = await this.forceGetTmClient().status();\n        return status.syncInfo.latestBlockHeight;\n    }\n    async getAccount(searchAddress) {\n        try {\n            const account = await this.forceGetQueryClient().auth.account(searchAddress);\n            return account ? stargate_1.accountFromAny(account) : null;\n        }\n        catch (error) {\n            if (/rpc error: code = NotFound/i.test(error)) {\n                return null;\n            }\n            throw error;\n        }\n    }\n    async getSequence(address) {\n        const account = await this.getAccount(address);\n        if (!account) {\n            throw new Error(\"Account does not exist on chain. Send some tokens there before trying to query sequence.\");\n        }\n        return {\n            accountNumber: account.accountNumber,\n            sequence: account.sequence,\n        };\n    }\n    async getBlock(height) {\n        const response = await this.forceGetTmClient().block(height);\n        return {\n            id: encoding_1.toHex(response.blockId.hash).toUpperCase(),\n            header: {\n                version: {\n                    block: new math_1.Uint53(response.block.header.version.block).toString(),\n                    app: new math_1.Uint53(response.block.header.version.app).toString(),\n                },\n                height: response.block.header.height,\n                chainId: response.block.header.chainId,\n                time: tendermint_rpc_1.toRfc3339WithNanoseconds(response.block.header.time),\n            },\n            txs: response.block.txs,\n        };\n    }\n    async getBalance(address, searchDenom) {\n        return this.forceGetQueryClient().bank.balance(address, searchDenom);\n    }\n    async getTx(id) {\n        var _a;\n        const results = await this.txsQuery(`tx.hash='${id}'`);\n        return (_a = results[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    async searchTx(query, filter = {}) {\n        const minHeight = filter.minHeight || 0;\n        const maxHeight = filter.maxHeight || Number.MAX_SAFE_INTEGER;\n        if (maxHeight < minHeight)\n            return []; // optional optimization\n        function withFilters(originalQuery) {\n            return `${originalQuery} AND tx.height>=${minHeight} AND tx.height<=${maxHeight}`;\n        }\n        let txs;\n        if (stargate_1.isSearchByHeightQuery(query)) {\n            txs =\n                query.height >= minHeight && query.height <= maxHeight\n                    ? await this.txsQuery(`tx.height=${query.height}`)\n                    : [];\n        }\n        else if (stargate_1.isSearchBySentFromOrToQuery(query)) {\n            const sentQuery = withFilters(`message.module='bank' AND transfer.sender='${query.sentFromOrTo}'`);\n            const receivedQuery = withFilters(`message.module='bank' AND transfer.recipient='${query.sentFromOrTo}'`);\n            const [sent, received] = await Promise.all([sentQuery, receivedQuery].map((rawQuery) => this.txsQuery(rawQuery)));\n            const sentHashes = sent.map((t) => t.hash);\n            txs = [...sent, ...received.filter((t) => !sentHashes.includes(t.hash))];\n        }\n        else if (stargate_1.isSearchByTagsQuery(query)) {\n            const rawQuery = withFilters(query.tags.map((t) => `${t.key}='${t.value}'`).join(\" AND \"));\n            txs = await this.txsQuery(rawQuery);\n        }\n        else {\n            throw new Error(\"Unknown query type\");\n        }\n        const filtered = txs.filter((tx) => tx.height >= minHeight && tx.height <= maxHeight);\n        return filtered;\n    }\n    disconnect() {\n        if (this.tmClient)\n            this.tmClient.disconnect();\n    }\n    /**\n     * Broadcasts a signed transaction to the network and monitors its inclusion in a block.\n     *\n     * If broadcasting is rejected by the node for some reason (e.g. because of a CheckTx failure),\n     * an error is thrown.\n     *\n     * If the transaction is not included in a block before the provided timeout, this errors with a `TimeoutError`.\n     *\n     * If the transaction is included in a block, a `BroadcastTxResponse` is returned. The caller then\n     * usually needs to check for execution success or failure.\n     */\n    // NOTE: This method is tested against slow chains and timeouts in the @cosmjs/stargate package.\n    // Make sure it is kept in sync!\n    async broadcastTx(tx, timeoutMs = 60000, pollIntervalMs = 3000) {\n        let timedOut = false;\n        const txPollTimeout = setTimeout(() => {\n            timedOut = true;\n        }, timeoutMs);\n        const pollForTx = async (txId) => {\n            if (timedOut) {\n                throw new stargate_1.TimeoutError(`Transaction with ID ${txId} was submitted but was not yet found on the chain. You might want to check later.`, txId);\n            }\n            await utils_1.sleep(pollIntervalMs);\n            const result = await this.getTx(txId);\n            return result\n                ? {\n                    code: result.code,\n                    height: result.height,\n                    rawLog: result.rawLog,\n                    transactionHash: txId,\n                    gasUsed: result.gasUsed,\n                    gasWanted: result.gasWanted,\n                }\n                : pollForTx(txId);\n        };\n        const broadcasted = await this.forceGetTmClient().broadcastTxSync({ tx });\n        if (broadcasted.code) {\n            throw new Error(`Broadcasting transaction failed with code ${broadcasted.code} (codespace: ${broadcasted.codeSpace}). Log: ${broadcasted.log}`);\n        }\n        const transactionId = encoding_1.toHex(broadcasted.hash).toUpperCase();\n        return new Promise((resolve, reject) => pollForTx(transactionId).then((value) => {\n            clearTimeout(txPollTimeout);\n            resolve(value);\n        }, (error) => {\n            clearTimeout(txPollTimeout);\n            reject(error);\n        }));\n    }\n    async getCodes() {\n        const { codeInfos } = await this.forceGetQueryClient().wasm.listCodeInfo();\n        return (codeInfos || []).map((entry) => {\n            utils_1.assert(entry.creator && entry.codeId && entry.dataHash, \"entry incomplete\");\n            return {\n                id: entry.codeId.toNumber(),\n                creator: entry.creator,\n                checksum: encoding_1.toHex(entry.dataHash),\n                source: entry.source || undefined,\n                builder: entry.builder || undefined,\n            };\n        });\n    }\n    async getCodeDetails(codeId) {\n        const cached = this.codesCache.get(codeId);\n        if (cached)\n            return cached;\n        const { codeInfo, data } = await this.forceGetQueryClient().wasm.getCode(codeId);\n        utils_1.assert(codeInfo && codeInfo.codeId && codeInfo.creator && codeInfo.dataHash && data, \"codeInfo missing or incomplete\");\n        const codeDetails = {\n            id: codeInfo.codeId.toNumber(),\n            creator: codeInfo.creator,\n            checksum: encoding_1.toHex(codeInfo.dataHash),\n            source: codeInfo.source || undefined,\n            builder: codeInfo.builder || undefined,\n            data: data,\n        };\n        this.codesCache.set(codeId, codeDetails);\n        return codeDetails;\n    }\n    async getContracts(codeId) {\n        // TODO: handle pagination - accept as arg or auto-loop\n        const { contracts } = await this.forceGetQueryClient().wasm.listContractsByCodeId(codeId);\n        return contracts;\n    }\n    /**\n     * Throws an error if no contract was found at the address\n     */\n    async getContract(address) {\n        const { address: retrievedAddress, contractInfo } = await this.forceGetQueryClient().wasm.getContractInfo(address);\n        if (!contractInfo)\n            throw new Error(`No contract found at address \"${address}\"`);\n        utils_1.assert(retrievedAddress, \"address missing\");\n        utils_1.assert(contractInfo.codeId && contractInfo.creator && contractInfo.label, \"contractInfo incomplete\");\n        return {\n            address: retrievedAddress,\n            codeId: contractInfo.codeId.toNumber(),\n            creator: contractInfo.creator,\n            admin: contractInfo.admin || undefined,\n            label: contractInfo.label,\n        };\n    }\n    /**\n     * Throws an error if no contract was found at the address\n     */\n    async getContractCodeHistory(address) {\n        const result = await this.forceGetQueryClient().wasm.getContractCodeHistory(address);\n        if (!result)\n            throw new Error(`No contract history found for address \"${address}\"`);\n        const operations = {\n            [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_INIT]: \"Init\",\n            [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_GENESIS]: \"Genesis\",\n            [types_1.ContractCodeHistoryOperationType.CONTRACT_CODE_HISTORY_OPERATION_TYPE_MIGRATE]: \"Migrate\",\n        };\n        return (result.entries || []).map((entry) => {\n            utils_1.assert(entry.operation && entry.codeId && entry.msg);\n            return {\n                operation: operations[entry.operation],\n                codeId: entry.codeId.toNumber(),\n                msg: JSON.parse(encoding_1.fromAscii(entry.msg)),\n            };\n        });\n    }\n    /**\n     * Returns the data at the key if present (raw contract dependent storage data)\n     * or null if no data at this key.\n     *\n     * Promise is rejected when contract does not exist.\n     */\n    async queryContractRaw(address, key) {\n        // just test contract existence\n        await this.getContract(address);\n        const { data } = await this.forceGetQueryClient().wasm.queryContractRaw(address, key);\n        return data !== null && data !== void 0 ? data : null;\n    }\n    /**\n     * Makes a smart query on the contract, returns the parsed JSON document.\n     *\n     * Promise is rejected when contract does not exist.\n     * Promise is rejected for invalid query format.\n     * Promise is rejected for invalid response format.\n     */\n    async queryContractSmart(address, queryMsg) {\n        try {\n            return await this.forceGetQueryClient().wasm.queryContractSmart(address, queryMsg);\n        }\n        catch (error) {\n            if (error instanceof Error) {\n                if (error.message.startsWith(\"not found: contract\")) {\n                    throw new Error(`No contract found at address \"${address}\"`);\n                }\n                else {\n                    throw error;\n                }\n            }\n            else {\n                throw error;\n            }\n        }\n    }\n    async txsQuery(query) {\n        const results = await this.forceGetTmClient().txSearchAll({ query: query });\n        return results.txs.map((tx) => {\n            return {\n                height: tx.height,\n                hash: encoding_1.toHex(tx.hash).toUpperCase(),\n                code: tx.result.code,\n                rawLog: tx.result.log || \"\",\n                tx: tx.tx,\n                gasUsed: tx.result.gasUsed,\n                gasWanted: tx.result.gasWanted,\n            };\n        });\n    }\n}\nexports.CosmWasmClient = CosmWasmClient;\n//# sourceMappingURL=cosmwasmclient.js.map"]},"metadata":{},"sourceType":"script"}