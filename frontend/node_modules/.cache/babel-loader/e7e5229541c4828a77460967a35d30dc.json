{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.lastValue = exports.asArray = exports.countStream = exports.Reducer = void 0; // Reducer takes a stream of events T and a ReducerFunc, that\n// materializes a state of type U.\n\nvar Reducer = /*#__PURE__*/function () {\n  function Reducer(stream, reducer, initState) {\n    var _this = this;\n\n    _classCallCheck(this, Reducer);\n\n    this.stream = stream;\n    this.reducer = reducer;\n    this.state = initState;\n    this.completed = new Promise(function (resolve, reject) {\n      var subscription = _this.stream.subscribe({\n        next: function next(evt) {\n          _this.state = _this.reducer(_this.state, evt);\n        },\n        complete: function complete() {\n          resolve(); // this must happen after resolve, to ensure stream.subscribe() has finished\n\n          subscription.unsubscribe();\n        },\n        error: function error(err) {\n          reject(err); // the stream already closed on error, but unsubscribe to be safe\n\n          subscription.unsubscribe();\n        }\n      });\n    });\n  } // value returns current materialized state\n\n\n  _createClass(Reducer, [{\n    key: \"value\",\n    value: function value() {\n      return this.state;\n    } // finished resolves on completed stream, rejects on stream error\n\n  }, {\n    key: \"finished\",\n    value: function () {\n      var _finished = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", this.completed);\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function finished() {\n        return _finished.apply(this, arguments);\n      }\n\n      return finished;\n    }()\n  }]);\n\n  return Reducer;\n}();\n\nexports.Reducer = Reducer;\n\nfunction increment(sum, _) {\n  return sum + 1;\n} // countStream returns a reducer that contains current count\n// of events on the stream\n\n\nfunction countStream(stream) {\n  return new Reducer(stream, increment, 0);\n}\n\nexports.countStream = countStream;\n\nfunction append(list, evt) {\n  return [].concat(_toConsumableArray(list), [evt]);\n} // asArray maintains an array containing all events that have\n// occurred on the stream\n\n\nfunction asArray(stream) {\n  return new Reducer(stream, append, []);\n}\n\nexports.asArray = asArray;\n\nfunction last(_, event) {\n  return event;\n} // lastValue returns the last value read from the stream, or undefined if no values sent\n\n\nfunction lastValue(stream) {\n  return new Reducer(stream, last, undefined);\n}\n\nexports.lastValue = lastValue;","map":null,"metadata":{},"sourceType":"script"}