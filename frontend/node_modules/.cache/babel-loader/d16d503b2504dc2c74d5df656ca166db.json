{"ast":null,"code":"\"use strict\";\n\nvar _toConsumableArray = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeMultisignedTx = exports.makeCompactBitArray = void 0;\n\nvar amino_1 = require(\"@cosmjs/amino\");\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar proto_signing_1 = require(\"@cosmjs/proto-signing\");\n\nvar long_1 = __importDefault(require(\"long\"));\n\nvar multisig_1 = require(\"./codec/cosmos/crypto/multisig/v1beta1/multisig\");\n\nvar signing_1 = require(\"./codec/cosmos/tx/signing/v1beta1/signing\");\n\nvar tx_1 = require(\"./codec/cosmos/tx/v1beta1/tx\");\n\nvar tx_2 = require(\"./codec/cosmos/tx/v1beta1/tx\");\n\nfunction makeCompactBitArray(bits) {\n  var byteCount = Math.ceil(bits.length / 8);\n  var extraBits = bits.length - Math.floor(bits.length / 8) * 8;\n  var bytes = new Uint8Array(byteCount); // zero-filled\n\n  bits.forEach(function (value, index) {\n    var bytePos = Math.floor(index / 8);\n    var bitPos = index % 8; // eslint-disable-next-line no-bitwise\n\n    if (value) bytes[bytePos] |= 1 << 8 - 1 - bitPos;\n  });\n  return multisig_1.CompactBitArray.fromPartial({\n    elems: bytes,\n    extraBitsStored: extraBits\n  });\n}\n\nexports.makeCompactBitArray = makeCompactBitArray;\n\nfunction makeMultisignedTx(multisigPubkey, sequence, fee, bodyBytes, signatures) {\n  var addresses = Array.from(signatures.keys());\n  var prefix = encoding_1.Bech32.decode(addresses[0]).prefix;\n  var signers = Array(multisigPubkey.value.pubkeys.length).fill(false);\n  var signaturesList = new Array();\n\n  for (var i = 0; i < multisigPubkey.value.pubkeys.length; i++) {\n    var signerAddress = amino_1.pubkeyToAddress(multisigPubkey.value.pubkeys[i], prefix);\n    var signature = signatures.get(signerAddress);\n\n    if (signature) {\n      signers[i] = true;\n      signaturesList.push(signature);\n    }\n  }\n\n  var signerInfo = {\n    publicKey: proto_signing_1.encodePubkey(multisigPubkey),\n    modeInfo: {\n      multi: {\n        bitarray: makeCompactBitArray(signers),\n        modeInfos: signaturesList.map(function (_) {\n          return {\n            single: {\n              mode: signing_1.SignMode.SIGN_MODE_LEGACY_AMINO_JSON\n            }\n          };\n        })\n      }\n    },\n    sequence: long_1.default.fromNumber(sequence)\n  };\n  var authInfo = tx_1.AuthInfo.fromPartial({\n    signerInfos: [signerInfo],\n    fee: {\n      amount: _toConsumableArray(fee.amount),\n      gasLimit: long_1.default.fromString(fee.gas)\n    }\n  });\n  var authInfoBytes = tx_1.AuthInfo.encode(authInfo).finish();\n  var signedTx = tx_2.TxRaw.fromPartial({\n    bodyBytes: bodyBytes,\n    authInfoBytes: authInfoBytes,\n    signatures: [multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({\n      signatures: signaturesList\n    })).finish()]\n  });\n  return signedTx;\n}\n\nexports.makeMultisignedTx = makeMultisignedTx;","map":null,"metadata":{},"sourceType":"script"}