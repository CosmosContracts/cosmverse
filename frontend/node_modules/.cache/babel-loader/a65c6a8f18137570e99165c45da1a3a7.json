{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport { useBoolean, useCallbackRef, useControllableState, useId, useLatestRef, usePanGesture, useUpdateEffect } from \"@chakra-ui/hooks\";\nimport { mergeRefs } from \"@chakra-ui/react-utils\";\nimport { ariaAttr, callAllHandlers, clampValue, dataAttr, focus, normalizeEventKey, percentToValue, roundValueToStep, valueToPercent } from \"@chakra-ui/utils\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport { getIds, getIsReversed, getStyles, orient } from \"./slider-utils\";\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\n\nexport function useRangeSlider(props) {\n  var {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0\n  } = props,\n      htmlProps = _objectWithoutPropertiesLoose(props, [\"min\", \"max\", \"onChange\", \"value\", \"defaultValue\", \"isReversed\", \"direction\", \"orientation\", \"id\", \"isDisabled\", \"isReadOnly\", \"onChangeStart\", \"onChangeEnd\", \"step\", \"getAriaValueText\", \"aria-valuetext\", \"aria-label\", \"aria-labelledby\", \"name\", \"focusThumbOnChange\", \"minStepsBetweenThumbs\"]);\n\n  var onChangeStart = useCallbackRef(onChangeStartProp);\n  var onChangeEnd = useCallbackRef(onChangeEndProp);\n  var getAriaValueText = useCallbackRef(getAriaValueTextProp);\n  var isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation\n  });\n  var [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue != null ? defaultValue : [25, 75],\n    onChange\n  });\n\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\"[range-slider] You passed an invalid value for `value` or `defaultValue`, expected `Array` but got `\" + typeof valueState + \"`\");\n  }\n\n  var [isDragging, setDragging] = useBoolean();\n  var [isFocused, setFocused] = useBoolean();\n  var [activeIndex, setActiveIndex] = useState(-1);\n  var eventSourceRef = useRef(null);\n  var isInteractive = !(isDisabled || isReadOnly);\n  var initialValue = useRef(valueState);\n  var value = valueState.map(val => clampValue(val, min, max));\n  var valueRef = useLatestRef(value);\n  var spacing = minStepsBetweenThumbs * step;\n  var valueBounds = getValueBounds(value, min, max, spacing);\n  var reversedValue = value.map(val => max - val + min);\n  var thumbValues = isReversed ? reversedValue : value;\n  var thumbPercents = thumbValues.map(val => valueToPercent(val, min, max));\n  var isVertical = orientation === \"vertical\";\n  var [thumbRects, setThumbRects] = useState(Array.from({\n    length: value.length\n  }).map(() => ({\n    width: 0,\n    height: 0\n  })));\n  useEffect(() => {\n    var _rootRef$current;\n\n    if (!rootRef.current) return;\n    var thumbs = Array.from((_rootRef$current = rootRef.current) == null ? void 0 : _rootRef$current.querySelectorAll(\"[role=slider]\"));\n    var rects = thumbs.map(el => ({\n      width: el.offsetWidth,\n      height: el.offsetHeight\n    }));\n    if (rects.length) setThumbRects(rects);\n  }, []);\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n\n  var trackRef = useRef(null);\n  var rootRef = useRef(null);\n  var uuid = useId(idProp);\n  var ids = getIds(uuid);\n  var getValueFromPointer = useCallback(event => {\n    var _event$touches$, _event$touches;\n\n    if (!trackRef.current) return;\n    eventSourceRef.current = \"pointer\";\n    var rect = trackRef.current.getBoundingClientRect();\n    var {\n      clientX,\n      clientY\n    } = (_event$touches$ = (_event$touches = event.touches) == null ? void 0 : _event$touches[0]) != null ? _event$touches$ : event;\n    var diff = isVertical ? rect.bottom - clientY : clientX - rect.left;\n    var length = isVertical ? rect.height : rect.width;\n    var percent = diff / length;\n    if (isReversed) percent = 1 - percent;\n    return percentToValue(percent, min, max);\n  }, [isVertical, isReversed, max, min]);\n  var tenSteps = (max - min) / 10;\n  var oneStep = step || (max - min) / 100;\n  var actions = useMemo(() => ({\n    setValueAtIndex: (index, val) => {\n      if (!isInteractive) return;\n      var bounds = valueBounds[index];\n      val = parseFloat(roundValueToStep(val, bounds.min, oneStep));\n      val = clampValue(val, bounds.min, bounds.max);\n      var next = [...value];\n      next[index] = val;\n      setValue(next);\n    },\n    setActiveIndex,\n    stepUp: function stepUp(index, step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var valueAtIndex = value[index];\n      var next = isReversed ? valueAtIndex - step : valueAtIndex + step;\n      actions.setValueAtIndex(index, next);\n    },\n    stepDown: function stepDown(index, step) {\n      if (step === void 0) {\n        step = oneStep;\n      }\n\n      var valueAtIndex = value[index];\n      var next = isReversed ? valueAtIndex + step : valueAtIndex - step;\n      actions.setValueAtIndex(index, next);\n    },\n    reset: () => setValue(initialValue.current)\n  }), [oneStep, value, isReversed, setValue, isInteractive, valueBounds]);\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n\n  var onKeyDown = useCallback(event => {\n    var eventKey = normalizeEventKey(event);\n    var keyMap = {\n      ArrowRight: () => actions.stepUp(activeIndex),\n      ArrowUp: () => actions.stepUp(activeIndex),\n      ArrowLeft: () => actions.stepDown(activeIndex),\n      ArrowDown: () => actions.stepDown(activeIndex),\n      PageUp: () => actions.stepUp(activeIndex, tenSteps),\n      PageDown: () => actions.stepDown(activeIndex, tenSteps),\n      Home: () => {\n        var {\n          min: value\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value);\n      },\n      End: () => {\n        var {\n          max: value\n        } = valueBounds[activeIndex];\n        actions.setValueAtIndex(activeIndex, value);\n      }\n    };\n    var action = keyMap[eventKey];\n\n    if (action) {\n      event.preventDefault();\n      event.stopPropagation();\n      action(event);\n      eventSourceRef.current = \"keyboard\";\n    }\n  }, [actions, activeIndex, tenSteps, valueBounds]);\n  /**\n   * Compute styles for all component parts.\n   */\n\n  var {\n    getThumbStyle,\n    rootStyle,\n    trackStyle,\n    innerTrackStyle\n  } = useMemo(() => getStyles({\n    isReversed,\n    orientation,\n    thumbRects,\n    thumbPercents\n  }), [isReversed, orientation, thumbPercents, thumbRects]);\n  var focusThumb = useCallback(index => {\n    var idx = index != null ? index : activeIndex;\n\n    if (idx !== -1 && focusThumbOnChange) {\n      var _rootRef$current2;\n\n      var id = ids.getThumb(idx);\n      var thumb = (_rootRef$current2 = rootRef.current) == null ? void 0 : _rootRef$current2.ownerDocument.getElementById(id);\n\n      if (thumb) {\n        setTimeout(() => focus(thumb));\n      }\n    }\n  }, [focusThumbOnChange, activeIndex, ids]);\n  useUpdateEffect(() => {\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    }\n  }, [value, onChangeEnd]);\n\n  var onPanSessionStart = event => {\n    var pointValue = getValueFromPointer(event) || 0;\n    var distances = value.map(val => Math.abs(val - pointValue));\n    var isThumbStacked = new Set(distances).size !== distances.length;\n    var closest = Math.min(...distances);\n    var index = distances.indexOf(closest); // when two thumbs are stacked and the user clicks at a point larger than\n    // their values, pick the next closest thumb\n\n    if (isThumbStacked && pointValue > value[index]) {\n      index++;\n    }\n\n    setActiveIndex(index);\n    actions.setValueAtIndex(index, pointValue);\n    focusThumb(index);\n  };\n\n  var onPan = event => {\n    if (activeIndex == -1) return;\n    var pointValue = getValueFromPointer(event) || 0;\n    setActiveIndex(activeIndex);\n    actions.setValueAtIndex(activeIndex, pointValue);\n    focusThumb(activeIndex);\n  };\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return;\n      setDragging.on();\n      onPanSessionStart(event);\n      onChangeStart == null ? void 0 : onChangeStart(valueRef.current);\n    },\n\n    onPanSessionEnd() {\n      if (!isInteractive) return;\n      setDragging.off();\n      onChangeEnd == null ? void 0 : onChangeEnd(valueRef.current);\n    },\n\n    onPan(event) {\n      if (!isInteractive) return;\n      onPan(event);\n    }\n\n  });\n  var getRootProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, htmlProps, {\n      id: ids.root,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: _extends({}, props.style, rootStyle)\n    });\n  }, [htmlProps, isDisabled, isFocused, rootStyle, ids]);\n  var getTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref: mergeRefs(ref, trackRef),\n      id: ids.track,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: _extends({}, props.style, trackStyle)\n    });\n  }, [isDisabled, trackStyle, ids]);\n  var getInnerTrackProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      id: ids.innerTrack,\n      style: _extends({}, props.style, innerTrackStyle)\n    });\n  }, [innerTrackStyle, ids]);\n  var getThumbProps = useCallback(function (props, ref) {\n    var _getAriaValueText;\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    var {\n      index\n    } = props,\n        rest = _objectWithoutPropertiesLoose(props, [\"index\"]);\n\n    var _value = value[index];\n\n    if (_value == null) {\n      throw new TypeError(\"[range-slider > thumb] Cannot find value at index `\" + index + \"`. The `value` or `defaultValue` length is : \" + value.length);\n    }\n\n    var bounds = valueBounds[index];\n    return _extends({}, rest, {\n      ref,\n      role: \"slider\",\n      tabIndex: isInteractive ? 0 : undefined,\n      id: ids.getThumb(index),\n      \"data-active\": dataAttr(isDragging && activeIndex === index),\n      \"aria-valuetext\": (_getAriaValueText = getAriaValueText == null ? void 0 : getAriaValueText(_value)) != null ? _getAriaValueText : ariaValueText == null ? void 0 : ariaValueText[index],\n      \"aria-valuemin\": bounds.min,\n      \"aria-valuemax\": bounds.max,\n      \"aria-valuenow\": _value,\n      \"aria-orientation\": orientation,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"aria-readonly\": ariaAttr(isReadOnly),\n      \"aria-label\": ariaLabel == null ? void 0 : ariaLabel[index],\n      \"aria-labelledby\": ariaLabel != null && ariaLabel[index] ? undefined : ariaLabelledBy == null ? void 0 : ariaLabelledBy[index],\n      style: _extends({}, props.style, getThumbStyle(index)),\n      onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n      onFocus: callAllHandlers(props.onFocus, () => {\n        setFocused.on();\n        setActiveIndex(index);\n      }),\n      onBlur: callAllHandlers(props.onBlur, () => {\n        setFocused.off();\n        setActiveIndex(-1);\n      })\n    });\n  }, [ids, value, valueBounds, isInteractive, isDragging, activeIndex, getAriaValueText, ariaValueText, orientation, isDisabled, isReadOnly, ariaLabel, ariaLabelledBy, getThumbStyle, onKeyDown, setFocused]);\n  var getOutputProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    return _extends({}, props, {\n      ref,\n      id: ids.output,\n      htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n      \"aria-live\": \"off\"\n    });\n  }, [ids, value]);\n  var getMarkerProps = useCallback(function (props, ref) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    var {\n      value: v\n    } = props,\n        rest = _objectWithoutPropertiesLoose(props, [\"value\"]);\n\n    var isInRange = !(v < min || v > max);\n    var isHighlighted = v >= value[0] && v <= value[value.length - 1];\n    var percent = valueToPercent(v, min, max);\n    percent = isReversed ? 100 - percent : percent;\n\n    var markerStyle = _extends({\n      position: \"absolute\",\n      pointerEvents: \"none\"\n    }, orient({\n      orientation,\n      vertical: {\n        bottom: percent + \"%\"\n      },\n      horizontal: {\n        left: percent + \"%\"\n      }\n    }));\n\n    return _extends({}, rest, {\n      ref,\n      id: ids.getMarker(props.value),\n      role: \"presentation\",\n      \"aria-hidden\": true,\n      \"data-disabled\": dataAttr(isDisabled),\n      \"data-invalid\": dataAttr(!isInRange),\n      \"data-highlighted\": dataAttr(isHighlighted),\n      style: _extends({}, props.style, markerStyle)\n    });\n  }, [isDisabled, isReversed, max, min, orientation, value, ids]);\n  var getInputProps = useCallback(function (props, ref) {\n    if (ref === void 0) {\n      ref = null;\n    }\n\n    var {\n      index\n    } = props,\n        rest = _objectWithoutPropertiesLoose(props, [\"index\"]);\n\n    return _extends({}, rest, {\n      ref,\n      id: ids.getInput(index),\n      type: \"hidden\",\n      value: value[index],\n      name: Array.isArray(name) ? name[index] : name + \"-\" + index\n    });\n  }, [name, value, ids]);\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n      getThumbPercent: i => thumbPercents[i],\n      getThumbMinValue: i => valueBounds[i].min,\n      getThumbMaxValue: i => valueBounds[i].max\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps\n  };\n}\n\nvar getValueBounds = (arr, min, max, spacing) => arr.map((v, i) => {\n  var _min = i === 0 ? min : arr[i - 1] + spacing;\n\n  var _max = i === arr.length - 1 ? max : arr[i + 1] - spacing;\n\n  return {\n    min: _min,\n    max: _max\n  };\n});","map":{"version":3,"sources":["../../src/use-range-slider.ts"],"names":["min","max","value","isReversed","direction","orientation","id","onChangeStart","onChangeEnd","step","getAriaValueText","focusThumbOnChange","minStepsBetweenThumbs","htmlProps","useCallbackRef","getIsReversed","useControllableState","defaultValue","onChange","Array","useBoolean","useState","eventSourceRef","useRef","isInteractive","isDisabled","initialValue","valueState","val","clampValue","valueRef","useLatestRef","spacing","valueBounds","getValueBounds","reversedValue","thumbValues","thumbPercents","valueToPercent","isVertical","length","width","height","useEffect","rootRef","thumbs","rects","el","offsetHeight","setThumbRects","trackRef","uuid","useId","ids","getIds","getValueFromPointer","useCallback","event","rect","clientY","diff","clientX","percent","percentToValue","tenSteps","oneStep","actions","useMemo","setValueAtIndex","bounds","parseFloat","roundValueToStep","next","setValue","stepUp","valueAtIndex","stepDown","reset","onKeyDown","eventKey","normalizeEventKey","keyMap","ArrowRight","ArrowUp","ArrowLeft","ArrowDown","PageUp","PageDown","Home","End","action","innerTrackStyle","getStyles","focusThumb","index","idx","thumb","setTimeout","focus","useUpdateEffect","onPanSessionStart","pointValue","distances","Math","isThumbStacked","closest","setActiveIndex","onPan","activeIndex","usePanGesture","setDragging","onPanSessionEnd","getRootProps","props","ref","mergeRefs","tabIndex","ariaAttr","dataAttr","style","getTrackProps","getInnerTrackProps","getThumbProps","rest","_value","role","isDragging","ariaValueText","ariaLabel","ariaLabelledBy","getThumbStyle","callAllHandlers","onFocus","setFocused","onBlur","getOutputProps","htmlFor","getMarkerProps","v","isInRange","isHighlighted","markerStyle","position","pointerEvents","orient","vertical","bottom","horizontal","left","getInputProps","type","name","state","getThumbPercent","i","getThumbMinValue","getThumbMaxValue","_min","arr","_max"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,UAAA,EAAA,cAAA,EAAA,oBAAA,EAAA,KAAA,EAAA,YAAA,EAAA,aAAA,EAAA,eAAA,QAAA,kBAAA;AASA,SAAA,SAAA,QAAA,wBAAA;AACA,SAAA,QAAA,EAAA,eAAA,EAAA,UAAA,EAAA,QAAA,EAAA,KAAA,EAAA,iBAAA,EAAA,cAAA,EAAA,gBAAA,EAAA,cAAA,QAAA,kBAAA;AAYA,SAAA,WAAA,EAAA,SAAA,EAAA,OAAA,EAAA,MAAA,EAAA,QAAA,QAAA,OAAA;AACA,SAAA,MAAA,EAAA,aAAA,EAAA,SAAA,EAAA,MAAA,QAAA,gBAAA;AAqGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,OAAO,SAAA,cAAA,CAAA,KAAA,EAAoD;AACzD,MAAM;AACJA,IAAAA,GAAG,GADC,CAAA;AAEJC,IAAAA,GAAG,GAFC,GAAA;AAAA,IAAA,QAAA;AAIJC,IAAAA,KAAK,EAJD,SAAA;AAAA,IAAA,YAAA;AAMJC,IAAAA,UAAU,EANN,cAAA;AAOJC,IAAAA,SAAS,GAPL,KAAA;AAQJC,IAAAA,WAAW,GARP,YAAA;AASJC,IAAAA,EAAE,EATE,MAAA;AAAA,IAAA,UAAA;AAAA,IAAA,UAAA;AAYJC,IAAAA,aAAa,EAZT,iBAAA;AAaJC,IAAAA,WAAW,EAbP,eAAA;AAcJC,IAAAA,IAAI,GAdA,CAAA;AAeJC,IAAAA,gBAAgB,EAfZ,oBAAA;AAgBJ,sBAhBI,aAAA;AAiBJ,kBAjBI,SAAA;AAkBJ,uBAlBI,cAAA;AAAA,IAAA,IAAA;AAoBJC,IAAAA,kBAAkB,GApBd,IAAA;AAqBJC,IAAAA,qBAAqB,GAAG;AArBpB,MAAN,KAAA;AAAA,MAsBKC,SAtBL,GAAA,6BAAA,CAAA,KAAA,EAAA,CAAA,KAAA,EAAA,KAAA,EAAA,UAAA,EAAA,OAAA,EAAA,cAAA,EAAA,YAAA,EAAA,WAAA,EAAA,aAAA,EAAA,IAAA,EAAA,YAAA,EAAA,YAAA,EAAA,eAAA,EAAA,aAAA,EAAA,MAAA,EAAA,kBAAA,EAAA,gBAAA,EAAA,YAAA,EAAA,iBAAA,EAAA,MAAA,EAAA,oBAAA,EAAA,uBAAA,CAAA,CAAA;;AAyBA,MAAMN,aAAa,GAAGO,cAAc,CAApC,iBAAoC,CAApC;AACA,MAAMN,WAAW,GAAGM,cAAc,CAAlC,eAAkC,CAAlC;AACA,MAAMJ,gBAAgB,GAAGI,cAAc,CAAvC,oBAAuC,CAAvC;AAEA,MAAMX,UAAU,GAAGY,aAAa,CAAC;AAC/BZ,IAAAA,UAAU,EADqB,cAAA;AAAA,IAAA,SAAA;AAG/BE,IAAAA;AAH+B,GAAD,CAAhC;AAMA,MAAM,CAAA,UAAA,EAAA,QAAA,IAAyBW,oBAAoB,CAAC;AAClDd,IAAAA,KAAK,EAD6C,SAAA;AAElDe,IAAAA,YAAY,EAAEA,YAAF,IAAA,IAAEA,GAAF,YAAEA,GAAgB,CAAA,EAAA,EAFoB,EAEpB,CAFoB;AAGlDC,IAAAA;AAHkD,GAAD,CAAnD;;AAMA,MAAI,CAACC,KAAK,CAALA,OAAAA,CAAL,UAAKA,CAAL,EAAgC;AAC9B,UAAM,IAAA,SAAA,CAAA,yGAC0G,OAD1G,UAAA,GAAN,GAAM,CAAN;AAGD;;AAED,MAAM,CAAA,UAAA,EAAA,WAAA,IAA4BC,UAAlC,EAAA;AACA,MAAM,CAAA,SAAA,EAAA,UAAA,IAA0BA,UAAhC,EAAA;AACA,MAAM,CAAA,WAAA,EAAA,cAAA,IAAgCC,QAAQ,CAAC,CAA/C,CAA8C,CAA9C;AACA,MAAMC,cAAc,GAAGC,MAAM,CAA7B,IAA6B,CAA7B;AACA,MAAMC,aAAa,GAAG,EAAEC,UAAU,IAAlC,UAAsB,CAAtB;AAEA,MAAMC,YAAY,GAAGH,MAAM,CAA3B,UAA2B,CAA3B;AACA,MAAMrB,KAAK,GAAGyB,UAAU,CAAVA,GAAAA,CAAgBC,GAAD,IAASC,UAAU,CAAA,GAAA,EAAA,GAAA,EAAhD,GAAgD,CAAlCF,CAAd;AACA,MAAMG,QAAQ,GAAGC,YAAY,CAA7B,KAA6B,CAA7B;AAEA,MAAMC,OAAO,GAAGpB,qBAAqB,GAArC,IAAA;AACA,MAAMqB,WAAW,GAAGC,cAAc,CAAA,KAAA,EAAA,GAAA,EAAA,GAAA,EAAlC,OAAkC,CAAlC;AAEA,MAAMC,aAAa,GAAGjC,KAAK,CAALA,GAAAA,CAAW0B,GAAD,IAAS3B,GAAG,GAAHA,GAAAA,GAAzC,GAAsBC,CAAtB;AACA,MAAMkC,WAAW,GAAGjC,UAAU,GAAA,aAAA,GAA9B,KAAA;AAEA,MAAMkC,aAAa,GAAGD,WAAW,CAAXA,GAAAA,CAAiBR,GAAD,IAASU,cAAc,CAAA,GAAA,EAAA,GAAA,EAA7D,GAA6D,CAAvCF,CAAtB;AAEA,MAAMG,UAAU,GAAGlC,WAAW,KAA9B,UAAA;AAEA,MAAM,CAAA,UAAA,EAAA,aAAA,IAA8BgB,QAAQ,CAC1C,KAAK,CAAL,IAAA,CAAW;AAAEmB,IAAAA,MAAM,EAAEtC,KAAK,CAACsC;AAAhB,GAAX,EAAA,GAAA,CAAyC,OAAO;AAAEC,IAAAA,KAAK,EAAP,CAAA;AAAYC,IAAAA,MAAM,EAAE;AAApB,GAAP,CAAzC,CAD0C,CAA5C;AAIAC,EAAAA,SAAS,CAAC,MAAM;AAAA,QAAA,gBAAA;;AACd,QAAI,CAACC,OAAO,CAAZ,OAAA,EAAsB;AAEtB,QAAMC,MAAM,GAAG1B,KAAK,CAALA,IAAAA,CAAAA,CAAAA,gBAAAA,GACbyB,OAAO,CADMzB,OAAAA,KAAAA,IAAAA,GAAAA,KAAAA,CAAAA,GACbyB,gBAAAA,CAAAA,gBAAAA,CADF,eACEA,CADazB,CAAf;AAGA,QAAM2B,KAAK,GAAG,MAAM,CAAN,GAAA,CAAYC,EAAD,KAAS;AAChCN,MAAAA,KAAK,EAAEM,EAAE,CADuB,WAAA;AAEhCL,MAAAA,MAAM,EAAEK,EAAE,CAACC;AAFqB,KAAT,CAAX,CAAd;AAKA,QAAIF,KAAK,CAAT,MAAA,EAAkBG,aAAa,CAAbA,KAAa,CAAbA;AAXX,GAAA,EAATN,EAAS,CAATA;AAcA;AACF;AACA;;AACE,MAAMO,QAAQ,GAAG3B,MAAM,CAAvB,IAAuB,CAAvB;AACA,MAAMqB,OAAO,GAAGrB,MAAM,CAAtB,IAAsB,CAAtB;AAEA,MAAM4B,IAAI,GAAGC,KAAK,CAAlB,MAAkB,CAAlB;AACA,MAAMC,GAAG,GAAGC,MAAM,CAAlB,IAAkB,CAAlB;AAEA,MAAMC,mBAAmB,GAAGC,WAAW,CACpCC,KAAD,IAAW;AAAA,QAAA,eAAA,EAAA,cAAA;;AACT,QAAI,CAACP,QAAQ,CAAb,OAAA,EAAuB;AACvB5B,IAAAA,cAAc,CAAdA,OAAAA,GAAAA,SAAAA;AACA,QAAMoC,IAAI,GAAGR,QAAQ,CAARA,OAAAA,CAAb,qBAAaA,EAAb;AACA,QAAM;AAAA,MAAA,OAAA;AAAWS,MAAAA;AAAX,QAAA,CAAA,eAAA,GAAA,CAAA,cAAA,GAAuBF,KAAK,CAA5B,OAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAuBA,cAAAA,CAAvB,CAAuBA,CAAvB,KAAA,IAAA,GAAA,eAAA,GAAN,KAAA;AAEA,QAAMG,IAAI,GAAGrB,UAAU,GAAGmB,IAAI,CAAJA,MAAAA,GAAH,OAAA,GAA2BG,OAAO,GAAGH,IAAI,CAAhE,IAAA;AACA,QAAMlB,MAAM,GAAGD,UAAU,GAAGmB,IAAI,CAAP,MAAA,GAAiBA,IAAI,CAA9C,KAAA;AAEA,QAAII,OAAO,GAAGF,IAAI,GAAlB,MAAA;AACA,QAAA,UAAA,EAAgBE,OAAO,GAAG,IAAVA,OAAAA;AAEhB,WAAOC,cAAc,CAAA,OAAA,EAAA,GAAA,EAArB,GAAqB,CAArB;AAbmC,GAAA,EAerC,CAAA,UAAA,EAAA,UAAA,EAAA,GAAA,EAfF,GAeE,CAfqC,CAAvC;AAkBA,MAAMC,QAAQ,GAAG,CAAC/D,GAAG,GAAJ,GAAA,IAAjB,EAAA;AACA,MAAMgE,OAAO,GAAGxD,IAAI,IAAI,CAACR,GAAG,GAAJ,GAAA,IAAxB,GAAA;AAEA,MAAMiE,OAAO,GAAGC,OAAO,CACrB,OAAO;AACLC,IAAAA,eAAe,EAAE,CAAA,KAAA,EAAA,GAAA,KAAgC;AAC/C,UAAI,CAAJ,aAAA,EAAoB;AACpB,UAAMC,MAAM,GAAGpC,WAAW,CAA1B,KAA0B,CAA1B;AACAL,MAAAA,GAAG,GAAG0C,UAAU,CAACC,gBAAgB,CAAA,GAAA,EAAMF,MAAM,CAAZ,GAAA,EAAjCzC,OAAiC,CAAjB,CAAhBA;AACAA,MAAAA,GAAG,GAAGC,UAAU,CAAA,GAAA,EAAMwC,MAAM,CAAZ,GAAA,EAAkBA,MAAM,CAAxCzC,GAAgB,CAAhBA;AACA,UAAM4C,IAAI,GAAG,CAAC,GAAd,KAAa,CAAb;AACAA,MAAAA,IAAI,CAAJA,KAAI,CAAJA,GAAAA,GAAAA;AACAC,MAAAA,QAAQ,CAARA,IAAQ,CAARA;AARG,KAAA;AAAA,IAAA,cAAA;AAWLC,IAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,KAAA,EAAA,IAAA,EAAmC;AAAA,UAAnBjE,IAAmB,KAAA,KAAA,CAAA,EAAA;AAAnBA,QAAAA,IAAmB,GAAZwD,OAAPxD;AAAmB;;AACzC,UAAMkE,YAAY,GAAGzE,KAAK,CAA1B,KAA0B,CAA1B;AACA,UAAMsE,IAAI,GAAGrE,UAAU,GAAGwE,YAAY,GAAf,IAAA,GAAyBA,YAAY,GAA5D,IAAA;AACAT,MAAAA,OAAO,CAAPA,eAAAA,CAAAA,KAAAA,EAAAA,IAAAA;AAdG,KAAA;AAgBLU,IAAAA,QAAQ,EAAE,SAAA,QAAA,CAAA,KAAA,EAAA,IAAA,EAAmC;AAAA,UAAnBnE,IAAmB,KAAA,KAAA,CAAA,EAAA;AAAnBA,QAAAA,IAAmB,GAAZwD,OAAPxD;AAAmB;;AAC3C,UAAMkE,YAAY,GAAGzE,KAAK,CAA1B,KAA0B,CAA1B;AACA,UAAMsE,IAAI,GAAGrE,UAAU,GAAGwE,YAAY,GAAf,IAAA,GAAyBA,YAAY,GAA5D,IAAA;AACAT,MAAAA,OAAO,CAAPA,eAAAA,CAAAA,KAAAA,EAAAA,IAAAA;AAnBG,KAAA;AAqBLW,IAAAA,KAAK,EAAE,MAAMJ,QAAQ,CAAC/C,YAAY,CAAb,OAAA;AArBhB,GAAP,CADqB,EAwBrB,CAAA,OAAA,EAAA,KAAA,EAAA,UAAA,EAAA,QAAA,EAAA,aAAA,EAxBF,WAwBE,CAxBqB,CAAvB;AA2BA;AACF;AACA;AACA;;AACE,MAAMoD,SAAS,GAAGtB,WAAW,CAC1BC,KAAD,IAAgC;AAC9B,QAAMsB,QAAQ,GAAGC,iBAAiB,CAAlC,KAAkC,CAAlC;AACA,QAAMC,MAAmB,GAAG;AAC1BC,MAAAA,UAAU,EAAE,MAAMhB,OAAO,CAAPA,MAAAA,CADQ,WACRA,CADQ;AAE1BiB,MAAAA,OAAO,EAAE,MAAMjB,OAAO,CAAPA,MAAAA,CAFW,WAEXA,CAFW;AAG1BkB,MAAAA,SAAS,EAAE,MAAMlB,OAAO,CAAPA,QAAAA,CAHS,WAGTA,CAHS;AAI1BmB,MAAAA,SAAS,EAAE,MAAMnB,OAAO,CAAPA,QAAAA,CAJS,WAITA,CAJS;AAK1BoB,MAAAA,MAAM,EAAE,MAAMpB,OAAO,CAAPA,MAAAA,CAAAA,WAAAA,EALY,QAKZA,CALY;AAM1BqB,MAAAA,QAAQ,EAAE,MAAMrB,OAAO,CAAPA,QAAAA,CAAAA,WAAAA,EANU,QAMVA,CANU;AAO1BsB,MAAAA,IAAI,EAAE,MAAM;AACV,YAAM;AAAExF,UAAAA,GAAG,EAAEE;AAAP,YAAiB+B,WAAW,CAAlC,WAAkC,CAAlC;AACAiC,QAAAA,OAAO,CAAPA,eAAAA,CAAAA,WAAAA,EAAAA,KAAAA;AATwB,OAAA;AAW1BuB,MAAAA,GAAG,EAAE,MAAM;AACT,YAAM;AAAExF,UAAAA,GAAG,EAAEC;AAAP,YAAiB+B,WAAW,CAAlC,WAAkC,CAAlC;AACAiC,QAAAA,OAAO,CAAPA,eAAAA,CAAAA,WAAAA,EAAAA,KAAAA;AACD;AAdyB,KAA5B;AAiBA,QAAMwB,MAAM,GAAGT,MAAM,CAArB,QAAqB,CAArB;;AAEA,QAAA,MAAA,EAAY;AACVxB,MAAAA,KAAK,CAALA,cAAAA;AACAA,MAAAA,KAAK,CAALA,eAAAA;AACAiC,MAAAA,MAAM,CAANA,KAAM,CAANA;AACApE,MAAAA,cAAc,CAAdA,OAAAA,GAAAA,UAAAA;AACD;AA3BwB,GAAA,EA6B3B,CAAA,OAAA,EAAA,WAAA,EAAA,QAAA,EA7BF,WA6BE,CA7B2B,CAA7B;AAgCA;AACF;AACA;;AACE,MAAM;AAAA,IAAA,aAAA;AAAA,IAAA,SAAA;AAAA,IAAA,UAAA;AAAwCqE,IAAAA;AAAxC,MAA4DxB,OAAO,CACvE,MACEyB,SAAS,CAAC;AAAA,IAAA,UAAA;AAAA,IAAA,WAAA;AAAA,IAAA,UAAA;AAIRvD,IAAAA;AAJQ,GAAD,CAF4D,EAQvE,CAAA,UAAA,EAAA,WAAA,EAAA,aAAA,EARF,UAQE,CARuE,CAAzE;AAWA,MAAMwD,UAAU,GAAGrC,WAAW,CAC3BsC,KAAD,IAAoB;AAClB,QAAMC,GAAG,GAAGD,KAAH,IAAA,IAAGA,GAAH,KAAGA,GAAZ,WAAA;;AACA,QAAIC,GAAG,KAAK,CAARA,CAAAA,IAAJ,kBAAA,EAAsC;AAAA,UAAA,iBAAA;;AACpC,UAAMzF,EAAE,GAAG+C,GAAG,CAAHA,QAAAA,CAAX,GAAWA,CAAX;AACA,UAAM2C,KAAK,GAAA,CAAA,iBAAA,GAAGpD,OAAO,CAAV,OAAA,KAAA,IAAA,GAAA,KAAA,CAAA,GAAGA,iBAAAA,CAAAA,aAAAA,CAAAA,cAAAA,CAAd,EAAcA,CAAd;;AACA,UAAA,KAAA,EAAW;AACTqD,QAAAA,UAAU,CAAC,MAAMC,KAAK,CAAtBD,KAAsB,CAAZ,CAAVA;AACD;AACF;AATyB,GAAA,EAW5B,CAAA,kBAAA,EAAA,WAAA,EAXF,GAWE,CAX4B,CAA9B;AAcAE,EAAAA,eAAe,CAAC,MAAM;AACpB,QAAI7E,cAAc,CAAdA,OAAAA,KAAJ,UAAA,EAA2C;AACzCd,MAAAA,WAAW,IAAXA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,WAAW,CAAGsB,QAAQ,CAAtBtB,OAAW,CAAXA;AACD;AAHY,GAAA,EAIZ,CAAA,KAAA,EAJH2F,WAIG,CAJY,CAAfA;;AAMA,MAAMC,iBAAiB,GAAI3C,KAAD,IAA4B;AACpD,QAAM4C,UAAU,GAAG9C,mBAAmB,CAAnBA,KAAmB,CAAnBA,IAAnB,CAAA;AACA,QAAM+C,SAAS,GAAGpG,KAAK,CAALA,GAAAA,CAAW0B,GAAD,IAAS2E,IAAI,CAAJA,GAAAA,CAAS3E,GAAG,GAAjD,UAAqC2E,CAAnBrG,CAAlB;AACA,QAAMsG,cAAc,GAAG,IAAA,GAAA,CAAA,SAAA,EAAA,IAAA,KAA4BF,SAAS,CAA5D,MAAA;AACA,QAAMG,OAAO,GAAGF,IAAI,CAAJA,GAAAA,CAAS,GAAzB,SAAgBA,CAAhB;AACA,QAAIT,KAAK,GAAGQ,SAAS,CAATA,OAAAA,CALwC,OAKxCA,CAAZ,CALoD,CAMpD;AACA;;AACA,QAAIE,cAAc,IAAIH,UAAU,GAAGnG,KAAK,CAAxC,KAAwC,CAAxC,EAAiD;AAC/C4F,MAAAA,KAAK;AACN;;AACDY,IAAAA,cAAc,CAAdA,KAAc,CAAdA;AACAxC,IAAAA,OAAO,CAAPA,eAAAA,CAAAA,KAAAA,EAAAA,UAAAA;AACA2B,IAAAA,UAAU,CAAVA,KAAU,CAAVA;AAbF,GAAA;;AAgBA,MAAMc,KAAK,GAAIlD,KAAD,IAA4B;AACxC,QAAImD,WAAW,IAAI,CAAnB,CAAA,EAAuB;AACvB,QAAMP,UAAU,GAAG9C,mBAAmB,CAAnBA,KAAmB,CAAnBA,IAAnB,CAAA;AACAmD,IAAAA,cAAc,CAAdA,WAAc,CAAdA;AACAxC,IAAAA,OAAO,CAAPA,eAAAA,CAAAA,WAAAA,EAAAA,UAAAA;AACA2B,IAAAA,UAAU,CAAVA,WAAU,CAAVA;AALF,GAAA;;AAQAgB,EAAAA,aAAa,CAAA,OAAA,EAAU;AACrBT,IAAAA,iBAAiB,CAAA,KAAA,EAAQ;AACvB,UAAI,CAAJ,aAAA,EAAoB;AACpBU,MAAAA,WAAW,CAAXA,EAAAA;AACAV,MAAAA,iBAAiB,CAAjBA,KAAiB,CAAjBA;AACA7F,MAAAA,aAAa,IAAbA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,aAAa,CAAGuB,QAAQ,CAAxBvB,OAAa,CAAbA;AALmB,KAAA;;AAOrBwG,IAAAA,eAAe,GAAG;AAChB,UAAI,CAAJ,aAAA,EAAoB;AACpBD,MAAAA,WAAW,CAAXA,GAAAA;AACAtG,MAAAA,WAAW,IAAXA,IAAAA,GAAAA,KAAAA,CAAAA,GAAAA,WAAW,CAAGsB,QAAQ,CAAtBtB,OAAW,CAAXA;AAVmB,KAAA;;AAYrBmG,IAAAA,KAAK,CAAA,KAAA,EAAQ;AACX,UAAI,CAAJ,aAAA,EAAoB;AACpBA,MAAAA,KAAK,CAALA,KAAK,CAALA;AACD;;AAfoB,GAAV,CAAbE;AAkBA,MAAMG,YAAwB,GAAGxD,WAAW,CAC1C,UAAA,KAAA,EAAA,GAAA,EAAA;AAAA,QAACyD,KAAD,KAAA,KAAA,CAAA,EAAA;AAACA,MAAAA,KAAD,GAAA,EAACA;AAAD;;AAAA,QAAaC,GAAb,KAAA,KAAA,CAAA,EAAA;AAAaA,MAAAA,GAAb,GAAA,IAAaA;AAAb;;AAAA,WAAA,QAAA,CAAA,EAAA,EAAA,KAAA,EAAA,SAAA,EAAA;AAGE5G,MAAAA,EAAE,EAAE+C,GAAG,CAHT,IAAA;AAIE6D,MAAAA,GAAG,EAAEC,SAAS,CAAA,GAAA,EAJhB,OAIgB,CAJhB;AAKEC,MAAAA,QAAQ,EAAE,CALZ,CAAA;AAME,uBAAiBC,QAAQ,CAN3B,UAM2B,CAN3B;AAOE,sBAAgBC,QAAQ,CAP1B,SAO0B,CAP1B;AAQEC,MAAAA,KAAK,EAAA,QAAA,CAAA,EAAA,EAAON,KAAK,CAAZ,KAAA,EAAA,SAAA;AARP,KAAA,CAAA;AAD0C,GAAA,EAW1C,CAAA,SAAA,EAAA,UAAA,EAAA,SAAA,EAAA,SAAA,EAXF,GAWE,CAX0C,CAA5C;AAcA,MAAMO,aAAyB,GAAGhE,WAAW,CAC3C,UAAA,KAAA,EAAA,GAAA,EAAA;AAAA,QAACyD,KAAD,KAAA,KAAA,CAAA,EAAA;AAACA,MAAAA,KAAD,GAAA,EAACA;AAAD;;AAAA,QAAaC,GAAb,KAAA,KAAA,CAAA,EAAA;AAAaA,MAAAA,GAAb,GAAA,IAAaA;AAAb;;AAAA,WAAA,QAAA,CAAA,EAAA,EAAA,KAAA,EAAA;AAEEA,MAAAA,GAAG,EAAEC,SAAS,CAAA,GAAA,EAFhB,QAEgB,CAFhB;AAGE7G,MAAAA,EAAE,EAAE+C,GAAG,CAHT,KAAA;AAIE,uBAAiBiE,QAAQ,CAJ3B,UAI2B,CAJ3B;AAKEC,MAAAA,KAAK,EAAA,QAAA,CAAA,EAAA,EAAON,KAAK,CAAZ,KAAA,EAAA,UAAA;AALP,KAAA,CAAA;AAD2C,GAAA,EAQ3C,CAAA,UAAA,EAAA,UAAA,EARF,GAQE,CAR2C,CAA7C;AAWA,MAAMQ,kBAA8B,GAAGjE,WAAW,CAChD,UAAA,KAAA,EAAA,GAAA,EAAA;AAAA,QAACyD,KAAD,KAAA,KAAA,CAAA,EAAA;AAACA,MAAAA,KAAD,GAAA,EAACA;AAAD;;AAAA,QAAaC,GAAb,KAAA,KAAA,CAAA,EAAA;AAAaA,MAAAA,GAAb,GAAA,IAAaA;AAAb;;AAAA,WAAA,QAAA,CAAA,EAAA,EAAA,KAAA,EAAA;AAAA,MAAA,GAAA;AAGE5G,MAAAA,EAAE,EAAE+C,GAAG,CAHT,UAAA;AAIEkE,MAAAA,KAAK,EAAA,QAAA,CAAA,EAAA,EAAON,KAAK,CAAZ,KAAA,EAAA,eAAA;AAJP,KAAA,CAAA;AADgD,GAAA,EAOhD,CAAA,eAAA,EAPF,GAOE,CAPgD,CAAlD;AAUA,MAAMS,aAAa,GAAGlE,WAAW,CAC/B,UAAA,KAAA,EAAA,GAAA,EAAuB;AAAA,QAAA,iBAAA;;AAAA,QAAf0D,GAAe,KAAA,KAAA,CAAA,EAAA;AAAfA,MAAAA,GAAe,GAAT,IAANA;AAAe;;AACrB,QAAM;AAAEpB,MAAAA;AAAF,QAAN,KAAA;AAAA,QAAkB6B,IAAlB,GAAA,6BAAA,CAAA,KAAA,EAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,QAAMC,MAAM,GAAG1H,KAAK,CAApB,KAAoB,CAApB;;AACA,QAAI0H,MAAM,IAAV,IAAA,EAAoB;AAClB,YAAM,IAAA,SAAA,CAAA,wDAAA,KAAA,GAAA,+CAAA,GAC6G1H,KAAK,CADxH,MAAM,CAAN;AAGD;;AACD,QAAMmE,MAAM,GAAGpC,WAAW,CAA1B,KAA0B,CAA1B;AAEA,WAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAAA;AAAA,MAAA,GAAA;AAGE4F,MAAAA,IAAI,EAHN,QAAA;AAIET,MAAAA,QAAQ,EAAE5F,aAAa,GAAA,CAAA,GAJzB,SAAA;AAKElB,MAAAA,EAAE,EAAE+C,GAAG,CAAHA,QAAAA,CALN,KAKMA,CALN;AAME,qBAAeiE,QAAQ,CAACQ,UAAU,IAAIlB,WAAW,KANnD,KAMyB,CANzB;AAOE,wBAAA,CAAA,iBAAA,GAAkBlG,gBAAlB,IAAA,IAAkBA,GAAlB,KAAA,CAAkBA,GAAAA,gBAAgB,CAAlC,MAAkC,CAAlC,KAAA,IAAA,GAAA,iBAAA,GAAgDqH,aAAhD,IAAA,IAAgDA,GAAhD,KAAA,CAAgDA,GAAAA,aAAa,CAP/D,KAO+D,CAP/D;AAQE,uBAAiB1D,MAAM,CARzB,GAAA;AASE,uBAAiBA,MAAM,CATzB,GAAA;AAUE,uBAVF,MAAA;AAWE,0BAXF,WAAA;AAYE,uBAAiBgD,QAAQ,CAZ3B,UAY2B,CAZ3B;AAaE,uBAAiBA,QAAQ,CAb3B,UAa2B,CAb3B;AAcE,oBAAcW,SAAd,IAAA,IAAcA,GAAd,KAAA,CAAcA,GAAAA,SAAS,CAdzB,KAcyB,CAdzB;AAeE,yBAAmBA,SAAS,IAATA,IAAAA,IAAAA,SAAS,CAATA,KAAS,CAATA,GAAAA,SAAAA,GAEfC,cAFeD,IAAAA,IAEfC,GAFeD,KAAAA,CAEfC,GAAAA,cAAc,CAjBpB,KAiBoB,CAjBpB;AAkBEV,MAAAA,KAAK,EAAA,QAAA,CAAA,EAAA,EAAON,KAAK,CAAZ,KAAA,EAAuBiB,aAAa,CAlB3C,KAkB2C,CAApC,CAlBP;AAmBEpD,MAAAA,SAAS,EAAEqD,eAAe,CAAClB,KAAK,CAAN,SAAA,EAnB5B,SAmB4B,CAnB5B;AAoBEmB,MAAAA,OAAO,EAAED,eAAe,CAAClB,KAAK,CAAN,OAAA,EAAgB,MAAM;AAC5CoB,QAAAA,UAAU,CAAVA,EAAAA;AACA3B,QAAAA,cAAc,CAAdA,KAAc,CAAdA;AAtBJ,OAoB0B,CApB1B;AAwBE4B,MAAAA,MAAM,EAAEH,eAAe,CAAClB,KAAK,CAAN,MAAA,EAAe,MAAM;AAC1CoB,QAAAA,UAAU,CAAVA,GAAAA;AACA3B,QAAAA,cAAc,CAAC,CAAfA,CAAc,CAAdA;AAFqB,OAAA;AAxBzB,KAAA,CAAA;AAZ6B,GAAA,EA0C/B,CAAA,GAAA,EAAA,KAAA,EAAA,WAAA,EAAA,aAAA,EAAA,UAAA,EAAA,WAAA,EAAA,gBAAA,EAAA,aAAA,EAAA,WAAA,EAAA,UAAA,EAAA,UAAA,EAAA,SAAA,EAAA,cAAA,EAAA,aAAA,EAAA,SAAA,EA1CF,UA0CE,CA1C+B,CAAjC;AA8DA,MAAM6B,cAAc,GAAG/E,WAAW,CAChC,UAAA,KAAA,EAAA,GAAA,EAAA;AAAA,QAACyD,KAAD,KAAA,KAAA,CAAA,EAAA;AAACA,MAAAA,KAAD,GAAA,EAACA;AAAD;;AAAA,QAAaC,GAAb,KAAA,KAAA,CAAA,EAAA;AAAaA,MAAAA,GAAb,GAAA,IAAaA;AAAb;;AAAA,WAAA,QAAA,CAAA,EAAA,EAAA,KAAA,EAAA;AAAA,MAAA,GAAA;AAGE5G,MAAAA,EAAE,EAAE+C,GAAG,CAHT,MAAA;AAIEmF,MAAAA,OAAO,EAAEtI,KAAK,CAALA,GAAAA,CAAU,CAAA,CAAA,EAAA,CAAA,KAAUmD,GAAG,CAAHA,QAAAA,CAApBnD,CAAoBmD,CAApBnD,EAAAA,IAAAA,CAJX,GAIWA,CAJX;AAKE,mBAAa;AALf,KAAA,CAAA;AADgC,GAAA,EAQhC,CAAA,GAAA,EARF,KAQE,CARgC,CAAlC;AAWA,MAAMuI,cAAgD,GAAGjF,WAAW,CAClE,UAAA,KAAA,EAAA,GAAA,EAA4B;AAAA,QAA3ByD,KAA2B,KAAA,KAAA,CAAA,EAAA;AAA3BA,MAAAA,KAA2B,GAAnB,EAARA;AAA2B;;AAAA,QAAfC,GAAe,KAAA,KAAA,CAAA,EAAA;AAAfA,MAAAA,GAAe,GAAT,IAANA;AAAe;;AAC1B,QAAM;AAAEhH,MAAAA,KAAK,EAAEwI;AAAT,QAAN,KAAA;AAAA,QAAqBf,IAArB,GAAA,6BAAA,CAAA,KAAA,EAAA,CAAA,OAAA,CAAA,CAAA;;AAEA,QAAMgB,SAAS,GAAG,EAAED,CAAC,GAADA,GAAAA,IAAWA,CAAC,GAAhC,GAAkB,CAAlB;AACA,QAAME,aAAa,GAAGF,CAAC,IAAIxI,KAAK,CAAVwI,CAAU,CAAVA,IAAiBA,CAAC,IAAIxI,KAAK,CAACA,KAAK,CAALA,MAAAA,GAAlD,CAAiD,CAAjD;AAEA,QAAI4D,OAAO,GAAGxB,cAAc,CAAA,CAAA,EAAA,GAAA,EAA5B,GAA4B,CAA5B;AACAwB,IAAAA,OAAO,GAAG3D,UAAU,GAAG,MAAH,OAAA,GAApB2D,OAAAA;;AAEA,QAAM+E,WAAgC,GAAA,QAAA,CAAA;AACpCC,MAAAA,QAAQ,EAD4B,UAAA;AAEpCC,MAAAA,aAAa,EAAE;AAFqB,KAAA,EAGjCC,MAAM,CAAC;AAAA,MAAA,WAAA;AAERC,MAAAA,QAAQ,EAAE;AAAEC,QAAAA,MAAM,EAAKpF,OAAL,GAAA;AAAR,OAFF;AAGRqF,MAAAA,UAAU,EAAE;AAAEC,QAAAA,IAAI,EAAKtF,OAAL,GAAA;AAAN;AAHJ,KAAD,CAH2B,CAAtC;;AAUA,WAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAAA;AAAA,MAAA,GAAA;AAGExD,MAAAA,EAAE,EAAE+C,GAAG,CAAHA,SAAAA,CAAc4D,KAAK,CAHzB,KAGM5D,CAHN;AAIEwE,MAAAA,IAAI,EAJN,cAAA;AAKE,qBALF,IAAA;AAME,uBAAiBP,QAAQ,CAN3B,UAM2B,CAN3B;AAOE,sBAAgBA,QAAQ,CAAC,CAP3B,SAO0B,CAP1B;AAQE,0BAAoBA,QAAQ,CAR9B,aAQ8B,CAR9B;AASEC,MAAAA,KAAK,EAAA,QAAA,CAAA,EAAA,EACAN,KAAK,CADL,KAAA,EAAA,WAAA;AATP,KAAA,CAAA;AApBgE,GAAA,EAmClE,CAAA,UAAA,EAAA,UAAA,EAAA,GAAA,EAAA,GAAA,EAAA,WAAA,EAAA,KAAA,EAnCF,GAmCE,CAnCkE,CAApE;AAsCA,MAAMoC,aAAa,GAAG7F,WAAW,CAC/B,UAAA,KAAA,EAAA,GAAA,EAAuB;AAAA,QAAf0D,GAAe,KAAA,KAAA,CAAA,EAAA;AAAfA,MAAAA,GAAe,GAAT,IAANA;AAAe;;AACrB,QAAM;AAAEpB,MAAAA;AAAF,QAAN,KAAA;AAAA,QAAkB6B,IAAlB,GAAA,6BAAA,CAAA,KAAA,EAAA,CAAA,OAAA,CAAA,CAAA;;AACA,WAAA,QAAA,CAAA,EAAA,EAAA,IAAA,EAAA;AAAA,MAAA,GAAA;AAGErH,MAAAA,EAAE,EAAE+C,GAAG,CAAHA,QAAAA,CAHN,KAGMA,CAHN;AAIEiG,MAAAA,IAAI,EAJN,QAAA;AAKEpJ,MAAAA,KAAK,EAAEA,KAAK,CALd,KAKc,CALd;AAMEqJ,MAAAA,IAAI,EAAEpI,KAAK,CAALA,OAAAA,CAAAA,IAAAA,IAAsBoI,IAAI,CAA1BpI,KAA0B,CAA1BA,GAAuCoI,IAAvCpI,GAAAA,GAAuCoI,GAAQzD;AANvD,KAAA,CAAA;AAH6B,GAAA,EAY/B,CAAA,IAAA,EAAA,KAAA,EAZF,GAYE,CAZ+B,CAAjC;AAeA,SAAO;AACL0D,IAAAA,KAAK,EAAE;AAAA,MAAA,KAAA;AAAA,MAAA,SAAA;AAAA,MAAA,UAAA;AAILC,MAAAA,eAAe,EAAGC,CAAD,IAAerH,aAAa,CAJxC,CAIwC,CAJxC;AAKLsH,MAAAA,gBAAgB,EAAGD,CAAD,IAAezH,WAAW,CAAXA,CAAW,CAAXA,CAL5B,GAAA;AAML2H,MAAAA,gBAAgB,EAAGF,CAAD,IAAezH,WAAW,CAAXA,CAAW,CAAXA,CAAehC;AAN3C,KADF;AAAA,IAAA,OAAA;AAAA,IAAA,YAAA;AAAA,IAAA,aAAA;AAAA,IAAA,kBAAA;AAAA,IAAA,aAAA;AAAA,IAAA,cAAA;AAAA,IAAA,aAAA;AAgBLsI,IAAAA;AAhBK,GAAP;AAkBD;;AAID,IAAMrG,cAAc,GAAG,CAAA,GAAA,EAAA,GAAA,EAAA,GAAA,EAAA,OAAA,KAMrB,GAAG,CAAH,GAAA,CAAQ,CAAA,CAAA,EAAA,CAAA,KAAU;AAChB,MAAM2H,IAAI,GAAGH,CAAC,KAADA,CAAAA,GAAAA,GAAAA,GAAgBI,GAAG,CAACJ,CAAC,GAALI,CAAG,CAAHA,GAA7B,OAAA;;AACA,MAAMC,IAAI,GAAGL,CAAC,KAAKI,GAAG,CAAHA,MAAAA,GAANJ,CAAAA,GAAAA,GAAAA,GAA6BI,GAAG,CAACJ,CAAC,GAALI,CAAG,CAAHA,GAA1C,OAAA;;AACA,SAAO;AAAE9J,IAAAA,GAAG,EAAL,IAAA;AAAaC,IAAAA,GAAG,EAAE8J;AAAlB,GAAP;AATJ,CAME,CANF","sourcesContent":["import {\n  useBoolean,\n  useCallbackRef,\n  useControllableState,\n  useId,\n  useLatestRef,\n  usePanGesture,\n  useUpdateEffect,\n} from \"@chakra-ui/hooks\"\nimport { EventKeyMap, mergeRefs, PropGetter } from \"@chakra-ui/react-utils\"\nimport {\n  AnyPointerEvent,\n  ariaAttr,\n  callAllHandlers,\n  clampValue,\n  dataAttr,\n  focus,\n  normalizeEventKey,\n  percentToValue,\n  roundValueToStep,\n  valueToPercent,\n} from \"@chakra-ui/utils\"\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\"\nimport { getIds, getIsReversed, getStyles, orient } from \"./slider-utils\"\n\nexport interface UseRangeSliderProps {\n  /**\n   * The minimum allowed value of the slider. Cannot be greater than max.\n   * @default 0\n   */\n  min?: number\n  /**\n   * The maximum allowed value of the slider. Cannot be less than min.\n   * @default 100\n   */\n  max?: number\n  /**\n   * The step in which increments/decrements have to be made\n   * @default 1\n   */\n  step?: number\n  /**\n   * The value of the slider in controlled mode\n   */\n  value?: number[]\n  /**\n   * The initial value of the slider in uncontrolled mode\n   */\n  defaultValue?: number[]\n  /**\n   * orientation of the slider\n   * @default \"horizontal\"\n   */\n  orientation?: \"horizontal\" | \"vertical\"\n  /**\n   * If `true`, the value will be incremented or decremented in reverse.\n   */\n  isReversed?: boolean\n  /**\n   * Function called when the user starts selecting a new value (by dragging or clicking)\n   */\n  onChangeStart?(value: number[]): void\n  /**\n   * Function called when the user is done selecting a new value (by dragging or clicking)\n   */\n  onChangeEnd?(value: number[]): void\n  /**\n   * Function called whenever the slider value changes  (by dragging or clicking)\n   */\n  onChange?(value: number[]): void\n  /**\n   * The base `id` to use for the slider and its components\n   */\n  id?: string\n  /**\n   * The name attribute of the hidden `input` field.\n   * This is particularly useful in forms\n   */\n  name?: string | string[]\n  /**\n   * If `true`, the slider will be disabled\n   */\n  isDisabled?: boolean\n  /**\n   * If `true`, the slider will be in `read-only` state\n   */\n  isReadOnly?: boolean\n  /**\n   * Function that returns the `aria-valuetext` for screen readers.\n   * It is mostly used to generate a more human-readable\n   * representation of the value for assistive technologies\n   */\n  getAriaValueText?(value: number): string\n  /**\n   * If `false`, the slider handle will not capture focus when value changes.\n   * @default true\n   */\n  focusThumbOnChange?: boolean\n  /**\n   * The static string to use used for `aria-valuetext`\n   */\n  \"aria-valuetext\"?: string[]\n  /**\n   * The static string to use used for `aria-label`\n   * if no visible label is used.\n   */\n  \"aria-label\"?: string[]\n  /**\n   * The static string `aria-labelledby` that points to the\n   * ID of the element that serves as label for the slider\n   */\n  \"aria-labelledby\"?: string[]\n  /**\n   * The writing mode\n   */\n  direction?: \"ltr\" | \"rtl\"\n  /**\n   * The minimum distance between slider thumbs. Useful for preventing\n   * the thumbs from being too close together.\n   * @default 0\n   */\n  minStepsBetweenThumbs?: number\n}\n\n/**\n * React hook that implements an accessible range slider.\n *\n * It is an alternative to `<input type=\"range\" />`, and returns\n * prop getters for the component parts\n *\n * @see Docs     https://chakra-ui.com/docs/form/slider\n * @see WAI-ARIA https://www.w3.org/TR/wai-aria-practices-1.1/#slider\n */\nexport function useRangeSlider(props: UseRangeSliderProps) {\n  const {\n    min = 0,\n    max = 100,\n    onChange,\n    value: valueProp,\n    defaultValue,\n    isReversed: isReversedProp,\n    direction = \"ltr\",\n    orientation = \"horizontal\",\n    id: idProp,\n    isDisabled,\n    isReadOnly,\n    onChangeStart: onChangeStartProp,\n    onChangeEnd: onChangeEndProp,\n    step = 1,\n    getAriaValueText: getAriaValueTextProp,\n    \"aria-valuetext\": ariaValueText,\n    \"aria-label\": ariaLabel,\n    \"aria-labelledby\": ariaLabelledBy,\n    name,\n    focusThumbOnChange = true,\n    minStepsBetweenThumbs = 0,\n    ...htmlProps\n  } = props\n\n  const onChangeStart = useCallbackRef(onChangeStartProp)\n  const onChangeEnd = useCallbackRef(onChangeEndProp)\n  const getAriaValueText = useCallbackRef(getAriaValueTextProp)\n\n  const isReversed = getIsReversed({\n    isReversed: isReversedProp,\n    direction,\n    orientation,\n  })\n\n  const [valueState, setValue] = useControllableState({\n    value: valueProp,\n    defaultValue: defaultValue ?? [25, 75],\n    onChange,\n  })\n\n  if (!Array.isArray(valueState)) {\n    throw new TypeError(\n      `[range-slider] You passed an invalid value for \\`value\\` or \\`defaultValue\\`, expected \\`Array\\` but got \\`${typeof valueState}\\``,\n    )\n  }\n\n  const [isDragging, setDragging] = useBoolean()\n  const [isFocused, setFocused] = useBoolean()\n  const [activeIndex, setActiveIndex] = useState(-1)\n  const eventSourceRef = useRef<\"pointer\" | \"keyboard\" | null>(null)\n  const isInteractive = !(isDisabled || isReadOnly)\n\n  const initialValue = useRef(valueState)\n  const value = valueState.map((val) => clampValue(val, min, max))\n  const valueRef = useLatestRef(value)\n\n  const spacing = minStepsBetweenThumbs * step\n  const valueBounds = getValueBounds(value, min, max, spacing)\n\n  const reversedValue = value.map((val) => max - val + min)\n  const thumbValues = isReversed ? reversedValue : value\n\n  const thumbPercents = thumbValues.map((val) => valueToPercent(val, min, max))\n\n  const isVertical = orientation === \"vertical\"\n\n  const [thumbRects, setThumbRects] = useState(\n    Array.from({ length: value.length }).map(() => ({ width: 0, height: 0 })),\n  )\n\n  useEffect(() => {\n    if (!rootRef.current) return\n\n    const thumbs = Array.from(\n      rootRef.current?.querySelectorAll<HTMLElement>(\"[role=slider]\"),\n    )\n    const rects = thumbs.map((el) => ({\n      width: el.offsetWidth,\n      height: el.offsetHeight,\n    }))\n\n    if (rects.length) setThumbRects(rects)\n  }, [])\n\n  /**\n   * Let's keep a reference to the slider track and thumb\n   */\n  const trackRef = useRef<HTMLElement>(null)\n  const rootRef = useRef<HTMLElement>(null)\n\n  const uuid = useId(idProp)\n  const ids = getIds(uuid)\n\n  const getValueFromPointer = useCallback(\n    (event) => {\n      if (!trackRef.current) return\n      eventSourceRef.current = \"pointer\"\n      const rect = trackRef.current.getBoundingClientRect()\n      const { clientX, clientY } = event.touches?.[0] ?? event\n\n      const diff = isVertical ? rect.bottom - clientY : clientX - rect.left\n      const length = isVertical ? rect.height : rect.width\n\n      let percent = diff / length\n      if (isReversed) percent = 1 - percent\n\n      return percentToValue(percent, min, max)\n    },\n    [isVertical, isReversed, max, min],\n  )\n\n  const tenSteps = (max - min) / 10\n  const oneStep = step || (max - min) / 100\n\n  const actions = useMemo(\n    () => ({\n      setValueAtIndex: (index: number, val: number) => {\n        if (!isInteractive) return\n        const bounds = valueBounds[index]\n        val = parseFloat(roundValueToStep(val, bounds.min, oneStep))\n        val = clampValue(val, bounds.min, bounds.max)\n        const next = [...value]\n        next[index] = val\n        setValue(next)\n      },\n      setActiveIndex,\n      stepUp: (index: number, step = oneStep) => {\n        const valueAtIndex = value[index]\n        const next = isReversed ? valueAtIndex - step : valueAtIndex + step\n        actions.setValueAtIndex(index, next)\n      },\n      stepDown: (index: number, step = oneStep) => {\n        const valueAtIndex = value[index]\n        const next = isReversed ? valueAtIndex + step : valueAtIndex - step\n        actions.setValueAtIndex(index, next)\n      },\n      reset: () => setValue(initialValue.current),\n    }),\n    [oneStep, value, isReversed, setValue, isInteractive, valueBounds],\n  )\n\n  /**\n   * Keyboard interaction to ensure users can operate\n   * the slider using only their keyboard.\n   */\n  const onKeyDown = useCallback(\n    (event: React.KeyboardEvent) => {\n      const eventKey = normalizeEventKey(event)\n      const keyMap: EventKeyMap = {\n        ArrowRight: () => actions.stepUp(activeIndex),\n        ArrowUp: () => actions.stepUp(activeIndex),\n        ArrowLeft: () => actions.stepDown(activeIndex),\n        ArrowDown: () => actions.stepDown(activeIndex),\n        PageUp: () => actions.stepUp(activeIndex, tenSteps),\n        PageDown: () => actions.stepDown(activeIndex, tenSteps),\n        Home: () => {\n          const { min: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n        End: () => {\n          const { max: value } = valueBounds[activeIndex]\n          actions.setValueAtIndex(activeIndex, value)\n        },\n      }\n\n      const action = keyMap[eventKey]\n\n      if (action) {\n        event.preventDefault()\n        event.stopPropagation()\n        action(event)\n        eventSourceRef.current = \"keyboard\"\n      }\n    },\n    [actions, activeIndex, tenSteps, valueBounds],\n  )\n\n  /**\n   * Compute styles for all component parts.\n   */\n  const { getThumbStyle, rootStyle, trackStyle, innerTrackStyle } = useMemo(\n    () =>\n      getStyles({\n        isReversed,\n        orientation,\n        thumbRects,\n        thumbPercents,\n      }),\n    [isReversed, orientation, thumbPercents, thumbRects],\n  )\n\n  const focusThumb = useCallback(\n    (index?: number) => {\n      const idx = index ?? activeIndex\n      if (idx !== -1 && focusThumbOnChange) {\n        const id = ids.getThumb(idx)\n        const thumb = rootRef.current?.ownerDocument.getElementById(id)\n        if (thumb) {\n          setTimeout(() => focus(thumb))\n        }\n      }\n    },\n    [focusThumbOnChange, activeIndex, ids],\n  )\n\n  useUpdateEffect(() => {\n    if (eventSourceRef.current === \"keyboard\") {\n      onChangeEnd?.(valueRef.current)\n    }\n  }, [value, onChangeEnd])\n\n  const onPanSessionStart = (event: AnyPointerEvent) => {\n    const pointValue = getValueFromPointer(event) || 0\n    const distances = value.map((val) => Math.abs(val - pointValue))\n    const isThumbStacked = new Set(distances).size !== distances.length\n    const closest = Math.min(...distances)\n    let index = distances.indexOf(closest)\n    // when two thumbs are stacked and the user clicks at a point larger than\n    // their values, pick the next closest thumb\n    if (isThumbStacked && pointValue > value[index]) {\n      index++\n    }\n    setActiveIndex(index)\n    actions.setValueAtIndex(index, pointValue)\n    focusThumb(index)\n  }\n\n  const onPan = (event: AnyPointerEvent) => {\n    if (activeIndex == -1) return;\n    const pointValue = getValueFromPointer(event) || 0\n    setActiveIndex(activeIndex)\n    actions.setValueAtIndex(activeIndex, pointValue)\n    focusThumb(activeIndex)\n  }\n\n  usePanGesture(rootRef, {\n    onPanSessionStart(event) {\n      if (!isInteractive) return\n      setDragging.on()\n      onPanSessionStart(event)\n      onChangeStart?.(valueRef.current)\n    },\n    onPanSessionEnd() {\n      if (!isInteractive) return\n      setDragging.off()\n      onChangeEnd?.(valueRef.current)\n    },\n    onPan(event) {\n      if (!isInteractive) return\n      onPan(event)\n    },\n  })\n\n  const getRootProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ...htmlProps,\n      id: ids.root,\n      ref: mergeRefs(ref, rootRef),\n      tabIndex: -1,\n      \"aria-disabled\": ariaAttr(isDisabled),\n      \"data-focused\": dataAttr(isFocused),\n      style: { ...props.style, ...rootStyle },\n    }),\n    [htmlProps, isDisabled, isFocused, rootStyle, ids],\n  )\n\n  const getTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref: mergeRefs(ref, trackRef),\n      id: ids.track,\n      \"data-disabled\": dataAttr(isDisabled),\n      style: { ...props.style, ...trackStyle },\n    }),\n    [isDisabled, trackStyle, ids],\n  )\n\n  const getInnerTrackProps: PropGetter = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      id: ids.innerTrack,\n      style: { ...props.style, ...innerTrackStyle },\n    }),\n    [innerTrackStyle, ids],\n  )\n\n  const getThumbProps = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n\n      const _value = value[index]\n      if (_value == null) {\n        throw new TypeError(\n          `[range-slider > thumb] Cannot find value at index \\`${index}\\`. The \\`value\\` or \\`defaultValue\\` length is : ${value.length}`,\n        )\n      }\n      const bounds = valueBounds[index]\n\n      return {\n        ...rest,\n        ref,\n        role: \"slider\",\n        tabIndex: isInteractive ? 0 : undefined,\n        id: ids.getThumb(index),\n        \"data-active\": dataAttr(isDragging && activeIndex === index),\n        \"aria-valuetext\": getAriaValueText?.(_value) ?? ariaValueText?.[index],\n        \"aria-valuemin\": bounds.min,\n        \"aria-valuemax\": bounds.max,\n        \"aria-valuenow\": _value,\n        \"aria-orientation\": orientation,\n        \"aria-disabled\": ariaAttr(isDisabled),\n        \"aria-readonly\": ariaAttr(isReadOnly),\n        \"aria-label\": ariaLabel?.[index],\n        \"aria-labelledby\": ariaLabel?.[index]\n          ? undefined\n          : ariaLabelledBy?.[index],\n        style: { ...props.style, ...getThumbStyle(index) },\n        onKeyDown: callAllHandlers(props.onKeyDown, onKeyDown),\n        onFocus: callAllHandlers(props.onFocus, () => {\n          setFocused.on()\n          setActiveIndex(index)\n        }),\n        onBlur: callAllHandlers(props.onBlur, () => {\n          setFocused.off()\n          setActiveIndex(-1)\n        }),\n      }\n    },\n    [\n      ids,\n      value,\n      valueBounds,\n      isInteractive,\n      isDragging,\n      activeIndex,\n      getAriaValueText,\n      ariaValueText,\n      orientation,\n      isDisabled,\n      isReadOnly,\n      ariaLabel,\n      ariaLabelledBy,\n      getThumbStyle,\n      onKeyDown,\n      setFocused,\n    ],\n  )\n\n  const getOutputProps = useCallback(\n    (props = {}, ref = null) => ({\n      ...props,\n      ref,\n      id: ids.output,\n      htmlFor: value.map((v, i) => ids.getThumb(i)).join(\" \"),\n      \"aria-live\": \"off\",\n    }),\n    [ids, value],\n  )\n\n  const getMarkerProps: PropGetter<any, { value?: any }> = useCallback(\n    (props = {}, ref = null) => {\n      const { value: v, ...rest } = props\n\n      const isInRange = !(v < min || v > max)\n      const isHighlighted = v >= value[0] && v <= value[value.length - 1]\n\n      let percent = valueToPercent(v, min, max)\n      percent = isReversed ? 100 - percent : percent\n\n      const markerStyle: React.CSSProperties = {\n        position: \"absolute\",\n        pointerEvents: \"none\",\n        ...orient({\n          orientation,\n          vertical: { bottom: `${percent}%` },\n          horizontal: { left: `${percent}%` },\n        }),\n      }\n\n      return {\n        ...rest,\n        ref,\n        id: ids.getMarker(props.value),\n        role: \"presentation\",\n        \"aria-hidden\": true,\n        \"data-disabled\": dataAttr(isDisabled),\n        \"data-invalid\": dataAttr(!isInRange),\n        \"data-highlighted\": dataAttr(isHighlighted),\n        style: {\n          ...props.style,\n          ...markerStyle,\n        },\n      }\n    },\n    [isDisabled, isReversed, max, min, orientation, value, ids],\n  )\n\n  const getInputProps = useCallback(\n    (props, ref = null) => {\n      const { index, ...rest } = props\n      return {\n        ...rest,\n        ref,\n        id: ids.getInput(index),\n        type: \"hidden\",\n        value: value[index],\n        name: Array.isArray(name) ? name[index] : `${name}-${index}`,\n      }\n    },\n    [name, value, ids],\n  )\n\n  return {\n    state: {\n      value,\n      isFocused,\n      isDragging,\n      getThumbPercent: (i: number) => thumbPercents[i],\n      getThumbMinValue: (i: number) => valueBounds[i].min,\n      getThumbMaxValue: (i: number) => valueBounds[i].max,\n    },\n    actions,\n    getRootProps,\n    getTrackProps,\n    getInnerTrackProps,\n    getThumbProps,\n    getMarkerProps,\n    getInputProps,\n    getOutputProps,\n  }\n}\n\nexport type UseRangeSliderReturn = ReturnType<typeof useRangeSlider>\n\nconst getValueBounds = (\n  arr: number[],\n  min: number,\n  max: number,\n  spacing: number,\n) =>\n  arr.map((v, i) => {\n    const _min = i === 0 ? min : arr[i - 1] + spacing\n    const _max = i === arr.length - 1 ? max : arr[i + 1] - spacing\n    return { min: _min, max: _max }\n  })\n"]},"metadata":{},"sourceType":"module"}