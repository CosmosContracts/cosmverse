{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Responses = void 0;\n/* eslint-disable @typescript-eslint/naming-convention */\n\nvar encoding_1 = require(\"@cosmjs/encoding\");\n\nvar utils_1 = require(\"@cosmjs/utils\");\n\nvar dates_1 = require(\"../../../dates\");\n\nvar types_1 = require(\"../../../types\");\n\nvar encodings_1 = require(\"../../encodings\");\n\nvar hasher_1 = require(\"../../hasher\");\n\nfunction _decodeAbciInfo(data) {\n  return {\n    data: data.data,\n    lastBlockHeight: encodings_1.may(encodings_1.Integer.parse, data.last_block_height),\n    lastBlockAppHash: encodings_1.may(encoding_1.fromBase64, data.last_block_app_hash)\n  };\n}\n\nfunction decodeQueryProof(data) {\n  return {\n    ops: data.ops.map(function (op) {\n      return {\n        type: op.type,\n        key: encoding_1.fromBase64(op.key),\n        data: encoding_1.fromBase64(op.data)\n      };\n    })\n  };\n}\n\nfunction _decodeAbciQuery(data) {\n  return {\n    key: encoding_1.fromBase64(encodings_1.optional(data.key, \"\")),\n    value: encoding_1.fromBase64(encodings_1.optional(data.value, \"\")),\n    proof: encodings_1.may(decodeQueryProof, data.proofOps),\n    height: encodings_1.may(encodings_1.Integer.parse, data.height),\n    code: encodings_1.may(encodings_1.Integer.parse, data.code),\n    index: encodings_1.may(encodings_1.Integer.parse, data.index),\n    log: data.log\n  };\n}\n\nfunction decodeAttribute(attribute) {\n  return {\n    key: encoding_1.fromBase64(encodings_1.assertNotEmpty(attribute.key)),\n    value: encoding_1.fromBase64(encodings_1.optional(attribute.value, \"\"))\n  };\n}\n\nfunction decodeAttributes(attributes) {\n  return encodings_1.assertArray(attributes).map(decodeAttribute);\n}\n\nfunction decodeEvent(event) {\n  return {\n    type: event.type,\n    attributes: decodeAttributes(event.attributes)\n  };\n}\n\nfunction decodeEvents(events) {\n  return encodings_1.assertArray(events).map(decodeEvent);\n}\n\nfunction decodeTxData(data) {\n  return {\n    data: encodings_1.may(encoding_1.fromBase64, data.data),\n    log: data.log,\n    code: encodings_1.Integer.parse(encodings_1.assertNumber(encodings_1.optional(data.code, 0))),\n    events: decodeEvents(data.events)\n  };\n}\n\nfunction decodePubkey(data) {\n  switch (data.type) {\n    // go-amino special code\n    case \"tendermint/PubKeyEd25519\":\n      return {\n        algorithm: \"ed25519\",\n        data: encoding_1.fromBase64(encodings_1.assertNotEmpty(data.value))\n      };\n\n    case \"tendermint/PubKeySecp256k1\":\n      return {\n        algorithm: \"secp256k1\",\n        data: encoding_1.fromBase64(encodings_1.assertNotEmpty(data.value))\n      };\n\n    default:\n      throw new Error(\"unknown pubkey type: \".concat(data.type));\n  }\n}\n\nfunction decodeValidatorUpdate(data) {\n  return {\n    pubkey: decodePubkey(encodings_1.assertObject(data.pub_key)),\n    votingPower: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.voting_power)),\n    address: encoding_1.fromHex(encodings_1.assertNotEmpty(data.address)),\n    proposerPriority: encodings_1.Integer.parse(data.proposer_priority)\n  };\n}\n/**\n * Note: we do not parse block.time_iota_ms for now because of this CHANGELOG entry\n *\n * > Add time_iota_ms to block's consensus parameters (not exposed to the application)\n * https://github.com/tendermint/tendermint/blob/master/CHANGELOG.md#v0310\n */\n\n\nfunction decodeBlockParams(data) {\n  return {\n    maxBytes: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.max_bytes)),\n    maxGas: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.max_gas))\n  };\n}\n\nfunction decodeEvidenceParams(data) {\n  return {\n    maxAgeNumBlocks: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.max_age_num_blocks)),\n    maxAgeDuration: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.max_age_duration))\n  };\n}\n\nfunction decodeConsensusParams(data) {\n  return {\n    block: decodeBlockParams(encodings_1.assertObject(data.block)),\n    evidence: decodeEvidenceParams(encodings_1.assertObject(data.evidence))\n  };\n}\n\nfunction _decodeBlockResults(data) {\n  return {\n    height: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.height)),\n    results: (data.txs_results || []).map(decodeTxData),\n    validatorUpdates: (data.validator_updates || []).map(decodeValidatorUpdate),\n    consensusUpdates: encodings_1.may(decodeConsensusParams, data.consensus_param_updates),\n    beginBlockEvents: decodeEvents(data.begin_block_events || []),\n    endBlockEvents: decodeEvents(data.end_block_events || [])\n  };\n}\n\nfunction decodeBlockId(data) {\n  return {\n    hash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.hash)),\n    parts: {\n      total: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.parts.total)),\n      hash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.parts.hash))\n    }\n  };\n}\n\nfunction decodeBlockVersion(data) {\n  var _a;\n\n  return {\n    block: encodings_1.Integer.parse(data.block),\n    app: encodings_1.Integer.parse((_a = data.app) !== null && _a !== void 0 ? _a : 0)\n  };\n}\n\nfunction decodeHeader(data) {\n  return {\n    version: decodeBlockVersion(data.version),\n    chainId: encodings_1.assertNotEmpty(data.chain_id),\n    height: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.height)),\n    time: dates_1.fromRfc3339WithNanoseconds(encodings_1.assertNotEmpty(data.time)),\n    lastBlockId: decodeBlockId(data.last_block_id),\n    lastCommitHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.last_commit_hash)),\n    dataHash: encoding_1.fromHex(encodings_1.assertSet(data.data_hash)),\n    validatorsHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.validators_hash)),\n    nextValidatorsHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.next_validators_hash)),\n    consensusHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.consensus_hash)),\n    appHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.app_hash)),\n    lastResultsHash: encoding_1.fromHex(encodings_1.assertSet(data.last_results_hash)),\n    evidenceHash: encoding_1.fromHex(encodings_1.assertSet(data.evidence_hash)),\n    proposerAddress: encoding_1.fromHex(encodings_1.assertNotEmpty(data.proposer_address))\n  };\n}\n\nfunction decodeBlockMeta(data) {\n  return {\n    blockId: decodeBlockId(data.block_id),\n    header: decodeHeader(data.header)\n  };\n}\n\nfunction _decodeBlockchain(data) {\n  return {\n    lastHeight: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.last_height)),\n    blockMetas: encodings_1.assertArray(data.block_metas).map(decodeBlockMeta)\n  };\n}\n\nfunction _decodeBroadcastTxSync(data) {\n  return Object.assign(Object.assign({}, decodeTxData(data)), {\n    hash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.hash))\n  });\n}\n\nfunction _decodeBroadcastTxCommit(data) {\n  return {\n    height: encodings_1.Integer.parse(data.height),\n    hash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.hash)),\n    checkTx: decodeTxData(encodings_1.assertObject(data.check_tx)),\n    deliverTx: encodings_1.may(decodeTxData, data.deliver_tx)\n  };\n}\n\nfunction decodeBlockIdFlag(blockIdFlag) {\n  utils_1.assert(blockIdFlag in types_1.BlockIdFlag);\n  return blockIdFlag;\n}\n\nfunction decodeCommitSignature(data) {\n  return {\n    blockIdFlag: decodeBlockIdFlag(data.block_id_flag),\n    validatorAddress: encoding_1.fromHex(data.validator_address),\n    timestamp: dates_1.fromRfc3339WithNanoseconds(encodings_1.assertNotEmpty(data.timestamp)),\n    signature: encoding_1.fromBase64(encodings_1.assertNotEmpty(data.signature))\n  };\n}\n\nfunction decodeCommit(data) {\n  return {\n    blockId: decodeBlockId(encodings_1.assertObject(data.block_id)),\n    height: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.height)),\n    round: encodings_1.Integer.parse(data.round),\n    signatures: encodings_1.assertArray(data.signatures).map(decodeCommitSignature)\n  };\n}\n\nfunction decodeCommitResponse(data) {\n  return {\n    canonical: encodings_1.assertBoolean(data.canonical),\n    header: decodeHeader(data.signed_header.header),\n    commit: decodeCommit(data.signed_header.commit)\n  };\n}\n\nfunction decodeValidatorGenesis(data) {\n  return {\n    address: encoding_1.fromHex(encodings_1.assertNotEmpty(data.address)),\n    pubkey: decodePubkey(encodings_1.assertObject(data.pub_key)),\n    votingPower: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.power))\n  };\n}\n\nfunction _decodeGenesis(data) {\n  return {\n    genesisTime: dates_1.fromRfc3339WithNanoseconds(encodings_1.assertNotEmpty(data.genesis_time)),\n    chainId: encodings_1.assertNotEmpty(data.chain_id),\n    consensusParams: decodeConsensusParams(data.consensus_params),\n    validators: data.validators ? encodings_1.assertArray(data.validators).map(decodeValidatorGenesis) : [],\n    appHash: encoding_1.fromHex(encodings_1.assertSet(data.app_hash)),\n    appState: data.app_state\n  };\n}\n\nfunction decodeValidatorInfo(data) {\n  return {\n    pubkey: decodePubkey(encodings_1.assertObject(data.pub_key)),\n    votingPower: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.voting_power)),\n    address: encoding_1.fromHex(encodings_1.assertNotEmpty(data.address))\n  };\n}\n\nfunction decodeNodeInfo(data) {\n  return {\n    id: encoding_1.fromHex(encodings_1.assertNotEmpty(data.id)),\n    listenAddr: encodings_1.assertNotEmpty(data.listen_addr),\n    network: encodings_1.assertNotEmpty(data.network),\n    version: encodings_1.assertString(data.version),\n    channels: encodings_1.assertNotEmpty(data.channels),\n    moniker: encodings_1.assertNotEmpty(data.moniker),\n    other: encodings_1.dictionaryToStringMap(data.other),\n    protocolVersion: {\n      app: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.protocol_version.app)),\n      block: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.protocol_version.block)),\n      p2p: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.protocol_version.p2p))\n    }\n  };\n}\n\nfunction decodeSyncInfo(data) {\n  return {\n    latestBlockHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.latest_block_hash)),\n    latestAppHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.latest_app_hash)),\n    latestBlockTime: dates_1.fromRfc3339WithNanoseconds(encodings_1.assertNotEmpty(data.latest_block_time)),\n    latestBlockHeight: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.latest_block_height)),\n    catchingUp: encodings_1.assertBoolean(data.catching_up)\n  };\n}\n\nfunction _decodeStatus(data) {\n  return {\n    nodeInfo: decodeNodeInfo(data.node_info),\n    syncInfo: decodeSyncInfo(data.sync_info),\n    validatorInfo: decodeValidatorInfo(data.validator_info)\n  };\n}\n\nfunction decodeTxProof(data) {\n  return {\n    data: encoding_1.fromBase64(encodings_1.assertNotEmpty(data.data)),\n    rootHash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.root_hash)),\n    proof: {\n      total: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.proof.total)),\n      index: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.proof.index)),\n      leafHash: encoding_1.fromBase64(encodings_1.assertNotEmpty(data.proof.leaf_hash)),\n      aunts: encodings_1.assertArray(data.proof.aunts).map(encoding_1.fromBase64)\n    }\n  };\n}\n\nfunction decodeTxResponse(data) {\n  return {\n    tx: encoding_1.fromBase64(encodings_1.assertNotEmpty(data.tx)),\n    result: decodeTxData(encodings_1.assertObject(data.tx_result)),\n    height: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.height)),\n    index: encodings_1.Integer.parse(encodings_1.assertNumber(data.index)),\n    hash: encoding_1.fromHex(encodings_1.assertNotEmpty(data.hash)),\n    proof: encodings_1.may(decodeTxProof, data.proof)\n  };\n}\n\nfunction _decodeTxSearch(data) {\n  return {\n    totalCount: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.total_count)),\n    txs: encodings_1.assertArray(data.txs).map(decodeTxResponse)\n  };\n}\n\nfunction _decodeTxEvent(data) {\n  var tx = encoding_1.fromBase64(encodings_1.assertNotEmpty(data.tx));\n  return {\n    tx: tx,\n    hash: hasher_1.hashTx(tx),\n    result: decodeTxData(data.result),\n    height: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.height)),\n    index: encodings_1.may(encodings_1.Integer.parse, data.index)\n  };\n}\n\nfunction _decodeValidators(data) {\n  return {\n    blockHeight: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.block_height)),\n    validators: encodings_1.assertArray(data.validators).map(decodeValidatorUpdate),\n    count: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.count)),\n    total: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.total))\n  };\n}\n\nfunction decodeEvidence(data) {\n  return {\n    type: encodings_1.assertNotEmpty(data.type),\n    height: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.height)),\n    time: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.time)),\n    totalVotingPower: encodings_1.Integer.parse(encodings_1.assertNotEmpty(data.totalVotingPower)),\n    validator: decodeValidatorUpdate(data.validator)\n  };\n}\n\nfunction decodeEvidences(ev) {\n  return encodings_1.assertArray(ev).map(decodeEvidence);\n}\n\nfunction decodeBlock(data) {\n  return {\n    header: decodeHeader(encodings_1.assertObject(data.header)),\n    lastCommit: decodeCommit(encodings_1.assertObject(data.last_commit)),\n    txs: data.data.txs ? encodings_1.assertArray(data.data.txs).map(encoding_1.fromBase64) : [],\n    evidence: data.evidence && encodings_1.may(decodeEvidences, data.evidence.evidence)\n  };\n}\n\nfunction decodeBlockResponse(data) {\n  return {\n    blockId: decodeBlockId(data.block_id),\n    block: decodeBlock(data.block)\n  };\n}\n\nvar Responses = /*#__PURE__*/function () {\n  function Responses() {\n    _classCallCheck(this, Responses);\n  }\n\n  _createClass(Responses, null, [{\n    key: \"decodeAbciInfo\",\n    value: function decodeAbciInfo(response) {\n      return _decodeAbciInfo(encodings_1.assertObject(response.result.response));\n    }\n  }, {\n    key: \"decodeAbciQuery\",\n    value: function decodeAbciQuery(response) {\n      return _decodeAbciQuery(encodings_1.assertObject(response.result.response));\n    }\n  }, {\n    key: \"decodeBlock\",\n    value: function decodeBlock(response) {\n      return decodeBlockResponse(response.result);\n    }\n  }, {\n    key: \"decodeBlockResults\",\n    value: function decodeBlockResults(response) {\n      return _decodeBlockResults(response.result);\n    }\n  }, {\n    key: \"decodeBlockchain\",\n    value: function decodeBlockchain(response) {\n      return _decodeBlockchain(response.result);\n    }\n  }, {\n    key: \"decodeBroadcastTxSync\",\n    value: function decodeBroadcastTxSync(response) {\n      return _decodeBroadcastTxSync(response.result);\n    }\n  }, {\n    key: \"decodeBroadcastTxAsync\",\n    value: function decodeBroadcastTxAsync(response) {\n      return this.decodeBroadcastTxSync(response);\n    }\n  }, {\n    key: \"decodeBroadcastTxCommit\",\n    value: function decodeBroadcastTxCommit(response) {\n      return _decodeBroadcastTxCommit(response.result);\n    }\n  }, {\n    key: \"decodeCommit\",\n    value: function decodeCommit(response) {\n      return decodeCommitResponse(response.result);\n    }\n  }, {\n    key: \"decodeGenesis\",\n    value: function decodeGenesis(response) {\n      return _decodeGenesis(encodings_1.assertObject(response.result.genesis));\n    }\n  }, {\n    key: \"decodeHealth\",\n    value: function decodeHealth() {\n      return null;\n    }\n  }, {\n    key: \"decodeStatus\",\n    value: function decodeStatus(response) {\n      return _decodeStatus(response.result);\n    }\n  }, {\n    key: \"decodeNewBlockEvent\",\n    value: function decodeNewBlockEvent(event) {\n      return decodeBlock(event.data.value.block);\n    }\n  }, {\n    key: \"decodeNewBlockHeaderEvent\",\n    value: function decodeNewBlockHeaderEvent(event) {\n      return decodeHeader(event.data.value.header);\n    }\n  }, {\n    key: \"decodeTxEvent\",\n    value: function decodeTxEvent(event) {\n      return _decodeTxEvent(event.data.value.TxResult);\n    }\n  }, {\n    key: \"decodeTx\",\n    value: function decodeTx(response) {\n      return decodeTxResponse(response.result);\n    }\n  }, {\n    key: \"decodeTxSearch\",\n    value: function decodeTxSearch(response) {\n      return _decodeTxSearch(response.result);\n    }\n  }, {\n    key: \"decodeValidators\",\n    value: function decodeValidators(response) {\n      return _decodeValidators(response.result);\n    }\n  }]);\n\n  return Responses;\n}();\n\nexports.Responses = Responses;","map":null,"metadata":{},"sourceType":"script"}