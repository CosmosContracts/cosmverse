{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/pauloponciano/Documents/cosmverse/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Decimal = void 0;\n\nvar bn_js_1 = __importDefault(require(\"bn.js\")); // Too large values lead to massive memory usage. Limit to something sensible.\n// The largest value we need is 18 (Ether).\n\n\nvar maxFractionalDigits = 100;\n/**\n * A type for arbitrary precision, non-negative decimals.\n *\n * Instances of this class are immutable.\n */\n\nvar Decimal = /*#__PURE__*/function () {\n  function Decimal(atomics, fractionalDigits) {\n    _classCallCheck(this, Decimal);\n\n    this.data = {\n      atomics: new bn_js_1.default(atomics),\n      fractionalDigits: fractionalDigits\n    };\n  }\n\n  _createClass(Decimal, [{\n    key: \"atomics\",\n    get: function get() {\n      return this.data.atomics.toString();\n    }\n  }, {\n    key: \"fractionalDigits\",\n    get: function get() {\n      return this.data.fractionalDigits;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var factor = new bn_js_1.default(10).pow(new bn_js_1.default(this.data.fractionalDigits));\n      var whole = this.data.atomics.div(factor);\n      var fractional = this.data.atomics.mod(factor);\n\n      if (fractional.isZero()) {\n        return whole.toString();\n      } else {\n        var fullFractionalPart = fractional.toString().padStart(this.data.fractionalDigits, \"0\");\n        var trimmedFractionalPart = fullFractionalPart.replace(/0+$/, \"\");\n        return \"\".concat(whole.toString(), \".\").concat(trimmedFractionalPart);\n      }\n    }\n    /**\n     * Returns an approximation as a float type. Only use this if no\n     * exact calculation is required.\n     */\n\n  }, {\n    key: \"toFloatApproximation\",\n    value: function toFloatApproximation() {\n      var out = Number(this.toString());\n      if (Number.isNaN(out)) throw new Error(\"Conversion to number failed\");\n      return out;\n    }\n    /**\n     * a.plus(b) returns a+b.\n     *\n     * Both values need to have the same fractional digits.\n     */\n\n  }, {\n    key: \"plus\",\n    value: function plus(b) {\n      if (this.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n      var sum = this.data.atomics.add(new bn_js_1.default(b.atomics));\n      return new Decimal(sum.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.minus(b) returns a-b.\n     *\n     * Both values need to have the same fractional digits.\n     * The resulting difference needs to be non-negative.\n     */\n\n  }, {\n    key: \"minus\",\n    value: function minus(b) {\n      if (this.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n      var difference = this.data.atomics.sub(new bn_js_1.default(b.atomics));\n      if (difference.ltn(0)) throw new Error(\"Difference must not be negative\");\n      return new Decimal(difference.toString(), this.fractionalDigits);\n    }\n    /**\n     * a.multiply(b) returns a*b.\n     *\n     * We only allow multiplication by unsigned integers to avoid rounding errors.\n     */\n\n  }, {\n    key: \"multiply\",\n    value: function multiply(b) {\n      var product = this.data.atomics.mul(new bn_js_1.default(b.toString()));\n      return new Decimal(product.toString(), this.fractionalDigits);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(b) {\n      return Decimal.compare(this, b) === 0;\n    }\n  }, {\n    key: \"isLessThan\",\n    value: function isLessThan(b) {\n      return Decimal.compare(this, b) < 0;\n    }\n  }, {\n    key: \"isLessThanOrEqual\",\n    value: function isLessThanOrEqual(b) {\n      return Decimal.compare(this, b) <= 0;\n    }\n  }, {\n    key: \"isGreaterThan\",\n    value: function isGreaterThan(b) {\n      return Decimal.compare(this, b) > 0;\n    }\n  }, {\n    key: \"isGreaterThanOrEqual\",\n    value: function isGreaterThanOrEqual(b) {\n      return Decimal.compare(this, b) >= 0;\n    }\n  }], [{\n    key: \"fromUserInput\",\n    value: function fromUserInput(input, fractionalDigits) {\n      Decimal.verifyFractionalDigits(fractionalDigits);\n      var badCharacter = input.match(/[^0-9.]/);\n\n      if (badCharacter) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        throw new Error(\"Invalid character at position \".concat(badCharacter.index + 1));\n      }\n\n      var whole;\n      var fractional;\n\n      if (input.search(/\\./) === -1) {\n        // integer format, no separator\n        whole = input;\n        fractional = \"\";\n      } else {\n        var parts = input.split(\".\");\n\n        switch (parts.length) {\n          case 0:\n          case 1:\n            throw new Error(\"Fewer than two elements in split result. This must not happen here.\");\n\n          case 2:\n            if (!parts[1]) throw new Error(\"Fractional part missing\");\n            whole = parts[0];\n            fractional = parts[1].replace(/0+$/, \"\");\n            break;\n\n          default:\n            throw new Error(\"More than one separator found\");\n        }\n      }\n\n      if (fractional.length > fractionalDigits) {\n        throw new Error(\"Got more fractional digits than supported\");\n      }\n\n      var quantity = \"\".concat(whole).concat(fractional.padEnd(fractionalDigits, \"0\"));\n      return new Decimal(quantity, fractionalDigits);\n    }\n  }, {\n    key: \"fromAtomics\",\n    value: function fromAtomics(atomics, fractionalDigits) {\n      Decimal.verifyFractionalDigits(fractionalDigits);\n      return new Decimal(atomics, fractionalDigits);\n    }\n  }, {\n    key: \"verifyFractionalDigits\",\n    value: function verifyFractionalDigits(fractionalDigits) {\n      if (!Number.isInteger(fractionalDigits)) throw new Error(\"Fractional digits is not an integer\");\n      if (fractionalDigits < 0) throw new Error(\"Fractional digits must not be negative\");\n\n      if (fractionalDigits > maxFractionalDigits) {\n        throw new Error(\"Fractional digits must not exceed \".concat(maxFractionalDigits));\n      }\n    }\n  }, {\n    key: \"compare\",\n    value: function compare(a, b) {\n      if (a.fractionalDigits !== b.fractionalDigits) throw new Error(\"Fractional digits do not match\");\n      return a.data.atomics.cmp(new bn_js_1.default(b.atomics));\n    }\n  }]);\n\n  return Decimal;\n}();\n\nexports.Decimal = Decimal;","map":null,"metadata":{},"sourceType":"script"}