"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("@iov/crypto");
const encoding_1 = require("@iov/encoding");
const pako_1 = __importDefault(require("pako"));
const builder_1 = require("./builder");
const cosmwasmclient_1 = require("./cosmwasmclient");
const encoding_2 = require("./encoding");
const logs_1 = require("./logs");
const restclient_1 = require("./restclient");
function singleAmount(amount, denom) {
    return [{ amount: amount.toString(), denom: denom }];
}
function prepareBuilder(buider) {
    if (buider === undefined) {
        return ""; // normalization needed by backend
    }
    else {
        if (!builder_1.isValidBuilder(buider))
            throw new Error("The builder (Docker Hub image with tag) is not valid");
        return buider;
    }
}
const defaultFees = {
    upload: {
        amount: singleAmount(250000, "uscrt"),
        gas: String(1000000),
    },
    init: {
        amount: singleAmount(125000, "uscrt"),
        gas: String(500000),
    },
    exec: {
        amount: singleAmount(50000, "uscrt"),
        gas: String(200000),
    },
    send: {
        amount: singleAmount(20000, "uscrt"),
        gas: String(80000),
    },
};
class SigningCosmWasmClient extends cosmwasmclient_1.CosmWasmClient {
    /**
     * Creates a new client with signing capability to interact with a CosmWasm blockchain. This is the bigger brother of CosmWasmClient.
     *
     * This instance does a lot of caching. In order to benefit from that you should try to use one instance
     * for the lifetime of your application. When switching backends, a new instance must be created.
     *
     * @param apiUrl The URL of a Cosmos SDK light client daemon API (sometimes called REST server or REST API)
     * @param senderAddress The address that will sign and send transactions using this instance
     * @param signer An asynchronous callback to create a signature for a given transaction. This can be implemented using secure key stores that require user interaction. Or a newer OfflineSigner type that handles that stuff
     * @param seedOrEnigmaUtils
     * @param customFees The fees that are paid for transactions
     * @param broadcastMode Defines at which point of the transaction processing the postTx method (i.e. transaction broadcasting) returns
     */
    constructor(apiUrl, senderAddress, signer, seedOrEnigmaUtils, customFees, broadcastMode = restclient_1.BroadcastMode.Block) {
        if (seedOrEnigmaUtils instanceof Uint8Array) {
            super(apiUrl, seedOrEnigmaUtils, broadcastMode);
        }
        else {
            super(apiUrl, undefined, broadcastMode);
        }
        this.anyValidAddress = senderAddress;
        this.senderAddress = senderAddress;
        //this.signCallback = signCallback ? signCallback : undefined;
        this.signer = signer;
        if (seedOrEnigmaUtils && !(seedOrEnigmaUtils instanceof Uint8Array)) {
            this.restClient.enigmautils = seedOrEnigmaUtils;
        }
        this.fees = Object.assign(Object.assign({}, defaultFees), (customFees || {}));
        // // Setup contract->hash cache
        // // This is only needed here and not in CosmWasmClient because we
        // // need code hashes before sending txs
        // this.restClient.listCodeInfo().then(async (codes) => {
        //   for (const code of codes) {
        //     this.restClient.codeHashCache.set(code.id, code.data_hash);
        //     const contracts = await this.restClient.listContractsByCodeId(code.id);
        //     for (const contract of contracts) {
        //       this.restClient.codeHashCache.set(contract.address, code.data_hash);
        //     }
        //   }
        // });
    }
    async getNonce(address) {
        return super.getNonce(address || this.senderAddress);
    }
    async getAccount(address) {
        return super.getAccount(address || this.senderAddress);
    }
    async signAdapter(msgs, fee, chainId, memo, accountNumber, sequence) {
        // offline signer interface
        if ("sign" in this.signer) {
            const signResponse = await this.signer.sign(this.senderAddress, {
                chain_id: chainId,
                account_number: String(accountNumber),
                sequence: String(sequence),
                fee: fee,
                msgs: msgs,
                memo: memo,
            });
            return {
                msg: msgs,
                fee: signResponse.signed.fee,
                memo: signResponse.signed.memo,
                signatures: [signResponse.signature],
            };
        }
        else {
            // legacy interface
            const signBytes = encoding_2.makeSignBytes(msgs, fee, chainId, memo, accountNumber, sequence);
            const signature = await this.signer(signBytes);
            return {
                msg: msgs,
                fee: fee,
                memo: memo,
                signatures: [signature],
            };
        }
    }
    /** Uploads code and returns a receipt, including the code ID */
    async upload(wasmCode, meta = {}, memo = "", fee = this.fees.upload) {
        const source = meta.source || "";
        const builder = prepareBuilder(meta.builder);
        const compressed = pako_1.default.gzip(wasmCode, { level: 9 });
        const storeCodeMsg = {
            type: "wasm/MsgStoreCode",
            value: {
                sender: this.senderAddress,
                // eslint-disable-next-line @typescript-eslint/camelcase
                wasm_byte_code: encoding_1.Encoding.toBase64(compressed),
                source: source,
                builder: builder,
            },
        };
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([storeCodeMsg], fee, chainId, memo, accountNumber, sequence);
        const result = await this.postTx(signedTx);
        const codeIdAttr = logs_1.findAttribute(result.logs, "message", "code_id");
        return {
            originalSize: wasmCode.length,
            originalChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(wasmCode).digest()),
            compressedSize: compressed.length,
            compressedChecksum: encoding_1.Encoding.toHex(new crypto_1.Sha256(compressed).digest()),
            codeId: Number.parseInt(codeIdAttr.value, 10),
            logs: result.logs,
            transactionHash: result.transactionHash,
        };
    }
    async instantiate(codeId, initMsg, label, memo = "", transferAmount, fee = this.fees.init, contractCodeHash) {
        var _a;
        if (!contractCodeHash) {
            contractCodeHash = await this.restClient.getCodeHashByCodeId(codeId);
        }
        else {
            this.restClient.codeHashCache.set(codeId, contractCodeHash);
        }
        if (!memo) {
            memo = "";
        }
        const instantiateMsg = {
            type: "wasm/MsgInstantiateContract",
            value: {
                sender: this.senderAddress,
                code_id: codeId.toString(),
                label: label,
                callback_code_hash: "",
                init_msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, initMsg)),
                init_funds: (transferAmount !== null && transferAmount !== void 0 ? transferAmount : []),
                callback_sig: null,
            },
        };
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([instantiateMsg], fee, chainId, memo, accountNumber, sequence);
        const nonce = encoding_1.Encoding.fromBase64(instantiateMsg.value.init_msg).slice(0, 32);
        let result;
        try {
            result = await this.postTx(signedTx);
        }
        catch (err) {
            try {
                const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: 0/g;
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || rgxMatches.length != 2) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);
            }
            throw err;
        }
        let contractAddress = "";
        if (this.restClient.broadcastMode == restclient_1.BroadcastMode.Block) {
            contractAddress = (_a = logs_1.findAttribute(result.logs, "message", "contract_address")) === null || _a === void 0 ? void 0 : _a.value;
        }
        const logs = await this.restClient.decryptLogs(result.logs, [nonce]);
        return {
            contractAddress,
            logs: logs,
            transactionHash: result.transactionHash,
            data: result.data,
        };
    }
    async multiExecute(inputMsgs, memo = "", totalFee) {
        var _a;
        if (!memo) {
            memo = "";
        }
        const msgs = [];
        for (const inputMsg of inputMsgs) {
            let { contractCodeHash } = inputMsg;
            if (!contractCodeHash) {
                contractCodeHash = await this.restClient.getCodeHashByContractAddr(inputMsg.contractAddress);
            }
            else {
                this.restClient.codeHashCache.set(inputMsg.contractAddress, contractCodeHash);
            }
            const msg = {
                type: "wasm/MsgExecuteContract",
                value: {
                    sender: this.senderAddress,
                    contract: inputMsg.contractAddress,
                    callback_code_hash: "",
                    msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, inputMsg.handleMsg)),
                    sent_funds: (_a = inputMsg.transferAmount, (_a !== null && _a !== void 0 ? _a : [])),
                    callback_sig: null,
                },
            };
            msgs.push(msg);
        }
        const { accountNumber, sequence } = await this.getNonce();
        const fee = (totalFee !== null && totalFee !== void 0 ? totalFee : {
            gas: String(Number(this.fees.exec.gas) * inputMsgs.length),
            amount: this.fees.exec.amount,
        });
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter(msgs, fee, chainId, memo, accountNumber, sequence);
        let result;
        try {
            result = await this.postTx(signedTx);
        }
        catch (err) {
            try {
                const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: (\d+)/g;
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || rgxMatches.length != 3) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const msgIndex = Number(rgxMatches[2]);
                const nonce = encoding_1.Encoding.fromBase64(msgs[msgIndex].value.msg).slice(0, 32);
                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);
            }
            throw err;
        }
        const nonces = msgs.map((msg) => encoding_1.Encoding.fromBase64(msg.value.msg).slice(0, 32));
        const data = await this.restClient.decryptDataField(result.data, nonces);
        const logs = await this.restClient.decryptLogs(result.logs, nonces);
        return {
            logs: logs,
            transactionHash: result.transactionHash,
            data: data,
        };
    }
    async execute(contractAddress, handleMsg, memo = "", transferAmount, fee = this.fees.exec, contractCodeHash) {
        if (!contractCodeHash) {
            contractCodeHash = await this.restClient.getCodeHashByContractAddr(contractAddress);
        }
        else {
            this.restClient.codeHashCache.set(contractAddress, contractCodeHash);
        }
        if (!memo) {
            memo = "";
        }
        const executeMsg = {
            type: "wasm/MsgExecuteContract",
            value: {
                sender: this.senderAddress,
                contract: contractAddress,
                callback_code_hash: "",
                msg: encoding_1.Encoding.toBase64(await this.restClient.enigmautils.encrypt(contractCodeHash, handleMsg)),
                sent_funds: (transferAmount !== null && transferAmount !== void 0 ? transferAmount : []),
                callback_sig: null,
            },
        };
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([executeMsg], fee, chainId, memo, accountNumber, sequence);
        const nonce = encoding_1.Encoding.fromBase64(executeMsg.value.msg).slice(0, 32);
        let result;
        try {
            result = await this.postTx(signedTx);
        }
        catch (err) {
            try {
                const errorMessageRgx = /contract failed: encrypted: (.+?): failed to execute message; message index: 0/g;
                const rgxMatches = errorMessageRgx.exec(err.message);
                if (rgxMatches == null || rgxMatches.length != 2) {
                    throw err;
                }
                const errorCipherB64 = rgxMatches[1];
                const errorCipherBz = encoding_1.Encoding.fromBase64(errorCipherB64);
                const errorPlainBz = await this.restClient.enigmautils.decrypt(errorCipherBz, nonce);
                err.message = err.message.replace(errorCipherB64, encoding_1.Encoding.fromUtf8(errorPlainBz));
            }
            catch (decryptionError) {
                throw new Error(`Failed to decrypt the following error message: ${err.message}. Decryption error of the error message: ${decryptionError.message}`);
            }
            throw err;
        }
        const data = await this.restClient.decryptDataField(result.data, [nonce]);
        const logs = await this.restClient.decryptLogs(result.logs, [nonce]);
        return {
            logs: logs,
            transactionHash: result.transactionHash,
            data: data,
        };
    }
    async sendTokens(recipientAddress, transferAmount, memo = "", fee = this.fees.send) {
        const sendMsg = {
            type: "cosmos-sdk/MsgSend",
            value: {
                // eslint-disable-next-line @typescript-eslint/camelcase
                from_address: this.senderAddress,
                // eslint-disable-next-line @typescript-eslint/camelcase
                to_address: recipientAddress,
                amount: transferAmount,
            },
        };
        if (!memo) {
            memo = "";
        }
        const { accountNumber, sequence } = await this.getNonce();
        const chainId = await this.getChainId();
        const signedTx = await this.signAdapter([sendMsg], fee, chainId, memo, accountNumber, sequence);
        return this.postTx(signedTx);
    }
}
exports.SigningCosmWasmClient = SigningCosmWasmClient;
//# sourceMappingURL=signingcosmwasmclient.js.map